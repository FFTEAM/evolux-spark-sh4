diff -Nur '--exclude-from=neutrino-hd_ignore' neutrino-hd2-exp.org/acinclude.m4 neutrino-hd2-exp/acinclude.m4
--- neutrino-hd2-exp.org/acinclude.m4	2012-08-25 22:02:02.410886888 +0200
+++ neutrino-hd2-exp/acinclude.m4	2012-08-25 22:02:02.586796676 +0200
@@ -225,10 +225,10 @@
 AC_DEFUN([_TUXBOX_APPS_LIB_PKGCONFIG],[
 AC_REQUIRE([TUXBOX_APPS_PKGCONFIG])
 AC_MSG_CHECKING(for package $2)
-if PKG_CONFIG_PATH="${prefix}/lib/pkgconfig" $PKG_CONFIG --exists "$2" ; then
+if $PKG_CONFIG --exists "$2" ; then
 	AC_MSG_RESULT(yes)
-	$1_CFLAGS=$(PKG_CONFIG_PATH="${prefix}/lib/pkgconfig" $PKG_CONFIG --cflags "$2")
-	$1_LIBS=$(PKG_CONFIG_PATH="${prefix}/lib/pkgconfig" $PKG_CONFIG --libs "$2")
+	$1_CFLAGS=$($PKG_CONFIG --cflags "$2")
+	$1_LIBS=$($PKG_CONFIG --libs "$2")
 else
 	AC_MSG_RESULT(no)
 fi
diff -Nur '--exclude-from=neutrino-hd_ignore' neutrino-hd2-exp.org/src/nhttpd/web/scripts/Makefile.am neutrino-hd2-exp/src/nhttpd/web/scripts/Makefile.am
--- neutrino-hd2-exp.org/src/nhttpd/web/scripts/Makefile.am	2012-08-25 22:01:57.585361584 +0200
+++ neutrino-hd2-exp/src/nhttpd/web/scripts/Makefile.am	2012-08-25 22:02:02.586796676 +0200
@@ -3,5 +3,5 @@
 install_DATA= api.sh _Y_Globals.sh _Y_Library.sh Y_Live.sh Y_Tools.sh
 
 install-data-hook:
-	chmod 0755 $(DATADIR)/neutrino/httpd/scripts/api.sh
-	chmod 0755 $(DATADIR)/neutrino/httpd/scripts/Y_*.sh
+	chmod 0755 $(DESTDIR)$(DATADIR)/neutrino/httpd/scripts/api.sh
+	chmod 0755 $(DESTDIR)$(DATADIR)/neutrino/httpd/scripts/Y_*.sh


//--- neutrino-hd2-exp/lib/libcoolstream/record_cs.cpp	2012-10-10 10:46:51.357580061 +0200
//+++ neutrino-hd2-exp/lib/libcoolstream/record_cs.cpp	2012-10-10 10:46:34.977498845 +0200
//@@ -72,7 +72,11 @@
// 	int i;
 
// 	if (!dmx)
//+#if defined (PLATFORM_SPARK7162)
//+		dmx = new cDemux(/*dmx_num*/);
//+#else
// 		dmx = new cDemux(dmx_num);
//+#endif
 
// 	dmx->Open(DMX_TP_CHANNEL, /*3 * 3008 * 62*/RECORD_STREAM_BUFFER_SIZE, fe_num );
// 	dmx->pesFilter(vpid);


////////////////////////
// extramenu patches ///
////////////////////////
--- neutrino-hd2-exp/src/gui/widget/menue.cpp	2012-10-21 16:09:01.871337465 +0200
+++ neutrino-hd2-exp/src/gui/widget/menue.cpp	2012-10-21 15:56:08.875504381 +0200
@@ -2123,3 +2123,14 @@
         return menu_return::RETURN_EXIT;
 }
 
+void CMenuForwarder::setOptionValue(const char * const Option)
+{
+	option = Option;
+	option_string = NULL;
+}
+
+void CMenuForwarder::setOptionValue(const std::string &Option)
+{
+	option = NULL;
+	option_string = &Option;
+}

--- neutrino-hd2-exp/src/gui/widget/menue.h	2012-10-21 16:13:02.680531577 +0200
+++ neutrino-hd2-exp/src/gui/widget/menue.h	2012-10-21 15:03:50.299941019 +0200
@@ -195,6 +195,8 @@
 		{
 			return active;
 		}
+		void setOptionValue(const char * const Option);
+		void setOptionValue(const std::string &Option);
 };
 
 class CMenuForwarderItemMenuIcon : public CMenuItem


--- neutrino-hd2-exp/src/system/locals_intern.h	2012-10-21 16:17:29.633855316 +0200
+++ neutrino-hd2-exp/src/system/locals_intern.h	2012-10-21 15:40:23.854818280 +0200
@@ -547,6 +547,7 @@
 	"messagebox.no",
 	"messagebox.ok",
 	"messagebox.yes",
+	"messagebox.accept",
 	"miscsettings.bootinfo",
 	"miscsettings.bootmenu",
 	"miscsettings.channellist",
@@ -1552,6 +1553,83 @@
 	"keybinding.key_timelist",
 	"keybinding.key_net",
 	"keybinding.key_video_player",
+
+	"mainmenu.extramenu",
+	"extramenu.tunerreset",
+	"extramenu.tunerreset.select",
+	"extramenu.tunerreset.on",
+	"extramenu.tunerreset.off",
+	"extramenu.tunerreset.restart",
+	"extramenu.correctvolume",
+	"extramenu.correctvolume.select",
+	"extramenu.correctvolume.on",
+	"extramenu.correctvolume.off",
+	"extramenu.amount",
+	"extramenu.amount.select",
+	"extramenu.amount.on",
+	"extramenu.amount.off",
+	"extramenu.displaytime",
+	"extramenu.displaytime.select",
+	"extramenu.displaytime.on",
+	"extramenu.displaytime.off",
+	"extramenu.wwwdate",
+	"extramenu.wwwdate.select",
+	"extramenu.wwwdate.on",
+	"extramenu.wwwdate.off",
+	"extramenu.checkfs",
+	"extramenu.checkfs.select",
+	"extramenu.checkfs.on",
+	"extramenu.checkfs.off",
+	"extramenu.emu",
+	"extramenu.emu.none",
+	"extramenu.emu.mgcamd",
+	"extramenu.emu.incubus",
+	"extramenu.emu.camd3",
+	"extramenu.emu.mbox",
+	"extramenu.emu.oscam",
+	"extramenu.emu.spcs",
+	"extramenu.emu.select",
+	"extramenu.emu.restart",
+	"extramenu.emu.disable",
+	"extramenu.swap",
+	"extramenu.swap.swapram",
+	"extramenu.swap.swappart",
+	"extramenu.swap.swapfile",
+	"extramenu.swap.select",
+	"extramenu.swap.onoff",
+	"extramenu.boot.head",
+	"extramenu.boot.select",
+	"extramenu.boot.unchanged",
+	"extramenu.boot.bootargs.head",
+	"extramenu.boot.bootargs.text",
+	"extramenu.fsck",
+	"extramenu.fsck.select",
+	"extramenu.fsck.on",
+	"extramenu.fsck.off",
+	"extramenu.nfsserver",
+	"extramenu.nfsserver.select",
+	"extramenu.nfsserver.on",
+	"extramenu.nfsserver.off",
+	"extramenu.stmfb",
+	"extramenu.stmfb.select",
+	"extramenu.stmfb.on",
+	"extramenu.stmfb.off",
+	"extramenu.fritzcall",
+	"extramenu.fritzcall.select",
+	"extramenu.fritzcall.on",
+	"extramenu.fritzcall.off",
+	"extramenu.evoluxupdate",
+	"extramenu.evoluxupdate.select",
+	"extramenu.evoluxupdate.on",
+	"extramenu.evoluxupdate.off",
+	"extramenu.evoluxupdate.update",
+	"extramenu.kerneloptions",
+	"extramenu.kerneloptions.apply",
+	"extramenu.kerneloptions.lsmod",
+	"extramenu.kerneloptions.modules",
+	"extramenu.kerneloptions.reset",
+	"onoff.on",
+	"onoff.off",
 	
 	"audiomenu.volumebar_audiosteps",
 };


--- neutrino-hd2-exp/src/system/locals.h	2012-10-21 16:19:09.050348294 +0200
+++ neutrino-hd2-exp/src/system/locals.h	2012-10-21 15:40:48.038938204 +0200
@@ -547,6 +547,7 @@
 	LOCALE_MESSAGEBOX_NO,
 	LOCALE_MESSAGEBOX_OK,
 	LOCALE_MESSAGEBOX_YES,
+	LOCALE_MESSAGEBOX_ACCEPT,
 	LOCALE_MISCSETTINGS_BOOTINFO,
 	LOCALE_MISCSETTINGS_BOOTMENU,
 	LOCALE_MISCSETTINGS_CHANNELLIST,
@@ -1552,6 +1553,82 @@
 	LOCALE_KEYBINDINGMENU_TIMELIST,
 	LOCALE_KEYBINDINGMENU_NET,
 	LOCALE_KEYBINDINGMENU_VIDEO_PLAYER,
+	LOCALE_MAINMENU_EXTRAMENU ,
+	LOCALE_EXTRAMENU_TUNERRESET ,
+	LOCALE_EXTRAMENU_TUNERRESET_SELECT ,
+	LOCALE_EXTRAMENU_TUNERRESET_ON ,
+	LOCALE_EXTRAMENU_TUNERRESET_OFF ,
+	LOCALE_EXTRAMENU_TUNERRESET_RESTART,
+	LOCALE_EXTRAMENU_CORRECTVOLUME,
+	LOCALE_EXTRAMENU_CORRECTVOLUME_SELECT,
+	LOCALE_EXTRAMENU_CORRECTVOLUME_ON,
+	LOCALE_EXTRAMENU_CORRECTVOLUME_OFF,
+	LOCALE_EXTRAMENU_AMOUNT,
+	LOCALE_EXTRAMENU_AMOUNT_SELECT,
+	LOCALE_EXTRAMENU_AMOUNT_ON,
+	LOCALE_EXTRAMENU_AMOUNT_OFF,
+	LOCALE_EXTRAMENU_DISPLAYTIME,
+	LOCALE_EXTRAMENU_DISPLAYTIME_SELECT,
+	LOCALE_EXTRAMENU_DISPLAYTIME_ON,
+	LOCALE_EXTRAMENU_DISPLAYTIME_OFF,
+	LOCALE_EXTRAMENU_WWWDATE,
+	LOCALE_EXTRAMENU_WWWDATE_SELECT,
+	LOCALE_EXTRAMENU_WWWDATE_ON,
+	LOCALE_EXTRAMENU_WWWDATE_OFF,
+	LOCALE_EXTRAMENU_CHECKFS,
+	LOCALE_EXTRAMENU_CHECKFS_SELECT,
+	LOCALE_EXTRAMENU_CHECKFS_ON,
+	LOCALE_EXTRAMENU_CHECKFS_OFF,
+	LOCALE_EXTRAMENU_EMU,
+	LOCALE_EXTRAMENU_EMU_NONE,
+	LOCALE_EXTRAMENU_EMU_MGCAMD,
+	LOCALE_EXTRAMENU_EMU_INCUBUS,
+	LOCALE_EXTRAMENU_EMU_CAMD3,
+	LOCALE_EXTRAMENU_EMU_MBOX,
+	LOCALE_EXTRAMENU_EMU_OSCAM ,
+	LOCALE_EXTRAMENU_EMU_SPCS ,
+	LOCALE_EXTRAMENU_EMU_SELECT,
+	LOCALE_EXTRAMENU_EMU_RESTART,
+	LOCALE_EXTRAMENU_EMU_DISABLE,
+	LOCALE_EXTRAMENU_SWAP,
+	LOCALE_EXTRAMENU_SWAP_SWAPRAM,
+	LOCALE_EXTRAMENU_SWAP_SWAPPART,
+	LOCALE_EXTRAMENU_SWAP_SWAPFILE,
+	LOCALE_EXTRAMENU_SWAP_SELECT,
+	LOCALE_EXTRAMENU_SWAP_ONOFF,
+	LOCALE_EXTRAMENU_BOOT_HEAD,
+	LOCALE_EXTRAMENU_BOOT_SELECT,
+	LOCALE_EXTRAMENU_BOOT_UNCHANGED,
+	LOCALE_EXTRAMENU_BOOT_BOOTARGS_HEAD,
+	LOCALE_EXTRAMENU_BOOT_BOOTARGS_TEXT,
+	LOCALE_EXTRAMENU_FSCK,
+	LOCALE_EXTRAMENU_FSCK_SELECT,
+	LOCALE_EXTRAMENU_FSCK_ON,
+	LOCALE_EXTRAMENU_FSCK_OFF,
+	LOCALE_EXTRAMENU_NFSSERVER,
+	LOCALE_EXTRAMENU_NFSSERVER_SELECT,
+	LOCALE_EXTRAMENU_NFSSERVER_ON,
+	LOCALE_EXTRAMENU_NFSSERVER_OFF,
+	LOCALE_EXTRAMENU_STMFB,
+	LOCALE_EXTRAMENU_STMFB_SELECT,
+	LOCALE_EXTRAMENU_STMFB_ON,
+	LOCALE_EXTRAMENU_STMFB_OFF,
+	LOCALE_EXTRAMENU_FRITZCALL,
+	LOCALE_EXTRAMENU_FRITZCALL_SELECT,
+	LOCALE_EXTRAMENU_FRITZCALL_ON,
+	LOCALE_EXTRAMENU_FRITZCALL_OFF,
+	LOCALE_EXTRAMENU_EVOLUXUPDATE,
+	LOCALE_EXTRAMENU_EVOLUXUPDATE_SELECT,
+	LOCALE_EXTRAMENU_EVOLUXUPDATE_ON,
+	LOCALE_EXTRAMENU_EVOLUXUPDATE_OFF,
+	LOCALE_EXTRAMENU_EVOLUXUPDATE_UPDATE,
+	LOCALE_EXTRAMENU_KERNELOPTIONS,
+	LOCALE_EXTRAMENU_KERNELOPTIONS_APPLY,
+	LOCALE_EXTRAMENU_KERNELOPTIONS_LSMOD,
+	LOCALE_EXTRAMENU_KERNELOPTIONS_MODULES,
+	LOCALE_EXTRAMENU_KERNELOPTIONS_RESET,
+	LOCALE_ONOFF_ON,
+	LOCALE_ONOFF_OFF,
 	
 	LOCALE_AUDIOMENU_VOLUMEBAR_AUDIOSTEPS,
 } neutrino_locale_t;

--- neutrino-hd2-exp/data/locale/english.locale	2012-10-21 18:16:56.041391617 +0200
+++ neutrino-hd2-exp/data/locale/english.locale	2012-10-21 18:45:30.769894488 +0200
@@ -1542,4 +1543,122 @@
 
 audiomenu.volumebar_audiosteps Volume Step Size
 
+mainmenu.extramenu Extras
+extramenu.tunerreset Tuner Menue
+extramenu.tunerreset.select Tuner Reset
+extramenu.tunerreset.on On
+extramenu.tunerreset.off Off
+extramenu.tunerreset.restart restart Tuner
+extramenu.correctvolume Volume Menue Ext.
+extramenu.correctvolume.select Correct Volume
+extramenu.correctvolume.on On
+extramenu.correctvolume.off Off
+extramenu.amount Amount Menue
+extramenu.amount.select Amount
+extramenu.amount.on On
+extramenu.amount.off Off
+extramenu.displaytime DisplayTime Menue
+extramenu.displaytime.select DisplayTime
+extramenu.displaytime.on On
+extramenu.displaytime.off Off
+extramenu.wwwdate wwwDate Menue
+extramenu.wwwdate.select wwwDate
+extramenu.wwwdate.on Ein
+extramenu.wwwdate.off Aus
+extramenu.checkfs CheckFS Menue
+extramenu.checkfs.select CheckFS
+extramenu.checkfs.on On
+extramenu.checkfs.off Off
+extramenu.emu Cam Menue
+extramenu.emu.none not aktiv
+extramenu.emu.mgcamd MGCamd
+extramenu.emu.incubus IncubusCamd
+extramenu.emu.camd3 Camd3
+extramenu.emu.mbox Mbox
+extramenu.emu.oscam Oscam
+extramenu.emu.spcs Spcs
+extramenu.emu.select Cam Select
+extramenu.emu.restart restart Cam
+extramenu.emu.disable deactivate Cam
+extramenu.swap Swap Menue
+extramenu.swap.swapram SWAPRAM
+extramenu.swap.swappart SWAPPART
+extramenu.swap.swapfile SWAPFILE
+extramenu.swap.select Swap Select
+extramenu.swap.onoff SWAP
+extramenu.boot.head Boot-Settings
+extramenu.boot.select Startsystem on Reboot
+extramenu.boot.unchanged Unchanged
+extramenu.boot.bootargs.head Change Boot-Parameter now
+extramenu.boot.bootargs.text Don't turn box off now... wait...!
+extramenu.fsck FSCK Menue
+extramenu.fsck.select FSCK
+extramenu.fsck.on On
+extramenu.fsck.off Off
+extramenu.nfsserver NFSSERVER Menue
+extramenu.nfsserver.select NFSSERVER
+extramenu.nfsserver.on On
+extramenu.nfsserver.off Off
+extramenu.stmfb STMFB Menue
+extramenu.stmfb.select STMFB 15m
+extramenu.stmfb.on On
+extramenu.stmfb.off Off
+extramenu.fritzcall Fritzcall Menue
+extramenu.fritzcall.select Fritzcallmonitor
+extramenu.fritzcall.on On
+extramenu.fritzcall.off Off
+extramenu.evoluxupdate Evolux OnlineUpdate
+extramenu.evoluxupdate.select OnlineUpdate
+extramenu.evoluxupdate.on On
+extramenu.evoluxupdate.off Off
+extramenu.evoluxupdate.update do OnlineUpdate
+extramenu.kerneloptions Kernel-Options
+extramenu.kerneloptions.apply apply Settings
+extramenu.kerneloptions.lsmod Status
+extramenu.kerneloptions.modules Kernel-Module
+extramenu.kerneloptions.reset reset Settings
+extramenu.glcd.volume Volume
+extramenu.glcd.color.black black
+extramenu.glcd.color.white white
+extramenu.glcd.color.red red
+extramenu.glcd.color.green green
+extramenu.glcd.color.blue blue
+extramenu.glcd.color.magenta magenta
+extramenu.glcd.color.cyan bluegreen
+extramenu.glcd.color.yellow yellow
+extramenu.glcd GraphLCD
+extramenu.glcd.select.fg Foreground-Colour
+extramenu.glcd.select.bg Background-Colour
+extramenu.glcd.select.bar Bar-Colour
+extramenu.glcd.size_channel Chan-Size
+extramenu.glcd.size_epg EPG-Size
+extramenu.glcd.size_bar Bar-Size
+extramenu.glcd.size_time Time-Size
+extramenu.glcd.restart Research
+extramenu.glcd.mirror_osd show Menue on GraphLCD
+extramenu.glcd.time_in_standby show Time on Standby
+onoff.on On
+onoff.off Off
+glcd.color.black black
+glcd.color.blue blue
+glcd.color.cyan bluegreen
+glcd.color.green green
+glcd.color.magenta magenta
+glcd.color.red red
+glcd.color.white white
+glcd.color.yellow yellow
+glcd.enable GraphLCD aktive
+glcd.font Fonts
+glcd.head GraphLCD
+glcd.mirror_osd show OSD-Menü on GraphLCD
+glcd.restart Rescan
+glcd.select.bar Bar-Colour
+glcd.select.bg Background-Colour
+glcd.select.fg Foreground-Colour
+glcd.size_bar Bar-Size
+glcd.size_channel Chan-Size
+glcd.size_epg EPG-Size
+glcd.size_time Time-Size
+glcd.time_in_standby show time on standby
+glcd.volume Volume
 

--- neutrino-hd2-exp/data/locale/deutsch.locale	2012-10-21 16:20:41.114804828 +0200
+++ neutrino-hd2-exp/data/locale/deutsch.locale	2012-10-21 15:41:08.487039606 +0200
@@ -705,6 +705,7 @@
 messagebox.no Nein
 messagebox.ok OK
 messagebox.yes Ja
+messagebox.accept Wollen Sie die Änderungen beibehalten?
 miscsettings.bootinfo Infos beim Booten anzeigen
 miscsettings.bootmenu Bootmenü anzeigen
 miscsettings.channellist Kanalliste
@@ -1544,4 +1546,100 @@
 
 audiomenu.volumebar_audiosteps Lautstärke Schrittweite
 
+mainmenu.extramenu Extras
+extramenu.tunerreset Tuner Menue
+extramenu.tunerreset.select Tuner Reset
+extramenu.tunerreset.on Ein
+extramenu.tunerreset.off Aus
+extramenu.tunerreset.restart Tuner neu starten
+extramenu.correctvolume Volume Menue Ext.
+extramenu.correctvolume.select Correct Volume
+extramenu.correctvolume.on Ein
+extramenu.correctvolume.off Aus
+extramenu.amount Amount Menue
+extramenu.amount.select Amount
+extramenu.amount.on Ein
+extramenu.amount.off Aus
+extramenu.displaytime DisplayTime Menue
+extramenu.displaytime.select DisplayTime
+extramenu.displaytime.on Ein
+extramenu.displaytime.off Aus
+extramenu.wwwdate wwwDate Menue
+extramenu.wwwdate.select wwwDate
+extramenu.wwwdate.on Ein
+extramenu.wwwdate.off Aus
+extramenu.checkfs CheckFS Menue
+extramenu.checkfs.select CheckFS
+extramenu.checkfs.on Ein
+extramenu.checkfs.off Aus
+extramenu.emu Cam Menue
+extramenu.emu.none Nicht aktiv
+extramenu.emu.mgcamd MGCamd
+extramenu.emu.incubus IncubusCamd
+extramenu.emu.camd3 Camd3
+extramenu.emu.mbox Mbox
+extramenu.emu.oscam Oscam
+extramenu.emu.spcs Spcs
+extramenu.emu.select Cam Auswahl
+extramenu.emu.restart Cam neu starten
+extramenu.emu.disable Cam deaktivieren
+extramenu.swap Swap Menue
+extramenu.swap.swapram SWAPRAM
+extramenu.swap.swappart SWAPPART
+extramenu.swap.swapfile SWAPFILE
+extramenu.swap.select Swap Auswahl
+extramenu.swap.onoff SWAP
+extramenu.boot.head Boot-Einstellungen
+extramenu.boot.select Startsystem bei Neustart
+extramenu.boot.unchanged Unverändert
+extramenu.boot.bootargs.head Änderung der Boot-Parameter
+extramenu.boot.bootargs.text Bitte den Receiver nicht ausschalten!
+extramenu.fsck FSCK Menue
+extramenu.fsck.select FSCK
+extramenu.fsck.on Ein
+extramenu.fsck.off Aus
+extramenu.nfsserver NFSSERVER Menue
+extramenu.nfsserver.select NFSSERVER
+extramenu.nfsserver.on Ein
+extramenu.nfsserver.off Aus
+extramenu.stmfb STMFB Menue
+extramenu.stmfb.select STMFB 15m
+extramenu.stmfb.on Ein
+extramenu.stmfb.off Aus
+extramenu.fritzcall Fritzcall Menue
+extramenu.fritzcall.select Fritzcallmonitor
+extramenu.fritzcall.on Ein
+extramenu.fritzcall.off Aus
+extramenu.evoluxupdate Evolux OnlineUpdate
+extramenu.evoluxupdate.select OnlineUpdate
+extramenu.evoluxupdate.on On
+extramenu.evoluxupdate.off Off
+extramenu.evoluxupdate.update OnlineUpdate ausführen
+extramenu.kerneloptions Kernel-Optionen
+extramenu.kerneloptions.apply Einstellungen anwenden
+extramenu.kerneloptions.lsmod Status
+extramenu.kerneloptions.modules Kernel-Module
+extramenu.kerneloptions.reset Einstellungen zurücksetzen
+extramenu.glcd.volume Lautstärke
+extramenu.glcd.color.black Schwarz
+extramenu.glcd.color.white Weiss
+extramenu.glcd.color.red Rot
+extramenu.glcd.color.green Grün
+extramenu.glcd.color.blue Blau
+extramenu.glcd.color.magenta Magenta
+extramenu.glcd.color.cyan Blaugrün
+extramenu.glcd.color.yellow Gelb
+extramenu.glcd GraphLCD
+extramenu.glcd.select.fg Vordergrund-Farbe
+extramenu.glcd.select.bg Hintergrund-Farbe
+extramenu.glcd.select.bar Fortschrittsbalken-Farbe
+extramenu.glcd.size_channel Sender-Größe
+extramenu.glcd.size_epg EPG-Größe
+extramenu.glcd.size_bar Fortschrittsbalken-Größe
+extramenu.glcd.size_time Uhrzeit-Größe
+extramenu.glcd.restart Neu erkennen
+extramenu.glcd.mirror_osd Menü auf GraphLCD anzeigen
+extramenu.glcd.time_in_standby Zeitanzeige in Standby
+onoff.on Ein
+onoff.off Aus
 

--- neutrino-hd2-exp/src/gui/Makefile.am	2012-10-21 16:23:08.683536677 +0200
+++ neutrino-hd2-exp/src/gui/Makefile.am	2012-10-21 15:21:56.569327570 +0200
@@ -43,7 +43,7 @@
 	filebrowser.cpp audioplayer.cpp nfs.cpp pictureviewer.cpp \
 	movieplayer.cpp rc_lock.cpp \
 	timeosd.cpp epgplus.cpp epg_menu.cpp \
-	streaminfo2.cpp dboxinfo.cpp \
+	streaminfo2.cpp dboxinfo.cpp extra_menu.cpp \
 	plugins.cpp imageinfo.cpp audio_select.cpp moviebrowser.cpp movieinfo.cpp \
 	scan_setup.cpp zapit_setup.cpp proxyserver_setup.cpp
 

--- neutrino-hd2-exp/src/gui/extra_menu.cpp	1970-01-01 01:00:00.000000000 +0100
+++ neutrino-hd2-exp/src/gui/extra_menu.cpp	2012-10-21 17:29:11.135185304 +0200
@@ -0,0 +1,1677 @@
+#define __USE_FILE_OFFSET64 1
+#include <gui/filebrowser.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/sysinfo.h>
+#include <sys/vfs.h>
+#include "libnet.h"
+#include <sys/wait.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <sstream>
+#include <iostream>
+#include <fstream>
+#include <map>
+#include <string>
+
+#include <unistd.h>
+
+#include <system/debug.h>
+#include <system/safe_system.h>
+#include <system/set_threadname.h>
+
+#include <global.h>
+#include <neutrino.h>
+
+#include "zapit/channel.h"
+
+#include <driver/fontrenderer.h>
+#include <driver/rcinput.h>
+#include <daemonc/remotecontrol.h>
+
+#include "widget/menue.h"
+#include "widget/messagebox.h"
+#include "widget/hintbox.h"
+#include "widget/colorchooser.h"
+#include "widget/keychooser.h"
+
+#include "widget/stringinput.h"
+#include "widget/stringinput_ext.h"
+
+#include "bouquetlist.h"
+#include "color.h"
+#include "eventlist.h"
+#include "infoviewer.h"
+
+#include "extra_menu.h"
+
+#define ONOFF_OPTION_COUNT 2
+
+const CMenuOptionChooser::keyval ONOFF_OPTIONS[ONOFF_OPTION_COUNT] = {
+	{ 0, LOCALE_ONOFF_OFF },
+	{ 1, LOCALE_ONOFF_ON },
+};
+
+static int touch(const char *filename) {
+	int fn = open(filename, O_RDWR | O_CREAT, 0644);
+	if (fn > -1) {
+		close(fn);
+		return -1;
+	}
+	return 0;
+}
+
+#if 0
+static int safe_system(const char *command) {
+	pid_t child = fork();
+	switch(child){
+		case -1:
+			return -1;
+		case 0:
+			for(int i = 3; i < 256 /* arbitrary, but high enough */; i++)
+				close(i);
+			signal(SIGTERM, SIG_DFL);
+			signal(SIGINT, SIG_DFL);
+			signal(SIGHUP, SIG_DFL);
+			execl("/bin/sh", "sh", "-c", command, NULL);
+			exit(-1);
+		default:
+			int status;
+			waitpid(child, &status, 0);
+			return status;
+	}
+}
+#endif
+
+
+static struct {
+#define EXTRA_CAM_SELECTED "cam_selected"
+        std::string	cam_selected;
+} settings;
+
+CConfigFile *configfile = NULL;
+
+static bool saveSettings() {
+	if (configfile) {
+		configfile->setString(EXTRA_CAM_SELECTED, settings.cam_selected);
+		configfile->saveConfig(EXTRA_SETTINGS_FILE);
+		return true;
+	}
+	return false;
+}
+
+static bool initSettings() {
+	settings.cam_selected = "disabled";
+}
+
+static bool loadSettings() {
+	if (!configfile) {
+		initSettings();
+		configfile = new CConfigFile('=');
+		if (configfile->loadConfig(EXTRA_SETTINGS_FILE)) {
+			settings.cam_selected = configfile->getString(EXTRA_CAM_SELECTED, "disabled");
+			return true;
+		}
+	}
+	return false;
+}
+
+# if 0 /* unused code */
+////////////////////////////// CORRECTVOLUME Menu ANFANG ////////////////////////////////////
+#define CORRECTVOLUME_OPTION_COUNT 2
+const CMenuOptionChooser::keyval CORRECTVOLUME_OPTIONS[CORRECTVOLUME_OPTION_COUNT] =
+{
+	{ 0, LOCALE_EXTRAMENU_CORRECTVOLUME_OFF },
+	{ 1, LOCALE_EXTRAMENU_CORRECTVOLUME_ON },
+};
+
+CORRECTVOLUME_Menu::CORRECTVOLUME_Menu()
+{
+	frameBuffer = CFrameBuffer::getInstance();
+	width = 600;
+	hheight = g_Font[SNeutrinoSettings::FONT_TYPE_MENU_TITLE]->getHeight();
+	mheight = g_Font[SNeutrinoSettings::FONT_TYPE_MENU]->getHeight();
+	height = hheight+13*mheight+ 10;
+
+	x=(((g_settings.screen_EndX- g_settings.screen_StartX)-width) / 2) + g_settings.screen_StartX;
+	y=(((g_settings.screen_EndY- g_settings.screen_StartY)-height) / 2) + g_settings.screen_StartY;
+}
+int CORRECTVOLUME_Menu::exec(CMenuTarget* parent, const std::string & actionKey)
+{
+	int res = menu_return::RETURN_REPAINT;
+
+	if (parent)
+	{
+	parent->hide();
+	}
+
+	CORRECTVOLUMESettings();
+
+	return res;
+}
+
+void CORRECTVOLUME_Menu::hide()
+{
+frameBuffer->paintBackgroundBoxRel(x,y, width,height);
+}
+
+void CORRECTVOLUME_Menu::CORRECTVOLUMESettings()
+{
+	int corrVol=0;
+	int save_value=0;
+	//UEBERPRUEFEN OB CORRECTVOLUME SCHON LAEUFT
+	FILE* fd1 = fopen("/etc/.corrVol", "r");
+	if(fd1)
+	{
+	corrVol=1;
+	fclose(fd1);
+	}
+	int old_corrVol=corrVol;
+	//MENU AUFBAUEN
+	CMenuWidget* menu = new CMenuWidget(LOCALE_EXTRAMENU_CORRECTVOLUME, "settings");
+	menu->addItem(GenericMenuSeparator);
+	menu->addItem(GenericMenuBack);
+	menu->addItem(GenericMenuSeparatorLine);
+	CMenuOptionChooser* oj1 = new CMenuOptionChooser(LOCALE_EXTRAMENU_CORRECTVOLUME_SELECT, &corrVol, CORRECTVOLUME_OPTIONS, CORRECTVOLUME_OPTION_COUNT,true);
+	menu->addItem( oj1 );
+	menu->exec (NULL, "");
+	menu->hide ();
+	delete menu;
+	// UEBERPRUEFEN OB SICH WAS GEAENDERT HAT
+	if (old_corrVol!=corrVol)
+	{
+	save_value=1;
+	}
+	// ENDE UEBERPRUEFEN OB SICH WAS GEAENDERT HAT
+
+	// AUSFUEHREN NUR WENN SICH WAS GEAENDERT HAT
+	if (save_value==1)
+	{
+	if (corrVol==1)
+	{
+	//CORRECTVOLUME STARTEN
+	safe_system("touch /etc/.corrVol");
+	safe_system("/etc/init.d/corrVol.sh &");
+	ShowHintUTF(LOCALE_MESSAGEBOX_INFO, "CORRECTVOLUME Activated!", 450, 2); // UTF-8("")
+	}
+	if (corrVol==0)
+	{
+	//CORRECTVOLUME BEENDEN
+	safe_system("rm /etc/.corrVol");
+	safe_system("killall -9 corrVol.sh");
+	ShowHintUTF(LOCALE_MESSAGEBOX_INFO, "CORRECTVOLUME Deactivated!", 450, 2); // UTF-8("")
+	}
+}
+//ENDE CORRECTVOLUME
+}
+////////////////////////////// CORRECTVOLUME Menu ENDE //////////////////////////////////////
+#endif
+
+////////////////////////////// TUNERRESET Menu ANFANG ////////////////////////////////////
+#define TUNERRESET_OPTION_COUNT 2
+const CMenuOptionChooser::keyval TUNERRESET_OPTIONS[TUNERRESET_OPTION_COUNT] =
+{
+	{ 0, LOCALE_EXTRAMENU_TUNERRESET_OFF },
+	{ 1, LOCALE_EXTRAMENU_TUNERRESET_ON },
+};
+
+TUNERRESET_Menu::TUNERRESET_Menu()
+{
+	frameBuffer = CFrameBuffer::getInstance();
+	width = 600;
+	hheight = g_Font[SNeutrinoSettings::FONT_TYPE_MENU_TITLE]->getHeight();
+	mheight = g_Font[SNeutrinoSettings::FONT_TYPE_MENU]->getHeight();
+	height = hheight+13*mheight+ 10;
+
+	x=(((g_settings.screen_EndX- g_settings.screen_StartX)-width) / 2) + g_settings.screen_StartX;
+	y=(((g_settings.screen_EndY- g_settings.screen_StartY)-height) / 2) + g_settings.screen_StartY;
+}
+
+int TUNERRESET_Menu::exec(CMenuTarget* parent, const std::string & actionKey)
+{
+	int res = menu_return::RETURN_REPAINT;
+	if(actionKey == "reset-usermenu") 
+	{
+		this->TunerReset();
+		return menu_return::RETURN_EXIT_ALL;
+	}
+	if(actionKey == "reset") 
+	{
+		this->TunerReset();
+		return res;
+	}
+
+	if (parent)
+		parent->hide();
+
+	TUNERRESETSettings();
+
+	return res;
+}
+
+void TUNERRESET_Menu::hide()
+{
+	frameBuffer->paintBackgroundBoxRel(x,y, width,height);
+}
+
+void TUNERRESET_Menu::TUNERRESETSettings()
+{
+	//MENU AUFBAUEN
+	CMenuWidget* menu = new CMenuWidget(LOCALE_EXTRAMENU_TUNERRESET, "settings");
+	menu->addItem(GenericMenuSeparator);
+	menu->addItem(GenericMenuBack);
+	menu->addItem(GenericMenuSeparatorLine);
+	menu->addItem(new CMenuForwarder(LOCALE_EXTRAMENU_TUNERRESET_RESTART, true, "", this, "reset", CRCInput::RC_red, NEUTRINO_ICON_BUTTON_RED));
+	menu->exec (NULL, "");
+	menu->hide ();
+	delete menu;
+}
+bool TUNERRESET_Menu::TunerReset()
+{
+	//TUNERRESET STARTEN
+	CHintBox * TunerResetBox = new CHintBox(LOCALE_EXTRAMENU_TUNERRESET_RESTART, "bitte warten, Tuner wird resettet");
+	TunerResetBox->paint();
+
+	safe_system("/usr/local/bin/pzapit -esb ; sleep 2 ; /usr/local/bin/pzapit -lsb");
+	TunerResetBox->hide();
+	delete TunerResetBox;
+}
+//ENDE TUNERRESET
+
+////////////////////////////// TUNERRESET Menu ENDE //////////////////////////////////////
+
+# if 0 /* unused code */
+////////////////////////////// AMOUNT Menu ANFANG ////////////////////////////////////
+#define AMOUNT_OPTION_COUNT 2
+const CMenuOptionChooser::keyval AMOUNT_OPTIONS[AMOUNT_OPTION_COUNT] =
+{
+	{ 0, LOCALE_EXTRAMENU_AMOUNT_OFF },
+	{ 1, LOCALE_EXTRAMENU_AMOUNT_ON },
+};
+
+AMOUNT_Menu::AMOUNT_Menu()
+{
+	frameBuffer = CFrameBuffer::getInstance();
+	width = 600;
+	hheight = g_Font[SNeutrinoSettings::FONT_TYPE_MENU_TITLE]->getHeight();
+	mheight = g_Font[SNeutrinoSettings::FONT_TYPE_MENU]->getHeight();
+	height = hheight+13*mheight+ 10;
+
+	x=(((g_settings.screen_EndX- g_settings.screen_StartX)-width) / 2) + g_settings.screen_StartX;
+	y=(((g_settings.screen_EndY- g_settings.screen_StartY)-height) / 2) + g_settings.screen_StartY;
+}
+int AMOUNT_Menu::exec(CMenuTarget* parent, const std::string & actionKey)
+{
+	int res = menu_return::RETURN_REPAINT;
+
+	if (parent)
+	{
+		parent->hide();
+	}
+
+	AMOUNTSettings();
+
+	return res;
+}
+
+void AMOUNT_Menu::hide()
+{
+	frameBuffer->paintBackgroundBoxRel(x,y, width,height);
+}
+
+void AMOUNT_Menu::AMOUNTSettings()
+{
+	int amount=0;
+	int save_value=0;
+	//UEBERPRUEFEN OB AMOUNT SCHON LAEUFT
+	FILE* fd1 = fopen("/etc/.byLabel", "r");
+	FILE* fd2 = fopen("/etc/.byDev", "r");
+	if(fd1)
+	{
+	amount=1;
+	fclose(fd1);
+	}
+	if(fd2)
+	{
+	amount=1;
+	fclose(fd2);
+	}
+	int old_amount=amount;
+	//MENU AUFBAUEN
+	CMenuWidget* menu = new CMenuWidget(LOCALE_EXTRAMENU_AMOUNT, "settings");
+	menu->addItem(GenericMenuSeparator);
+	menu->addItem(GenericMenuBack);
+	menu->addItem(GenericMenuSeparatorLine);
+	CMenuOptionChooser* oj1 = new CMenuOptionChooser(LOCALE_EXTRAMENU_AMOUNT_SELECT, &amount, AMOUNT_OPTIONS, AMOUNT_OPTION_COUNT,true);
+	menu->addItem( oj1 );
+	menu->exec (NULL, "");
+	menu->hide ();
+	delete menu;
+	// UEBERPRUEFEN OB SICH WAS GEAENDERT HAT
+	if (old_amount!=amount)
+	{
+	save_value=1;
+	}
+	// ENDE UEBERPRUEFEN OB SICH WAS GEAENDERT HAT
+
+	// AUSFUEHREN NUR WENN SICH WAS GEAENDERT HAT
+	if (save_value==1)
+	{
+	if (amount==1)
+	{
+	//AMOUNT STARTEN
+	safe_system("touch /etc/.byLabel");
+	safe_system("/etc/init.d/amount.sh &");
+	ShowHintUTF(LOCALE_MESSAGEBOX_INFO, "AMOUNT byLabel Activated!", 450, 2); // UTF-8("")
+	}
+	if (amount==0)
+	{
+	//AMOUNT BEENDEN
+	safe_system("rm /etc/.byLabel");
+	safe_system("rm /etc/.byDev");
+//	safe_system("killall -9 amount.sh");
+	ShowHintUTF(LOCALE_MESSAGEBOX_INFO, "AMOUNT byLabel Deactivated!\nPlease REBOOT", 450, 2); // UTF-8("")
+	}
+}
+//ENDE AMOUNT
+}
+////////////////////////////// AMOUNT Menu ENDE //////////////////////////////////////
+#endif
+
+#if 0
+////////////////////////////// CheckFS Menu ANFANG ////////////////////////////////////
+#define CHECKFS_OPTION_COUNT 2
+const CMenuOptionChooser::keyval CHECKFS_OPTIONS[CHECKFS_OPTION_COUNT] =
+{
+	{ 0, LOCALE_EXTRAMENU_CHECKFS_OFF },
+	{ 1, LOCALE_EXTRAMENU_CHECKFS_ON },
+};
+
+CHECKFS_Menu::CHECKFS_Menu()
+{
+	frameBuffer = CFrameBuffer::getInstance();
+	width = 600;
+	hheight = g_Font[SNeutrinoSettings::FONT_TYPE_MENU_TITLE]->getHeight();
+	mheight = g_Font[SNeutrinoSettings::FONT_TYPE_MENU]->getHeight();
+	height = hheight+13*mheight+ 10;
+
+	x=(((g_settings.screen_EndX- g_settings.screen_StartX)-width) / 2) + g_settings.screen_StartX;
+	y=(((g_settings.screen_EndY- g_settings.screen_StartY)-height) / 2) + g_settings.screen_StartY;
+}
+
+int CHECKFS_Menu::exec(CMenuTarget* parent, const std::string & actionKey)
+{
+	int res = menu_return::RETURN_REPAINT;
+
+	if (parent)
+		parent->hide();
+
+	CHECKFSSettings();
+
+	return res;
+}
+
+void CHECKFS_Menu::hide()
+{
+	frameBuffer->paintBackgroundBoxRel(x,y, width,height);
+}
+
+void CHECKFS_Menu::CHECKFSSettings()
+{
+#define DOTFILE_CHECKFS "/etc/.checkfs"
+	int checkfs = access(DOTFILE_CHECKFS, F_OK) ? 0 : 1;
+	int old_checkfs=checkfs;
+	//MENU AUFBAUEN
+	CMenuWidget* menu = new CMenuWidget(LOCALE_EXTRAMENU_CHECKFS, "settings");
+	menu->addItem(GenericMenuSeparator);
+	menu->addItem(GenericMenuBack);
+	menu->addItem(GenericMenuSeparatorLine);
+	CMenuOptionChooser* oj1 = new CMenuOptionChooser(LOCALE_EXTRAMENU_CHECKFS_SELECT, &checkfs, CHECKFS_OPTIONS, CHECKFS_OPTION_COUNT,true);
+	menu->addItem( oj1 );
+	menu->exec (NULL, "");
+	menu->hide ();
+	delete menu;
+	// UEBERPRUEFEN OB SICH WAS GEAENDERT HAT
+	if (old_checkfs!=checkfs)
+	{
+		if (checkfs==1)
+		{
+			//CHECKFS STARTEN
+			touch(DOTFILE_CHECKFS);
+			ShowHintUTF(LOCALE_MESSAGEBOX_INFO, "CHECKFS Activated!", 450, 2); // UTF-8("")
+		} else {
+			//CHECKFS BEENDEN
+			unlink(DOTFILE_CHECKFS);
+			ShowHintUTF(LOCALE_MESSAGEBOX_INFO, "CHECKFS Deactivated!", 450, 2); // UTF-8("")
+		}
+	}
+}
+////////////////////////////// CheckFS Menu ENDE //////////////////////////////////////
+#endif
+
+////////////////////////////// EMU choose Menu ANFANG ////////////////////////////////////
+
+#define EMU_OPTION_COUNT 8
+static EMU_Menu::emu_list EMU_list[EMU_OPTION_COUNT] =
+{
+	  { "disabled" }
+	, { "mgcamd", "rm -f /tmp/camd.socket >/dev/null; /usr/bin/mgcamd /var/keys/mg_cfg >/dev/null 2>&1 &", "kill -9 $(pidof mgcamd)", false }
+	, { "incubusCamd", "rm -f /tmp/camd.socket 2>/dev/null ; /usr/bin/incubusCamd >/dev/null 2>&1 &", "kill -9 $(pidof incubusCamd)", false }
+	, { "camd3", "/usr/bin/camd3 /var/keys/camd3.config >/dev/null 2>&1 &", "kill -9 $(pidof camd3)", false }
+	, { "mbox", "/usr/bin/mbox /var/keys/mbox.cfg >/dev/null 2>&1 &", "kill -9 $(pidof mbox) ; rm -f /tmp/share.* /tmp/mbox.ver /tmp/*.info 2>/dev/null", false }
+	, { "oscam", "/usr/bin/oscam -b -c /var/keys >/dev/null 2>&1 &", "kill -9 $(pidof oscam)", false }
+	, { "spcs", "/usr/bin/spcs -c /var/keys >/dev/null 2>&1 &", "kill -9 $(pidof spcs)", false }
+	, { "gbox", "/usr/bin/gbox >/dev/null 2>&1 &", "touch /tmp/gbox.kill", false }
+};
+
+int EMU_Menu::get_installed_count() {
+	return installed_count;
+}
+
+int EMU_Menu::update_installed()
+{
+	installed_count = 0;
+
+	for (int i = 1; i < EMU_OPTION_COUNT; i++) {
+		string e = "/usr/bin/" + string(EMU_list[i].procname);
+		if (!access(e.c_str(), X_OK)) {
+			EMU_list[i].installed = true;
+			installed_count++;
+		}
+	}
+
+	return installed_count;
+}
+
+int EMU_Menu::update_selected()
+{
+	for (int i = 1; i < EMU_OPTION_COUNT && !selected; i++)
+		if (!settings.cam_selected.compare(EMU_list[i].procname) && EMU_list[i].installed)
+			selected = i;
+	return selected;
+}
+
+static bool is_scrambled(void){
+	bool res = true;
+	CChannelList *channelList = CNeutrinoApp::getInstance()->channelList;
+	if (!channelList)
+		return res;
+	int curnum = channelList->getActiveChannelNumber();
+	if (curnum < -1)
+		return res;
+	CZapitChannel *channel = channelList->getChannel(curnum);
+	if (!channel)
+		return res;
+	return channel->scrambled ? true : false;
+}
+
+EMU_Menu::EMU_Menu()
+{
+	suspended = false;
+	selected = 0;
+
+	frameBuffer = CFrameBuffer::getInstance();
+	width = 600;
+	hheight = g_Font[SNeutrinoSettings::FONT_TYPE_MENU_TITLE]->getHeight();
+	mheight = g_Font[SNeutrinoSettings::FONT_TYPE_MENU]->getHeight();
+	height = hheight+13*mheight+ 10;
+
+	x=(((g_settings.screen_EndX- g_settings.screen_StartX)-width) / 2) + g_settings.screen_StartX;
+	y=(((g_settings.screen_EndY- g_settings.screen_StartY)-height) / 2) + g_settings.screen_StartY;
+
+	loadSettings();
+	update_installed();
+	update_selected();
+
+	if (selected > 0){
+		bool scrambled = false;
+		ifstream zc (CONFIGDIR "/zapit/zapit.conf");
+		string line;
+		while (zc.good() && !scrambled)
+			if (getline(zc, line) && !line.compare((line, "lastChannelTVScrambled=true")))
+					scrambled = true;
+		zc.close();
+
+		string cmd = "(" + string(EMU_list[selected].start_command)
+			+ ( scrambled ? "sleep 2 ; /usr/local/bin/pzapit -rz" : "" )
+			+ " >/dev/null 2>&1) &";
+		safe_system(cmd.c_str());
+	}
+	for (int i = 1; i < EMU_OPTION_COUNT; i++)
+		EMU_list[i].cmf = NULL;
+}
+
+int EMU_Menu::exec(CMenuTarget* parent, const std::string & actionKey)
+{
+	int res = menu_return::RETURN_REPAINT;
+
+	bool doReset = false;
+	int emu = selected;
+
+	if(actionKey == "disable")
+		emu = 0;
+	else if (actionKey == "reset") {
+		doReset = true;
+		emu = selected;
+	} else if (actionKey == "reset-usermenu") {
+		doReset = true;
+		emu = selected;
+		res = menu_return::RETURN_EXIT_ALL;
+	} else
+		for (emu = 1; emu < EMU_OPTION_COUNT; emu++)
+			if (!strcmp(EMU_list[emu].procname, actionKey.c_str()))
+				break;
+
+	if (emu < EMU_OPTION_COUNT) {
+		int emu_old = selected;
+		if ((emu_old != emu) || doReset) {
+			if (emu_old) {
+				safe_system(EMU_list[emu_old].stop_command);
+				string m = " " + string(EMU_list[emu_old].procname) + " is now inactive ";
+				ShowHintUTF(LOCALE_MESSAGEBOX_INFO, m.c_str(), 450, 2); // UTF-8("")
+				if (EMU_list[emu_old].cmf)
+					EMU_list[emu_old].cmf->setOptionValue(g_Locale->getText(LOCALE_ONOFF_OFF));
+			}
+			if (emu) {
+				safe_system(EMU_list[emu].start_command);
+
+				string cmd = "(" + string(EMU_list[emu].start_command);
+				if (is_scrambled())
+					safe_system("sleep 2; /usr/local/bin/pzapit -rz >/dev/null 2>&1");
+				string m = " " + string(EMU_list[emu].procname) + " is now active ";
+				ShowHintUTF(LOCALE_MESSAGEBOX_INFO, m.c_str(), 450, 2); // UTF-8("")
+				if (EMU_list[emu].cmf)
+					EMU_list[emu].cmf->setOptionValue(g_Locale->getText(LOCALE_ONOFF_ON));
+			}
+			settings.cam_selected = string(EMU_list[emu].procname);
+			selected = emu;
+		}
+
+		return res;
+	}
+
+	if (parent)
+		parent->hide();
+
+	EMU_Menu_Settings();
+
+	return res;
+}
+
+void EMU_Menu::hide()
+{
+	frameBuffer->paintBackgroundBoxRel(x,y, width,height);
+}
+
+void EMU_Menu::EMU_Menu_Settings()
+{
+	int emu = selected;
+	int emu_old = emu;
+
+	update_installed();
+
+	CMenuWidget* menu = new CMenuWidget(LOCALE_EXTRAMENU_EMU, "settings");
+	menu->addItem(GenericMenuSeparator);
+	menu->addItem(GenericMenuBack);
+	menu->addItem(GenericMenuSeparatorLine);
+
+	int shortcut = 1;
+	for (int i = 1; i < EMU_OPTION_COUNT; i++)
+		if (EMU_list[i].installed) {
+			EMU_list[i].cmf = new CMenuForwarderNonLocalized(EMU_list[i].procname, true,
+				(i == selected) ? g_Locale->getText(LOCALE_ONOFF_ON)
+						: g_Locale->getText(LOCALE_ONOFF_OFF),
+				this, EMU_list[i].procname, CRCInput::convertDigitToKey(shortcut++));
+			menu->addItem(EMU_list[i].cmf, (i == selected));
+		}
+
+	menu->addItem(GenericMenuSeparatorLine);
+	menu->addItem(new CMenuForwarder(LOCALE_EXTRAMENU_EMU_RESTART, true, "", this, "reset",
+			CRCInput::RC_red, NEUTRINO_ICON_BUTTON_RED));
+	menu->addItem(new CMenuForwarder(LOCALE_EXTRAMENU_EMU_DISABLE, true, "", this, "disable",
+			CRCInput::RC_blue, NEUTRINO_ICON_BUTTON_BLUE));
+
+	menu->exec(NULL, "");
+        menu->hide();
+        delete menu;
+	saveSettings();
+}
+
+void EMU_Menu::suspend()
+{
+	if (selected && !suspended) {
+		safe_system(EMU_list[selected].stop_command);
+		suspended = true;
+	}
+}
+
+void EMU_Menu::resume()
+{
+	if (selected && suspended) {
+		safe_system(EMU_list[selected].start_command);
+		if (is_scrambled())
+			safe_system("sleep 2; /usr/local/bin/pzapit -rz >/dev/null 2>&1");
+		suspended = false;
+	}
+}
+
+////////////////////////////// EMU Menu ENDE //////////////////////////////////////
+
+#if 0
+////////////////////////////// DISPLAYTIME Menu ANFANG ////////////////////////////////////
+#define DISPLAYTIME_OPTION_COUNT 2
+const CMenuOptionChooser::keyval DISPLAYTIME_OPTIONS[DISPLAYTIME_OPTION_COUNT] =
+{
+	{ 0, LOCALE_EXTRAMENU_DISPLAYTIME_OFF },
+	{ 1, LOCALE_EXTRAMENU_DISPLAYTIME_ON },
+};
+
+DISPLAYTIME_Menu::DISPLAYTIME_Menu()
+{
+	frameBuffer = CFrameBuffer::getInstance();
+	width = 600;
+	hheight = g_Font[SNeutrinoSettings::FONT_TYPE_MENU_TITLE]->getHeight();
+	mheight = g_Font[SNeutrinoSettings::FONT_TYPE_MENU]->getHeight();
+	height = hheight+13*mheight+ 10;
+
+	x=(((g_settings.screen_EndX- g_settings.screen_StartX)-width) / 2) + g_settings.screen_StartX;
+	y=(((g_settings.screen_EndY- g_settings.screen_StartY)-height) / 2) + g_settings.screen_StartY;
+}
+int DISPLAYTIME_Menu::exec(CMenuTarget* parent, const std::string & actionKey)
+{
+	int res = menu_return::RETURN_REPAINT;
+
+	if (parent)
+		parent->hide();
+
+	DISPLAYTIMESettings();
+
+	return res;
+}
+
+void DISPLAYTIME_Menu::hide()
+{
+	frameBuffer->paintBackgroundBoxRel(x,y, width,height);
+}
+
+void DISPLAYTIME_Menu::DISPLAYTIMESettings()
+{
+#define DOTFILE_DISPLAYTIME "/etc/.time"
+	int displaytime = access(DOTFILE_DISPLAYTIME, F_OK) ? 0 : 1;
+	int old_displaytime=displaytime;
+	//MENU AUFBAUEN
+	CMenuWidget* menu = new CMenuWidget(LOCALE_EXTRAMENU_DISPLAYTIME, "settings");
+	menu->addItem(GenericMenuSeparator);
+	menu->addItem(GenericMenuBack);
+	menu->addItem(GenericMenuSeparatorLine);
+	CMenuOptionChooser* oj1 = new CMenuOptionChooser(LOCALE_EXTRAMENU_DISPLAYTIME_SELECT, &displaytime, DISPLAYTIME_OPTIONS, DISPLAYTIME_OPTION_COUNT,true);
+	menu->addItem( oj1 );
+	menu->exec (NULL, "");
+	menu->hide ();
+	delete menu;
+	// UEBERPRUEFEN OB SICH WAS GEAENDERT HAT
+	if (old_displaytime!=displaytime)
+	{
+		if (displaytime==1)
+		{
+			//DisplayTime STARTEN
+			touch("/etc/.time");
+			safe_system("/etc/init.d/DisplayTime.sh >/dev/null 2>&1 &");
+			ShowHintUTF(LOCALE_MESSAGEBOX_INFO, "DISPLAYTIME Activated!", 450, 2); // UTF-8("")
+		} else {
+			//DisplayTime BEENDEN
+			unlink("/etc/.time");
+			safe_system("killall -9 DisplayTime.sh");
+			ShowHintUTF(LOCALE_MESSAGEBOX_INFO, "DISPLAYTIME Deactivated!", 450, 2); // UTF-8("")
+		}
+	}
+}
+////////////////////////////// DisplayTime Menu ENDE //////////////////////////////////////
+#endif
+
+#if 0 /* unused code */
+////////////////////////////// WWWDATE Menu ANFANG ////////////////////////////////////
+#define WWWDATE_OPTION_COUNT 2
+const CMenuOptionChooser::keyval WWWDATE_OPTIONS[WWWDATE_OPTION_COUNT] =
+{
+	{ 0, LOCALE_EXTRAMENU_WWWDATE_OFF },
+	{ 1, LOCALE_EXTRAMENU_WWWDATE_ON },
+};
+
+WWWDATE_Menu::WWWDATE_Menu()
+{
+	frameBuffer = CFrameBuffer::getInstance();
+	width = 600;
+	hheight = g_Font[SNeutrinoSettings::FONT_TYPE_MENU_TITLE]->getHeight();
+	mheight = g_Font[SNeutrinoSettings::FONT_TYPE_MENU]->getHeight();
+	height = hheight+13*mheight+ 10;
+
+	x=(((g_settings.screen_EndX- g_settings.screen_StartX)-width) / 2) + g_settings.screen_StartX;
+	y=(((g_settings.screen_EndY- g_settings.screen_StartY)-height) / 2) + g_settings.screen_StartY;
+}
+int WWWDATE_Menu::exec(CMenuTarget* parent, const std::string & actionKey)
+{
+	int res = menu_return::RETURN_REPAINT;
+
+	if (parent)
+		parent->hide();
+
+	WWWDATESettings();
+
+	return res;
+}
+
+void WWWDATE_Menu::hide()
+{
+	frameBuffer->paintBackgroundBoxRel(x,y, width,height);
+}
+
+void WWWDATE_Menu::WWWDATESettings()
+{
+	int wwwdate=0;
+	int save_value=0;
+	//UEBERPRUEFEN OB WWWDATE SCHON LAEUFT
+	FILE* fd1 = fopen("/etc/.wwwdate", "r");
+	if(fd1)
+	{
+		wwwdate=1;
+		fclose(fd1);
+	}
+	int old_wwwdate=wwwdate;
+	//MENU AUFBAUEN
+	CMenuWidget* menu = new CMenuWidget(LOCALE_EXTRAMENU_WWWDATE, "settings");
+	menu->addItem(GenericMenuSeparator);
+	menu->addItem(GenericMenuBack);
+	menu->addItem(GenericMenuSeparatorLine);
+	CMenuOptionChooser* oj1 = new CMenuOptionChooser(LOCALE_EXTRAMENU_WWWDATE_SELECT, &wwwdate, WWWDATE_OPTIONS, WWWDATE_OPTION_COUNT,true);
+	menu->addItem( oj1 );
+	menu->exec (NULL, "");
+	menu->hide ();
+	delete menu;
+	// UEBERPRUEFEN OB SICH WAS GEAENDERT HAT
+	if (old_wwwdate!=wwwdate)
+	{
+		save_value=1;
+	}
+	// ENDE UEBERPRUEFEN OB SICH WAS GEAENDERT HAT
+
+	// AUSFUEHREN NUR WENN SICH WAS GEAENDERT HAT
+	if (save_value==1)
+	{
+		if (wwwdate==1)
+		{
+			//WWWDATE STARTEN
+			safe_system("touch /etc/.wwwdate");
+			ShowHintUTF(LOCALE_MESSAGEBOX_INFO, "WWWDATE Activated!", 450, 2); // UTF-8("")
+		}
+		if (wwwdate==0)
+		{
+			//WWWDATE BEENDEN
+			safe_system("rm /etc/.wwwdate");
+			ShowHintUTF(LOCALE_MESSAGEBOX_INFO, "WWWDATE Deactivated!", 450, 2); // UTF-8("")
+		}
+	}
+	//ENDE WWWDATE
+}
+////////////////////////////// WWWDATE Menu ENDE //////////////////////////////////////
+#endif
+
+////////////////////////////// SWAP choose Menu ANFANG ////////////////////////////////////
+
+#define SWAP_OPTION_COUNT 3
+const CMenuOptionChooser::keyval SWAP_OPTIONS[SWAP_OPTION_COUNT] =
+{
+#define KEY_SWAP_SWAPRAM 0
+#define KEY_SWAP_SWAPPART 1
+#define KEY_SWAP_SWAPFILE 2
+	{ KEY_SWAP_SWAPRAM, LOCALE_EXTRAMENU_SWAP_SWAPRAM },
+	{ KEY_SWAP_SWAPPART, LOCALE_EXTRAMENU_SWAP_SWAPPART },
+	{ KEY_SWAP_SWAPFILE, LOCALE_EXTRAMENU_SWAP_SWAPFILE }
+};
+
+SWAP_Menu::SWAP_Menu()
+{
+	frameBuffer = CFrameBuffer::getInstance();
+	width = 600;
+	hheight = g_Font[SNeutrinoSettings::FONT_TYPE_MENU_TITLE]->getHeight();
+	mheight = g_Font[SNeutrinoSettings::FONT_TYPE_MENU]->getHeight();
+	height = hheight+13*mheight+ 10;
+
+	x=(((g_settings.screen_EndX- g_settings.screen_StartX)-width) / 2) + g_settings.screen_StartX;
+	y=(((g_settings.screen_EndY- g_settings.screen_StartY)-height) / 2) + g_settings.screen_StartY;
+}
+
+int SWAP_Menu::exec(CMenuTarget* parent, const std::string & actionKey)
+{
+	int res = menu_return::RETURN_REPAINT;
+
+	if (parent)
+		parent->hide();
+
+	SWAP_Menu_Settings();
+
+	return res;
+}
+
+void SWAP_Menu::hide()
+{
+	frameBuffer->paintBackgroundBoxRel(x,y, width,height);
+}
+
+string SWAP_Menu::start_swap(int swaptype) {
+	switch(swaptype) {
+		case KEY_SWAP_SWAPRAM:
+			safe_system("/etc/init.d/Swap.sh >/dev/null 2>&1 &");
+			return "SWAP-RAM activated";
+		case KEY_SWAP_SWAPPART:
+			safe_system("/etc/init.d/Swap.sh >/dev/null 2>&1 &");
+			return "SWAP partition activated";
+		case KEY_SWAP_SWAPFILE:
+			safe_system("/etc/init.d/Swap.sh >/dev/null 2>&1 &");
+			return "SWAP file activated";
+		default:
+			return "Internal error.";
+	}
+}
+
+string SWAP_Menu::stop_swap(int swaptype) {
+	switch(swaptype) {
+		case KEY_SWAP_SWAPRAM:
+			safe_system("swapoff -a");
+			return "SWAPRAM deactivated";
+		case KEY_SWAP_SWAPPART:
+			safe_system("swapoff -a");
+			return "SWAP partition deactivated";
+		case KEY_SWAP_SWAPFILE:
+			safe_system("swapoff /dev/loop0 ; losetup -d /dev/loop0 ; swapoff -a");
+			return "SWAP file deactivated";
+		default:
+			return "Internal error.";
+	}
+}
+
+#define DOTFILE_SWAPON  "/etc/.swapon"
+#define DOTFILE_SWAPRAM "/etc/.swapram"
+#define DOTFILE_SWAPPART "/etc/.swappart"
+#define DOTFILE_SWAPFILE "/etc/.swapfile"
+
+void SWAP_Menu::unlink_dotfile(int swaptype) {
+	switch(swaptype) {
+		case KEY_SWAP_SWAPRAM:
+			unlink(DOTFILE_SWAPRAM);
+			return;
+		case KEY_SWAP_SWAPPART:
+			unlink(DOTFILE_SWAPPART);
+			return;
+		case KEY_SWAP_SWAPFILE:
+			unlink(DOTFILE_SWAPFILE);
+		default:
+			return;
+	}
+}
+
+void SWAP_Menu::touch_dotfile(int swaptype) {
+	switch(swaptype) {
+		case KEY_SWAP_SWAPRAM:
+			touch(DOTFILE_SWAPRAM);
+			return;
+		case KEY_SWAP_SWAPPART:
+			touch(DOTFILE_SWAPPART);
+			return;
+		case KEY_SWAP_SWAPFILE:
+			touch(DOTFILE_SWAPFILE);
+		default:
+			return;
+	}
+}
+
+void SWAP_Menu::SWAP_Menu_Settings()
+{
+	int swap_onoff = access(DOTFILE_SWAPON, F_OK) ? 0 : 1;
+	int swap=0;
+
+	if (!access(DOTFILE_SWAPRAM, F_OK))
+		swap = KEY_SWAP_SWAPRAM;
+	else if (!access(DOTFILE_SWAPPART, F_OK))
+		swap = KEY_SWAP_SWAPPART;
+	else if (!access(DOTFILE_SWAPFILE, F_OK))
+		swap = KEY_SWAP_SWAPFILE;
+
+	int old_swap=swap;
+	int old_swap_onoff=swap_onoff;
+
+	//MENU AUFBAUEN
+	CMenuWidget* menu = new CMenuWidget(LOCALE_EXTRAMENU_SWAP, "settings");
+	menu->addItem(GenericMenuSeparator);
+	menu->addItem(GenericMenuBack);
+	menu->addItem(GenericMenuSeparatorLine);
+	CMenuOptionChooser* oj1 = new CMenuOptionChooser(LOCALE_EXTRAMENU_SWAP_ONOFF, &swap_onoff, ONOFF_OPTIONS, ONOFF_OPTION_COUNT,true);
+	menu->addItem( oj1 );
+	menu->addItem(GenericMenuSeparatorLine);
+	CMenuOptionChooser* oj2 = new CMenuOptionChooser(LOCALE_EXTRAMENU_SWAP_SELECT, &swap, SWAP_OPTIONS, SWAP_OPTION_COUNT,true);
+	menu->addItem( oj2 );
+	menu->exec (NULL, "");
+	menu->hide ();
+	delete menu;
+
+	// UEBERPRUEFEN OB SICH WAS GEAENDERT HAT
+	if ((old_swap != swap) && (swap_onoff == 1)) {
+		if (old_swap_onoff == 0)
+			stop_swap(old_swap);
+		else
+			unlink_dotfile(old_swap);
+		touch_dotfile(swap);
+		touch(DOTFILE_SWAPON);
+		ShowHintUTF(LOCALE_MESSAGEBOX_INFO, start_swap(swap).c_str(), 450, 2); // UTF-8("")
+	} else if ((old_swap!=swap) && (swap_onoff == 0)) {
+		if (old_swap_onoff == 1) {
+			unlink(DOTFILE_SWAPON);
+			ShowHintUTF(LOCALE_MESSAGEBOX_INFO, stop_swap(old_swap).c_str(), 450, 2); // UTF-8("")
+		}
+		unlink_dotfile(old_swap);
+		touch_dotfile(swap);
+	} else if ((old_swap == swap) && (swap_onoff == 1)) {
+		if (old_swap_onoff == 0) {
+			touch_dotfile(swap); // might be the default value
+			touch(DOTFILE_SWAPON);
+			ShowHintUTF(LOCALE_MESSAGEBOX_INFO, start_swap(swap).c_str(), 450, 2); // UTF-8("")
+		}
+	} else if ((old_swap == swap) && (swap_onoff == 0)) {
+		if (old_swap_onoff == 1) {
+			unlink(DOTFILE_SWAPON);
+			ShowHintUTF(LOCALE_MESSAGEBOX_INFO, stop_swap(swap).c_str(), 450, 2); // UTF-8("")
+		}
+	}
+}
+
+////////////////////////////// SWAP Menu ENDE //////////////////////////////////////
+
+////////////////////////////// BOOT Menu ANFANG ////////////////////////////////////
+#define BOOT_OPTION_COUNT 2
+const CMenuOptionChooser::keyval BOOT_OPTIONS[BOOT_OPTION_COUNT] =
+{
+#define BOOT_NEUTRINO 0
+#define BOOT_E2       1
+//#define BOOT_SPARK    2
+#if 0
+	{ BOOT_NEUTRINO, NONEXISTANT_LOCALE, "Neutrino" },
+#else
+	{ BOOT_NEUTRINO, LOCALE_EXTRAMENU_BOOT_UNCHANGED },
+#endif
+	{ BOOT_E2, NONEXISTANT_LOCALE, "E2PLI" }
+//	{ BOOT_SPARK, NONEXISTANT_LOCALE, "Spark" }
+};
+
+BOOT_Menu::BOOT_Menu()
+{
+	frameBuffer = CFrameBuffer::getInstance();
+	width = 500;
+	hheight = g_Font[SNeutrinoSettings::FONT_TYPE_MENU_TITLE]->getHeight();
+	mheight = g_Font[SNeutrinoSettings::FONT_TYPE_MENU]->getHeight();
+	height = hheight+13*mheight+ 10;
+
+	x=(((g_settings.screen_EndX- g_settings.screen_StartX)-width) / 2) + g_settings.screen_StartX;
+	y=(((g_settings.screen_EndY- g_settings.screen_StartY)-height) / 2) + g_settings.screen_StartY;
+}
+
+int BOOT_Menu::exec(CMenuTarget* parent, const std::string & actionKey)
+{
+	int res = menu_return::RETURN_REPAINT;
+/*	if(actionKey == "reboot") {
+                FILE *f = fopen("/tmp/.reboot", "w");
+                fclose(f);
+		CNeutrinoApp::getInstance()->ExitRun(true, 2);
+		// not reached, hopefully...
+                unlink("/tmp/.reboot");
+		return res;
+	}*/
+
+	if (parent)
+		parent->hide();
+
+	BOOTSettings();
+
+	return res;
+}
+
+void BOOT_Menu::hide()
+{
+	frameBuffer->paintBackgroundBoxRel(x,y, width,height);
+}
+
+void BOOT_Menu::BOOTSettings()
+{
+#define DOTFILE_BOOTE2 "/etc/.start_enigma2"
+#define DOTFILE_BOOTNHD2 "/etc/.nhd2"
+/*
+#define DOTFILE_BOOTSPARK "/etc/.start_spark"
+	int boot = BOOT_NEUTRINO;
+	if (!access(DOTFILE_BOOTSPARK, F_OK))
+		boot = BOOT_SPARK;
+	else if (!access(DOTFILE_BOOTE2, F_OK))
+		boot = BOOT_E2;
+	int old_boot = boot;
+*/
+	int boot = BOOT_NEUTRINO;
+	if (!access(DOTFILE_BOOTE2, F_OK))
+		boot = BOOT_E2;
+	int old_boot = boot;
+	CMenuWidget* menu = new CMenuWidget(LOCALE_EXTRAMENU_BOOT_HEAD, "settings", width);
+	menu->addItem(GenericMenuSeparator);
+	menu->addItem(GenericMenuBack);
+	menu->addItem(GenericMenuSeparatorLine);
+	CMenuOptionChooser* oj1 = new CMenuOptionChooser(LOCALE_EXTRAMENU_BOOT_SELECT, &boot, BOOT_OPTIONS, BOOT_OPTION_COUNT,true);
+	menu->addItem( oj1 );
+#if 0
+	menu->addItem(new CMenuForwarder(LOCALE_MAINMENU_REBOOT, true, "", this, "reboot", CRCInput::RC_red, NEUTRINO_ICON_BUTTON_RED));
+	menu->addItem(GenericMenuSeparatorLine);
+#endif
+	menu->exec (NULL, "");
+	menu->hide ();
+	delete menu;
+
+	if ((boot != old_boot)
+         && (ShowLocalizedMessage (LOCALE_EXTRAMENU_BOOT_HEAD, LOCALE_MESSAGEBOX_ACCEPT, CMessageBox::mbrYes, CMessageBox::mbYes | CMessageBox::mbCancel) != CMessageBox::mbrCancel))
+	{
+		CHintBox *b = NULL;
+/*		if(boot == BOOT_SPARK || old_boot == BOOT_SPARK) {
+			b = new CHintBox(LOCALE_EXTRAMENU_BOOT_BOOTARGS_HEAD, g_Locale->getText(LOCALE_EXTRAMENU_BOOT_BOOTARGS_TEXT));
+			b->paint();
+		}
+		if (boot == BOOT_SPARK) {
+			touch(DOTFILE_BOOTSPARK);
+			safe_system("fw_setenv -s /etc/bootargs_orig");
+			ShowHintUTF(LOCALE_MESSAGEBOX_INFO, "Spark activated, please reboot now..!", 450, 2);
+		}
+		if (old_boot == BOOT_SPARK) {
+			unlink(DOTFILE_BOOTSPARK);
+			safe_system("fw_setenv -s /etc/bootargs_evolux");
+		}
+		if(b) {
+			b->hide();
+			delete b;
+		}
+*/
+		if (boot == BOOT_E2 && old_boot == BOOT_NEUTRINO && !access("/usr/local/bin/enigma2", X_OK)) {
+			touch(DOTFILE_BOOTE2);
+			unlink(DOTFILE_BOOTNHD2);
+			ShowHintUTF(LOCALE_MESSAGEBOX_INFO, "E2 activated, please reboot now..!", 450, 2);
+		}
+		else if (boot == BOOT_NEUTRINO && old_boot == BOOT_E2)
+			unlink(DOTFILE_BOOTE2);
+
+	}
+}
+////////////////////////////// BOOT Menu ENDE //////////////////////////////////////
+
+////////////////////////////// FSCK Menu ANFANG ////////////////////////////////////
+#define FSCK_OPTION_COUNT 2
+const CMenuOptionChooser::keyval FSCK_OPTIONS[FSCK_OPTION_COUNT] =
+{
+	{ 0, LOCALE_EXTRAMENU_FSCK_OFF },
+	{ 1, LOCALE_EXTRAMENU_FSCK_ON }
+};
+
+FSCK_Menu::FSCK_Menu()
+{
+	frameBuffer = CFrameBuffer::getInstance();
+	width = 600;
+	hheight = g_Font[SNeutrinoSettings::FONT_TYPE_MENU_TITLE]->getHeight();
+	mheight = g_Font[SNeutrinoSettings::FONT_TYPE_MENU]->getHeight();
+	height = hheight+13*mheight+ 10;
+
+	x=(((g_settings.screen_EndX- g_settings.screen_StartX)-width) / 2) + g_settings.screen_StartX;
+	y=(((g_settings.screen_EndY- g_settings.screen_StartY)-height) / 2) + g_settings.screen_StartY;
+}
+
+int FSCK_Menu::exec(CMenuTarget* parent, const std::string & actionKey)
+{
+	int res = menu_return::RETURN_REPAINT;
+
+	if (parent)
+		parent->hide();
+
+	FSCKSettings();
+
+	return res;
+}
+
+void FSCK_Menu::hide()
+{
+	frameBuffer->paintBackgroundBoxRel(x,y, width,height);
+}
+
+void FSCK_Menu::FSCKSettings()
+{
+#define DOTFILE_FSCK "/etc/.fsck"
+	int fsck = access(DOTFILE_FSCK, F_OK) ? 0 : 1;
+	int old_fsck=fsck;
+	//MENU AUFBAUEN
+	CMenuWidget* menu = new CMenuWidget(LOCALE_EXTRAMENU_FSCK, "settings");
+	menu->addItem(GenericMenuSeparator);
+	menu->addItem(GenericMenuBack);
+	menu->addItem(GenericMenuSeparatorLine);
+	CMenuOptionChooser* oj1 = new CMenuOptionChooser(LOCALE_EXTRAMENU_FSCK_SELECT, &fsck, FSCK_OPTIONS, FSCK_OPTION_COUNT,true);
+	menu->addItem( oj1 );
+	menu->exec (NULL, "");
+	menu->hide ();
+	delete menu;
+	// UEBERPRUEFEN OB SICH WAS GEAENDERT HAT
+	if (old_fsck!=fsck)
+	{
+		if (fsck == 1) {
+			touch(DOTFILE_FSCK);
+			ShowHintUTF(LOCALE_MESSAGEBOX_INFO, "FSCK Activated, please reboot!", 450, 2); // UTF-8("")
+		} else {
+			unlink(DOTFILE_FSCK);
+			ShowHintUTF(LOCALE_MESSAGEBOX_INFO, "FSCK Deactivated!", 450, 2); // UTF-8("")
+		}
+	}
+}
+////////////////////////////// FSCK Menu ENDE //////////////////////////////////////
+
+////////////////////////////// STMFB Menu ANFANG ////////////////////////////////////
+#define STMFB_OPTION_COUNT 2
+const CMenuOptionChooser::keyval STMFB_OPTIONS[STMFB_OPTION_COUNT] =
+{
+	{ 0, LOCALE_EXTRAMENU_STMFB_OFF },
+	{ 1, LOCALE_EXTRAMENU_STMFB_ON }
+};
+
+STMFB_Menu::STMFB_Menu()
+{
+	frameBuffer = CFrameBuffer::getInstance();
+	width = 600;
+	hheight = g_Font[SNeutrinoSettings::FONT_TYPE_MENU_TITLE]->getHeight();
+	mheight = g_Font[SNeutrinoSettings::FONT_TYPE_MENU]->getHeight();
+	height = hheight+13*mheight+ 10;
+
+	x=(((g_settings.screen_EndX- g_settings.screen_StartX)-width) / 2) + g_settings.screen_StartX;
+	y=(((g_settings.screen_EndY- g_settings.screen_StartY)-height) / 2) + g_settings.screen_StartY;
+}
+int STMFB_Menu::exec(CMenuTarget* parent, const std::string & actionKey)
+{
+	int res = menu_return::RETURN_REPAINT;
+
+	if (parent)
+		parent->hide();
+
+	STMFBSettings();
+
+	return res;
+}
+
+void STMFB_Menu::hide()
+{
+	frameBuffer->paintBackgroundBoxRel(x,y, width,height);
+}
+
+void STMFB_Menu::STMFBSettings()
+{
+#define DOTFILE_STMFB "/etc/.15m"
+	int stmfb = access(DOTFILE_STMFB, F_OK) ? 0 : 1;
+	int old_stmfb=stmfb;
+	//MENU AUFBAUEN
+	CMenuWidget* menu = new CMenuWidget(LOCALE_EXTRAMENU_STMFB, "settings");
+	menu->addItem(GenericMenuSeparator);
+	menu->addItem(GenericMenuBack);
+	menu->addItem(GenericMenuSeparatorLine);
+	CMenuOptionChooser* oj1 = new CMenuOptionChooser(LOCALE_EXTRAMENU_STMFB_SELECT, &stmfb, STMFB_OPTIONS, STMFB_OPTION_COUNT,true);
+	menu->addItem( oj1 );
+	menu->exec (NULL, "");
+	menu->hide ();
+	delete menu;
+	// UEBERPRUEFEN OB SICH WAS GEAENDERT HAT
+	if (old_stmfb!=stmfb)
+	{
+		if (stmfb==1)
+		{
+			//STMFB STARTEN
+			touch(DOTFILE_STMFB);
+			ShowHintUTF(LOCALE_MESSAGEBOX_INFO, "STMFB 15m Activated, please reboot!", 450, 2); // UTF-8("")
+		} else {
+			//STMFB BEENDEN
+			unlink(DOTFILE_STMFB);
+			ShowHintUTF(LOCALE_MESSAGEBOX_INFO, "STMFB 15m Deactivated!", 450, 2); // UTF-8("")
+		}
+	}
+}
+////////////////////////////// STMFB Menu ENDE //////////////////////////////////////
+
+////////////////////////////// FRITZCALL Menu ANFANG ////////////////////////////////////
+#define FRITZCALL_OPTION_COUNT 2
+const CMenuOptionChooser::keyval FRITZCALL_OPTIONS[FRITZCALL_OPTION_COUNT] =
+{
+	{ 0, LOCALE_EXTRAMENU_FRITZCALL_OFF },
+	{ 1, LOCALE_EXTRAMENU_FRITZCALL_ON }
+};
+
+FRITZCALL_Menu::FRITZCALL_Menu()
+{
+	frameBuffer = CFrameBuffer::getInstance();
+	width = 600;
+	hheight = g_Font[SNeutrinoSettings::FONT_TYPE_MENU_TITLE]->getHeight();
+	mheight = g_Font[SNeutrinoSettings::FONT_TYPE_MENU]->getHeight();
+	height = hheight+13*mheight+ 10;
+
+	x=(((g_settings.screen_EndX- g_settings.screen_StartX)-width) / 2) + g_settings.screen_StartX;
+	y=(((g_settings.screen_EndY- g_settings.screen_StartY)-height) / 2) + g_settings.screen_StartY;
+}
+
+int FRITZCALL_Menu::exec(CMenuTarget* parent, const std::string & actionKey)
+{
+	int res = menu_return::RETURN_REPAINT;
+
+	if (parent)
+		parent->hide();
+
+	FRITZCALLSettings();
+
+	return res;
+}
+
+void FRITZCALL_Menu::hide()
+{
+	frameBuffer->paintBackgroundBoxRel(x,y, width,height);
+}
+
+#define DOTFILE_FRITZCALL "/etc/.fritzcall"
+void FRITZCALL_Menu::FRITZCALLSettings()
+{
+	int fritzcall = access(DOTFILE_FRITZCALL, F_OK) ? 0 : 1;
+	int old_fritzcall=fritzcall;
+
+	//MENU AUFBAUEN
+	CMenuWidget* menu = new CMenuWidget(LOCALE_EXTRAMENU_FRITZCALL, "settings");
+	menu->addItem(GenericMenuSeparator);
+	menu->addItem(GenericMenuBack);
+	menu->addItem(GenericMenuSeparatorLine);
+	CMenuOptionChooser* oj1 = new CMenuOptionChooser(LOCALE_EXTRAMENU_FRITZCALL_SELECT, &fritzcall, FRITZCALL_OPTIONS, FRITZCALL_OPTION_COUNT,true);
+	menu->addItem( oj1 );
+	menu->exec (NULL, "");
+	menu->hide ();
+	delete menu;
+	// UEBERPRUEFEN OB SICH WAS GEAENDERT HAT
+	if (old_fritzcall!=fritzcall)
+	{
+		if (fritzcall == 1)
+		{
+			//FRITZCALL STARTEN
+			touch(DOTFILE_FRITZCALL);
+			safe_system("/var/plugins/fritzcall/fb.sh start >/dev/null 2>&1 &");
+			ShowHintUTF(LOCALE_MESSAGEBOX_INFO, "FRITZCALLMONITOR activated!", 450, 2); // UTF-8("")
+		} else {
+			//FRITZCALL BEENDEN
+			unlink(DOTFILE_FRITZCALL);
+			safe_system("/var/plugins/fritzcall/fb.sh stop >/dev/null 2>&1 &");
+			ShowHintUTF(LOCALE_MESSAGEBOX_INFO, "FRITZCALLMONITOR deactivated!", 450, 2); // UTF-8("")
+		}
+	}
+	//ENDE FRITZCALL
+}
+////////////////////////////// FRITZCALL Menu ENDE //////////////////////////////////////
+
+KernelOptions_Menu::KernelOptions_Menu()
+{
+	frameBuffer = CFrameBuffer::getInstance();
+	width = 600;
+	hheight = g_Font[SNeutrinoSettings::FONT_TYPE_MENU_TITLE]->getHeight();
+	mheight = g_Font[SNeutrinoSettings::FONT_TYPE_MENU]->getHeight();
+	height = hheight+13*mheight+ 10;
+
+	x=(((g_settings.screen_EndX- g_settings.screen_StartX)-width) / 2) + g_settings.screen_StartX;
+	y=(((g_settings.screen_EndY- g_settings.screen_StartY)-height) / 2) + g_settings.screen_StartY;
+}
+
+int KernelOptions_Menu::exec(CMenuTarget* parent, const std::string & actionKey)
+{
+	int res = menu_return::RETURN_REPAINT;
+
+	if (actionKey == "reset") {
+		for (int i = 0; i < modules.size(); i++)
+			modules[i].active = modules[i].active_orig;
+		return res;
+	}
+
+	if (actionKey == "apply") {
+		for (int i = 0; i < modules.size(); i++)
+			if (modules[i].active != modules[i].active_orig) {
+				FILE *f = fopen("/etc/modules.extra", "w");
+					if (f) {
+						chmod("/etc/modules.extra", 0644);
+						for (int i = 0; i < modules.size(); i++) {
+							if (modules[i].active) {
+								for (int j = 0; j < modules[i].moduleList.size(); j++)
+									fprintf(f, "%s\n", modules[i].moduleList[j].c_str());
+							}
+						}
+					fclose(f);
+				}
+				for (int i = 0; i < modules.size(); i++) {
+					char buf[80];
+					if (modules[i].active)
+						for (int j = 0; j < modules[i].moduleList.size(); j++) {
+							snprintf(buf, sizeof(buf), "insmod /lib/modules/%s.ko", modules[i].moduleList[j].c_str());
+							safe_system(buf);
+						}
+					else
+						for (int j = 0; j < modules[i].moduleList.size(); j++) {
+							snprintf(buf, sizeof(buf), "rmmod %s", modules[i].moduleList[j].c_str());
+							safe_system(buf);
+						}
+					modules[i].active_orig = modules[i].active;
+				}
+				break;
+			}
+	}
+
+	if (actionKey == "apply" || actionKey == "lsmod") {
+		for (int i = 0; i < modules.size(); i++)
+			modules[i].installed = false;
+		FILE *f = fopen("/proc/modules", "r");
+		if (f) {
+			char buf[200];
+			while (fgets(buf, sizeof(buf), f)) {
+				char name[200];
+				if (1 == sscanf(buf, "%s", name))
+					for (int i = 0; i < modules.size(); i++) {
+						if (name == modules[i].moduleList.back()) {
+							modules[i].installed = true;
+							break;
+						}
+				}
+			}
+			fclose(f);
+		}
+
+		string text = "";
+		for (int i = 0; i < modules.size(); i++) {
+			text += modules[i].comment + " (" + modules[i].moduleList.back() + ") ";
+			// FIXME, localizations are missing (but rather not worth adding)
+			if (modules[i].active) {
+				if (modules[i].installed)
+					text += " is enabled and loaded\n";
+				else
+					text += " is enabled but not loaded\n";
+			} else {
+				if (modules[i].installed)
+					text += " is disabled but loaded\n";
+				else
+					text += " is disabled and not loaded\n";
+			}
+		}
+
+		ShowHintUTF(LOCALE_EXTRAMENU_KERNELOPTIONS_LSMOD, text.c_str());
+
+		return res;
+	}
+
+	if (parent)
+		parent->hide();
+
+	Settings();
+
+	return res;
+}
+
+void KernelOptions_Menu::hide()
+{
+	frameBuffer->paintBackgroundBoxRel(x,y, width,height);
+}
+
+void KernelOptions_Menu::Settings()
+{
+	CMenuWidget* menu = new CMenuWidget(LOCALE_EXTRAMENU_KERNELOPTIONS, "settings");
+	menu->addItem(GenericMenuSeparator);
+	menu->addItem(GenericMenuBack);
+	menu->addItem(new CMenuSeparator(CMenuSeparator::LINE | CMenuSeparator::STRING, LOCALE_EXTRAMENU_KERNELOPTIONS_MODULES));
+
+	modules.clear();
+
+	FILE *f = fopen("/etc/modules.available", "r");
+	if (f) {
+		char buf[200];
+		while (fgets(buf, sizeof(buf), f)) {
+			if (buf[0] == '#')
+				continue;
+			char *comment = strchr(buf, '#');
+			if (!comment)
+				continue;
+			*comment++ = 0;
+			while (*comment == ' ' || *comment == '\t')
+				comment++;
+			if (strlen(comment) < 1)
+				continue;
+			module m;
+			m.active = m.active_orig = 0;
+			m.installed = false;
+			m.comment = string(comment);
+			std::istringstream in(buf);
+			std::string s;
+			while (in >> s)
+				m.moduleList.push_back(s);
+			if (m.moduleList.size() > 0)
+				modules.push_back(m);
+		}
+		fclose(f);
+	}
+
+	f = fopen("/etc/modules.extra", "r");
+	if (f) {
+		char buf[200];
+		while (fgets(buf, sizeof(buf), f)) {
+			char *t = strchr(buf, '#');
+			if (t)
+				*t = 0;
+			char name[200];
+			if (1 == sscanf(buf, "%s", name)) {
+				int i;
+				for (i = 0; i < modules.size(); i++)
+					if (modules[i].moduleList.back() == name) {
+						modules[i].active = modules[i].active_orig = 1;
+						break;
+					}
+			}
+		}
+		fclose(f);
+	}
+
+	int shortcut = 0;
+
+	for (int i = 0; i < modules.size(); i++) {
+		menu->addItem(new CMenuOptionChooser(modules[i].comment.c_str(), &modules[i].active,
+				ONOFF_OPTIONS, ONOFF_OPTION_COUNT, true));
+	}
+
+	menu->addItem(GenericMenuSeparatorLine);
+
+	menu->addItem(new CMenuForwarder(LOCALE_EXTRAMENU_KERNELOPTIONS_RESET, true, "", this,
+		"reset", CRCInput::RC_red, NEUTRINO_ICON_BUTTON_RED));
+	menu->addItem(new CMenuForwarder(LOCALE_EXTRAMENU_KERNELOPTIONS_APPLY, true, "", this,
+		"apply", CRCInput::RC_green, NEUTRINO_ICON_BUTTON_GREEN));
+	menu->addItem(new CMenuForwarder(LOCALE_EXTRAMENU_KERNELOPTIONS_LSMOD, true, "", this,
+		"lsmod", CRCInput::RC_yellow, NEUTRINO_ICON_BUTTON_YELLOW));
+	menu->exec (NULL, "");
+	menu->hide ();
+	delete menu;
+}
+
+////////////////////////////// EVOLUXUPDATE Menu ANFANG ////////////////////////////////////
+#define EVOLUXUPDATE_OPTION_COUNT 2
+const CMenuOptionChooser::keyval EVOLUXUPDATE_OPTIONS[EVOLUXUPDATE_OPTION_COUNT] =
+{
+	{ 0, LOCALE_EXTRAMENU_EVOLUXUPDATE_OFF },
+	{ 1, LOCALE_EXTRAMENU_EVOLUXUPDATE_ON },
+};
+
+EVOLUXUPDATE_Menu::EVOLUXUPDATE_Menu()
+{
+	frameBuffer = CFrameBuffer::getInstance();
+	width = 600;
+	hheight = g_Font[SNeutrinoSettings::FONT_TYPE_MENU_TITLE]->getHeight();
+	mheight = g_Font[SNeutrinoSettings::FONT_TYPE_MENU]->getHeight();
+	height = hheight+13*mheight+ 10;
+
+	x=(((g_settings.screen_EndX- g_settings.screen_StartX)-width) / 2) + g_settings.screen_StartX;
+	y=(((g_settings.screen_EndY- g_settings.screen_StartY)-height) / 2) + g_settings.screen_StartY;
+}
+
+int EVOLUXUPDATE_Menu::exec(CMenuTarget* parent, const std::string & actionKey)
+{
+	int res = menu_return::RETURN_REPAINT;
+	if(actionKey == "checkupdate") 
+	{
+		this->CheckUpdate();
+		return res;
+	}
+
+	if (parent)
+		parent->hide();
+
+	EVOLUXUPDATESettings();
+
+	return res;
+}
+
+void EVOLUXUPDATE_Menu::hide()
+{
+	frameBuffer->paintBackgroundBoxRel(x,y, width,height);
+}
+
+void EVOLUXUPDATE_Menu::EVOLUXUPDATESettings()
+{
+	//MENU AUFBAUEN
+	CMenuWidget* menu = new CMenuWidget(LOCALE_EXTRAMENU_EVOLUXUPDATE, "settings");
+	menu->addItem(GenericMenuSeparator);
+	menu->addItem(GenericMenuBack);
+	menu->addItem(GenericMenuSeparatorLine);
+	menu->addItem(new CMenuForwarder(LOCALE_EXTRAMENU_EVOLUXUPDATE_UPDATE, true, "", this, "checkupdate", CRCInput::RC_red, NEUTRINO_ICON_BUTTON_RED));
+	menu->exec (NULL, "");
+	menu->hide ();
+	delete menu;
+}
+
+bool EVOLUXUPDATE_Menu::CheckUpdate()
+{
+	//EVOLUXUPDATE STARTEN
+	unlink("/tmp/EvoluxUpdatevailable");
+#if defined (PLATFORM_SPARK)
+	safe_system("oVersion=`wget -q -O - http://tinyurl.com/7gz7jpo | grep version | cut -d = -f2`;"
+		   "lVersion=`grep version /etc/.version | cut -d = -f2`;"
+		   "[ \"$lVersion\" != \"$oVersion\" ] && touch /tmp/EvoluxUpdatevailable");
+#else
+	safe_system("oVersion=`wget -q -O - http://is.gd/reTrI0 | grep version | cut -d = -f2`;"
+		   "lVersion=`grep version /etc/.version | cut -d = -f2`;"
+		   "[ \"$lVersion\" != \"$oVersion\" ] && touch /tmp/EvoluxUpdatevailable;"
+		   "myfree=`df | grep -m1 root | cut -b45-51`; if [ \"$myfree\" -gt 8000 ]; then touch /tmp/freeok;fi");
+#endif
+	if(!access("/tmp/EvoluxUpdatevailable", F_OK)) {
+		if(!access("/tmp/freeok", F_OK)) {
+			CHintBox * CheckUpdateBox = new CHintBox(LOCALE_EXTRAMENU_EVOLUXUPDATE_UPDATE, "update found, performing update now...");
+			CheckUpdateBox->paint();
+#if defined (PLATFORM_SPARK)
+			safe_system("wget -O - -q http://tinyurl.com/7fjrnm3 | tee /tmp/update.tar.gz | tar -tzf - && tar -xpzf /tmp/update.tar.gz -C /");
+#else
+			safe_system("wget -O - -q http://is.gd/DL3IrU | tee /tmp/update.tar.gz | tar -tzf - && tar -xpzf /tmp/update.tar.gz -C /");
+#endif
+			unlink("/tmp/EvoluxUpdatevailable");
+			unlink("/tmp/update.tar.gz");
+			CheckUpdateBox->hide();
+			delete CheckUpdateBox;
+			CheckUpdateBox = new CHintBox(LOCALE_EXTRAMENU_EVOLUXUPDATE_UPDATE, "update done, please reboot now...");
+			CheckUpdateBox->paint();
+			sleep(3);
+			CheckUpdateBox->hide();
+			delete CheckUpdateBox;
+		}
+		else {
+			CHintBox * CheckUpdateBox = new CHintBox(LOCALE_EXTRAMENU_EVOLUXUPDATE_UPDATE, "not enough free mem! less than 8mb)!");
+			CheckUpdateBox->paint();
+			sleep(3);
+			CheckUpdateBox->hide();
+			delete CheckUpdateBox;
+		}
+	}
+	else {
+		CHintBox * CheckUpdateBox = new CHintBox(LOCALE_EXTRAMENU_EVOLUXUPDATE_UPDATE, "no update available!");
+		CheckUpdateBox->paint();
+		sleep(3);
+		CheckUpdateBox->hide();
+		delete CheckUpdateBox;
+	}
+}
+//ENDE EVOLUXUPDATE
+
+////////////////////////////// NFSSERVER Menu ANFANG ////////////////////////////////////
+#define NFSSERVER_OPTION_COUNT 2
+const CMenuOptionChooser::keyval NFSSERVER_OPTIONS[NFSSERVER_OPTION_COUNT] =
+{
+	{ 0, LOCALE_EXTRAMENU_NFSSERVER_OFF },
+	{ 1, LOCALE_EXTRAMENU_NFSSERVER_ON }
+};
+
+NFSSERVER_Menu::NFSSERVER_Menu()
+{
+	frameBuffer = CFrameBuffer::getInstance();
+	width = 600;
+	hheight = g_Font[SNeutrinoSettings::FONT_TYPE_MENU_TITLE]->getHeight();
+	mheight = g_Font[SNeutrinoSettings::FONT_TYPE_MENU]->getHeight();
+	height = hheight+13*mheight+ 10;
+
+	x=(((g_settings.screen_EndX- g_settings.screen_StartX)-width) / 2) + g_settings.screen_StartX;
+	y=(((g_settings.screen_EndY- g_settings.screen_StartY)-height) / 2) + g_settings.screen_StartY;
+}
+
+int NFSSERVER_Menu::exec(CMenuTarget* parent, const std::string & actionKey)
+{
+	int res = menu_return::RETURN_REPAINT;
+
+	if (parent)
+		parent->hide();
+
+	NFSSERVERSettings();
+
+	return res;
+}
+
+void NFSSERVER_Menu::hide()
+{
+	frameBuffer->paintBackgroundBoxRel(x,y, width,height);
+}
+
+void NFSSERVER_Menu::NFSSERVERSettings()
+{
+#define DOTFILE_NFSSERVER "/etc/.nfsserver"
+	int nfsserver = access(DOTFILE_NFSSERVER, F_OK) ? 0 : 1;
+	int old_nfsserver=nfsserver;
+	//MENU AUFBAUEN
+	CMenuWidget* menu = new CMenuWidget(LOCALE_EXTRAMENU_NFSSERVER, "settings");
+	menu->addItem(GenericMenuSeparator);
+	menu->addItem(GenericMenuBack);
+	menu->addItem(GenericMenuSeparatorLine);
+	CMenuOptionChooser* oj1 = new CMenuOptionChooser(LOCALE_EXTRAMENU_NFSSERVER_SELECT, &nfsserver, NFSSERVER_OPTIONS, NFSSERVER_OPTION_COUNT,true);
+	menu->addItem( oj1 );
+	menu->exec (NULL, "");
+	menu->hide ();
+	delete menu;
+	// UEBERPRUEFEN OB SICH WAS GEAENDERT HAT
+	if (old_nfsserver!=nfsserver)
+	{
+		if (nfsserver == 1) {
+			touch(DOTFILE_NFSSERVER);
+			safe_system("myRange=`ifconfig | grep -m1 'Bcast' | cut -d : -f3 | cut -d ' ' -f1 | cut -b1-11`;sed 's@/media/hdd.*@/media/hdd '$myRange'.0/255.255.255.0(rw,async,no_root_squash)@g' -i /etc/exports;/etc/init.d/nfs-common start;/etc/init.d/nfs-kernel-server start");
+			ShowHintUTF(LOCALE_MESSAGEBOX_INFO, "NFSSERVER Activated!", 450, 2); // UTF-8("")
+		} else {
+			unlink(DOTFILE_NFSSERVER);
+			system("/etc/init.d/nfs-kernel-server stop;/etc/init.d/nfs-common stop");
+			ShowHintUTF(LOCALE_MESSAGEBOX_INFO, "NFSSERVER Deactivated!", 450, 2); // UTF-8("")
+		}
+	}
+}
+////////////////////////////// NFSSERVER Menu ENDE //////////////////////////////////////
+
+////////////////////////////// EVOLUXUPDATE Menu ENDE //////////////////////////////////////
+// vim:ts=4--- neutrino-hd2-exp/src/gui/extra_menu.h	1970-01-01 01:00:00.000000000 +0100


+++ neutrino-hd2-exp/src/gui/extra_menu.h	2012-10-06 17:54:32.000000000 +0200
@@ -0,0 +1,387 @@
+/*
+Neutrino-GUI - DBoxII-Project
+
+Copyright (C) 2001 Steffen Hehn 'McClean'
+Homepage: http://dbox.cyberphoria.org/
+
+Kommentar:
+
+Diese GUI wurde von Grund auf neu programmiert und sollte nun vom
+Aufbau und auch den Ausbaumoeglichkeiten gut aussehen. Neutrino basiert
+auf der Client-Server Idee, diese GUI ist also von der direkten DBox-
+Steuerung getrennt. Diese wird dann von Daemons uebernommen.
+
+
+License: GPL
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#ifndef __extramenu__
+#define __extramenu__
+
+#include <string>
+#include <vector>
+
+#include <driver/framebuffer.h>
+#include <system/lastchannel.h>
+#include <system/setting_helpers.h>
+#include <configfile.h>
+
+#define EXTRA_SETTINGS_FILE CONFIGDIR "/extra.conf"
+
+using namespace std;
+
+class CORRECTVOLUME_Menu : public CMenuTarget
+{
+	private:
+
+	CFrameBuffer *frameBuffer;
+	int x;
+	int y;
+	int width;
+	int height;
+	int hheight,mheight; // head/menu font height
+
+	public:
+
+	CORRECTVOLUME_Menu();
+
+	void hide();
+	int exec(CMenuTarget* parent, const std::string & actionKey);
+	void CORRECTVOLUMESettings();
+
+};
+
+class TUNERRESET_Menu : public CMenuTarget
+{
+	private:
+
+	CFrameBuffer *frameBuffer;
+	int x;
+	int y;
+	int width;
+	int height;
+	int hheight,mheight; // head/menu font height
+
+	public:
+
+	TUNERRESET_Menu();
+	bool TunerReset();
+	void hide();
+	int exec(CMenuTarget* parent, const std::string & actionKey);
+	void TUNERRESETSettings();
+
+};
+
+class EMU_Menu : public CMenuTarget
+{
+	private:
+
+	CFrameBuffer *frameBuffer;
+	int x;
+	int y;
+	int width;
+	int height;
+	int hheight,mheight; // head/menu font height
+
+	int installed_count;
+	int update_installed();
+	int update_selected();
+	int suspended;
+	int selected;
+
+	public:
+
+	struct emu_list
+	{
+		const char *procname;
+		const char *start_command;
+		const char *stop_command;
+		bool installed;
+		CMenuForwarderNonLocalized *cmf;
+	};
+
+	int get_installed_count();
+
+	EMU_Menu();
+	void hide();
+	int exec(CMenuTarget* parent, const std::string & actionKey);
+	void EMU_Menu_Settings();
+	void suspend();
+	void resume();
+
+};
+
+class AMOUNT_Menu : public CMenuTarget
+{
+	private:
+
+	CFrameBuffer *frameBuffer;
+	int x;
+	int y;
+	int width;
+	int height;
+	int hheight,mheight; // head/menu font height
+
+	public:
+
+	AMOUNT_Menu();
+
+	void hide();
+	int exec(CMenuTarget* parent, const std::string & actionKey);
+	void AMOUNTSettings();
+
+};
+
+class CHECKFS_Menu : public CMenuTarget
+{
+	private:
+
+	CFrameBuffer *frameBuffer;
+	int x;
+	int y;
+	int width;
+	int height;
+	int hheight,mheight; // head/menu font height
+
+	public:
+
+	CHECKFS_Menu();
+
+	void hide();
+	int exec(CMenuTarget* parent, const std::string & actionKey);
+	void CHECKFSSettings();
+
+};
+
+class DISPLAYTIME_Menu : public CMenuTarget
+{
+	private:
+
+	CFrameBuffer *frameBuffer;
+	int x;
+	int y;
+	int width;
+	int height;
+	int hheight,mheight; // head/menu font height
+
+	public:
+
+	DISPLAYTIME_Menu();
+
+	void hide();
+	int exec(CMenuTarget* parent, const std::string & actionKey);
+	void DISPLAYTIMESettings();
+
+};
+
+class WWWDATE_Menu : public CMenuTarget
+{
+	private:
+
+	CFrameBuffer *frameBuffer;
+	int x;
+	int y;
+	int width;
+	int height;
+	int hheight,mheight; // head/menu font height
+
+	public:
+
+	WWWDATE_Menu();
+
+	void hide();
+	int exec(CMenuTarget* parent, const std::string & actionKey);
+	void WWWDATESettings();
+
+};
+
+class SWAP_Menu : public CMenuTarget
+{
+	private:
+
+	CFrameBuffer *frameBuffer;
+	int x;
+	int y;
+	int width;
+	int height;
+	int hheight,mheight; // head/menu font height
+
+	string start_swap(int);
+	string stop_swap(int);
+	void touch_dotfile(int);
+	void unlink_dotfile(int);
+
+	public:
+
+	SWAP_Menu();
+	void hide();
+	int exec(CMenuTarget* parent, const std::string & actionKey);
+	void SWAP_Menu_Settings();
+
+};
+
+class BOOT_Menu : public CMenuTarget
+{
+	private:
+
+	CFrameBuffer *frameBuffer;
+	int x;
+	int y;
+	int width;
+	int height;
+	int hheight,mheight; // head/menu font height
+
+	public:
+
+	BOOT_Menu();
+
+	void hide();
+	int exec(CMenuTarget* parent, const std::string & actionKey);
+	void BOOTSettings();
+};
+
+class FSCK_Menu : public CMenuTarget
+{
+	private:
+
+	CFrameBuffer *frameBuffer;
+	int x;
+	int y;
+	int width;
+	int height;
+	int hheight,mheight; // head/menu font height
+
+	public:
+
+	FSCK_Menu();
+
+	void hide();
+	int exec(CMenuTarget* parent, const std::string & actionKey);
+	void FSCKSettings();
+
+};
+
+class NFSSERVER_Menu : public CMenuTarget
+{
+	private:
+
+	CFrameBuffer *frameBuffer;
+	int x;
+	int y;
+	int width;
+	int height;
+	int hheight,mheight; // head/menu font height
+
+	public:
+
+	NFSSERVER_Menu();
+
+	void hide();
+	int exec(CMenuTarget* parent, const std::string & actionKey);
+	void NFSSERVERSettings();
+
+};
+
+class STMFB_Menu : public CMenuTarget
+{
+	private:
+
+	CFrameBuffer *frameBuffer;
+	int x;
+	int y;
+	int width;
+	int height;
+	int hheight,mheight; // head/menu font height
+
+	public:
+
+	STMFB_Menu();
+
+	void hide();
+	int exec(CMenuTarget* parent, const std::string & actionKey);
+	void STMFBSettings();
+
+};
+
+class FRITZCALL_Menu : public CMenuTarget
+{
+	private:
+
+	CFrameBuffer *frameBuffer;
+	int x;
+	int y;
+	int width;
+	int height;
+	int hheight,mheight; // head/menu font height
+
+	public:
+
+	FRITZCALL_Menu();
+
+	void hide();
+	int exec(CMenuTarget* parent, const std::string & actionKey);
+	void FRITZCALLSettings();
+
+};
+
+
+class KernelOptions_Menu : public CMenuTarget
+{
+    private:
+	CFrameBuffer *frameBuffer;
+	int x;
+	int y;
+	int width;
+	int height;
+	int hheight,mheight; // head/menu font height
+	struct module {
+		string comment;
+		std::vector<string> moduleList;
+		int active_orig;
+		int active;
+		bool installed;
+	};
+	std::vector<module> modules;
+    public:
+	KernelOptions_Menu();
+	void hide();
+	int exec(CMenuTarget* parent, const std::string & actionKey);
+	void Settings();
+};
+
+class EVOLUXUPDATE_Menu : public CMenuTarget
+{
+	private:
+
+	CFrameBuffer *frameBuffer;
+	int x;
+	int y;
+	int width;
+	int height;
+	int hheight,mheight; // head/menu font height
+
+	public:
+
+	EVOLUXUPDATE_Menu();
+	bool CheckUpdate();
+	void hide();
+	int exec(CMenuTarget* parent, const std::string & actionKey);
+	void EVOLUXUPDATESettings();
+
+};
+
+#endif //__extramenu__


--- neutrino-hd2-exp/src/neutrino_menue.cpp	2012-10-21 16:29:13.569345942 +0200
+++ neutrino-hd2-exp/src/neutrino_menue.cpp	2012-10-21 15:13:49.234910982 +0200
@@ -195,7 +195,7 @@
 };
 
 // Init Main Menu
-void CNeutrinoApp::InitMainMenu(CMenuWidget &mainMenu, CMenuWidget &mainSettings, CMenuWidget &videoSettings, CMenuWidget &audioSettings, CMenuWidget &parentallockSettings, CMenuWidget &networkSettings, CMenuWidget &recordingSettings, CMenuWidget &colorSettings, CMenuWidget &lcdSettings, CMenuWidget &keySettings, CMenuWidget &languageSettings, CMenuWidget &miscSettings, CMenuWidget &service, CMenuWidget &audioplayerSettings, CMenuWidget &PicViewerSettings, CMenuWidget &streamingSettings, CMenuWidget &MediaPlayer)
+void CNeutrinoApp::InitMainMenu(CMenuWidget &mainMenu, CMenuWidget &mainSettings, CMenuWidget &videoSettings, CMenuWidget &audioSettings, CMenuWidget &parentallockSettings, CMenuWidget &networkSettings, CMenuWidget &recordingSettings, CMenuWidget &colorSettings, CMenuWidget &lcdSettings, CMenuWidget &keySettings, CMenuWidget &languageSettings, CMenuWidget &miscSettings, CMenuWidget &service, CMenuWidget &audioplayerSettings, CMenuWidget &PicViewerSettings, CMenuWidget &streamingSettings, CMenuWidget &MediaPlayer, CMenuWidget &ExtraMenu)
 {
 	int shortcut = 1;
 
@@ -262,6 +262,42 @@
 	//Service
 	mainMenu.addItem(new CMenuForwarderItemMenuIcon(LOCALE_MAINMENU_SERVICE, true, "", &service, NULL,CRCInput::convertDigitToKey(shortcut++), NULL, "service", LOCALE_HELPTEXT_SERVICE ));
 
+//***************************************** Extra Menue 
+	mainMenu.addItem(new CMenuForwarderItemMenuIcon(LOCALE_MAINMENU_EXTRAMENU, true, "", &ExtraMenu, NULL, CRCInput::convertDigitToKey(shortcut++), NULL, "mainsettings", LOCALE_HELPTEXT_SERVICE));
+	ExtraMenu.addItem(GenericMenuSeparator);
+	ExtraMenu.addItem(GenericMenuBack);
+	ExtraMenu.addItem(GenericMenuSeparatorLine);
+
+	EmuMenu = new EMU_Menu();
+	ExtraMenu.addItem(new CMenuForwarder(LOCALE_EXTRAMENU_EMU, true, "", EmuMenu, NULL, CRCInput::RC_red, NEUTRINO_ICON_BUTTON_RED)); // Emu Menu
+
+	TunerMenu = new TUNERRESET_Menu();
+	ExtraMenu.addItem(new CMenuForwarder(LOCALE_EXTRAMENU_TUNERRESET, true, "", TunerMenu, NULL, CRCInput::RC_green, NEUTRINO_ICON_BUTTON_GREEN)); // Tuner Menu
+	//ExtraMenu.addItem(new CMenuForwarder(LOCALE_EXTRAMENU_CORRECTVOLUME, true, NULL, new CORRECTVOLUME_Menu(), NULL, CRCInput::RC_blue, NEUTRINO_ICON_BUTTON_BLUE)); // CorrectVolume Menu
+	//ExtraMenu.addItem(new CMenuForwarder(LOCALE_EXTRAMENU_AMOUNT, true, NULL, new AMOUNT_Menu(), NULL, CRCInput::RC_yellow, NEUTRINO_ICON_BUTTON_YELLOW)); // Amount Menu
+	//ExtraMenu.addItem(new CMenuForwarder(LOCALE_EXTRAMENU_CHECKFS, true, NULL, new CHECKFS_Menu(), NULL, CRCInput::RC_blue, NEUTRINO_ICON_BUTTON_BLUE)); // CheckFS Menu
+	//ExtraMenu.addItem(new CMenuForwarder(LOCALE_EXTRAMENU_WWWDATE, true, NULL, new WWWDATE_Menu(), NULL, CRCInput::RC_2)); // wwwDate Menu
+	ExtraMenu.addItem(new CMenuForwarder(LOCALE_EXTRAMENU_SWAP, true, "", new SWAP_Menu(), NULL, CRCInput::RC_yellow, NEUTRINO_ICON_BUTTON_YELLOW)); // SWAP Menu
+	ExtraMenu.addItem(new CMenuForwarder(LOCALE_EXTRAMENU_FSCK, true, "", new FSCK_Menu(), NULL, CRCInput::RC_blue, NEUTRINO_ICON_BUTTON_BLUE)); // FSCK Menu
+	int extrashortcut = 1;
+	//ExtraMenu.addItem(new CMenuForwarder(LOCALE_EXTRAMENU_DISPLAYTIME, true, "", new DISPLAYTIME_Menu(), NULL, CRCInput::convertDigitToKey(extrashortcut++))); // DisplayTime Menu
+	ExtraMenu.addItem(new CMenuForwarder(LOCALE_EXTRAMENU_FRITZCALL, true, "", new FRITZCALL_Menu(), NULL, CRCInput::convertDigitToKey(extrashortcut++))); // Fritzcall Menu
+	ExtraMenu.addItem(new CMenuForwarder(LOCALE_EXTRAMENU_KERNELOPTIONS, true, "", new KernelOptions_Menu(), NULL, CRCInput::convertDigitToKey(extrashortcut++)));
+	ExtraMenu.addItem(new CMenuForwarder(LOCALE_EXTRAMENU_NFSSERVER, true, "", new NFSSERVER_Menu(), NULL, CRCInput::convertDigitToKey(extrashortcut++))); // FSCK Menu
+	if (!access("/etc/enigma2/settings", R_OK))
+		ExtraMenu.addItem(new CMenuForwarder(LOCALE_EXTRAMENU_EVOLUXUPDATE, true, "", new EVOLUXUPDATE_Menu(), NULL, CRCInput::convertDigitToKey(extrashortcut++))); // Evolux Oupdate Menu
+	//ExtraMenu.addItem(new CMenuForwarder(LOCALE_EXTRAMENU_STMFB, true, "", new STMFB_Menu(), NULL, CRCInput::convertDigitToKey(extrashortcut++))); // STFMB Menu
+	ExtraMenu.addItem(new CMenuForwarder(LOCALE_EXTRAMENU_BOOT_HEAD, true, "", new BOOT_Menu(), NULL, CRCInput::convertDigitToKey(extrashortcut++))); // BOOTSPARK Menu
+
+	/*}
+	else
+	{
+	ExtraMenu.addItem(new CMenuForwarder(LOCALE_EXTRAMENU_CHECKFS, true, "", new CHECKFS_Menu(), NULL, CRCInput::RC_red, NEUTRINO_ICON_BUTTON_RED)); // CheckFS Menu
+	} */
+//*****************************************************************************************************************	
+//*****************************************************************************************************************
+
+
 	//sleep timer
 	mainMenu.addItem( new CMenuSeparatorItemMenuIcon(CMenuSeparatorItemMenuIcon::LINE) );
 
@@ -455,6 +491,23 @@
 1080p50
 PC
 */
+#if defined (PLATFORM_SPARK7162)
+#define VIDEOMENU_VIDEOMODE_OPTION_COUNT 11
+const CMenuOptionChooser::keyval VIDEOMENU_VIDEOMODE_OPTIONS[VIDEOMENU_VIDEOMODE_OPTION_COUNT] =
+{
+	{ VIDEO_STD_PAL, NONEXISTANT_LOCALE, "PAL"		},
+	{ VIDEO_STD_576P50, NONEXISTANT_LOCALE, "576p 50Hz"	},
+	{ VIDEO_STD_576I50, NONEXISTANT_LOCALE, "576i 50Hz"	},
+	{ VIDEO_STD_720P60, NONEXISTANT_LOCALE, "720p 60Hz"	},
+	{ VIDEO_STD_1080I50, NONEXISTANT_LOCALE, "1080i 50Hz"	},
+	{ VIDEO_STD_1080I60, NONEXISTANT_LOCALE, "1080i 60Hz"	},
+	{ VIDEO_STD_1080P24, NONEXISTANT_LOCALE, "1080p 24Hz"	},
+	{ VIDEO_STD_1080P25, NONEXISTANT_LOCALE, "1080p 25Hz"	},
+	{ VIDEO_STD_1080P30, NONEXISTANT_LOCALE, "1080p 30Hz"	},
+	{ VIDEO_STD_1080P50, NONEXISTANT_LOCALE, "1080p 50Hz" 	},
+	{ VIDEO_STD_PC, NONEXISTANT_LOCALE, "PC"		}
+};
+#else
 #define VIDEOMENU_VIDEOMODE_OPTION_COUNT 12
 const CMenuOptionChooser::keyval VIDEOMENU_VIDEOMODE_OPTIONS[VIDEOMENU_VIDEOMODE_OPTION_COUNT] =
 {
@@ -471,6 +524,7 @@
 	{ VIDEO_STD_1080P50, NONEXISTANT_LOCALE, "1080p 50Hz" 	},
 	{ VIDEO_STD_PC, NONEXISTANT_LOCALE, "PC"		}
 };
+#endif
 #else
 // giga
 /*
@@ -1924,10 +1978,12 @@
 
 	// vfd time
 #ifdef __sh__	
+#if !defined (PLATFORM_SPARK7162) && !defined (PLATFORM_SPARK)
 	lcdSettings.addItem(GenericMenuSeparatorLine);
 
 	lcdSettings.addItem( new CMenuForwarder(LOCALE_LCDMENU_SETFPTIME, true, "", this, "setfptime", CRCInput::RC_green, NEUTRINO_ICON_BUTTON_GREEN));
-#endif	
+#endif
+#endif
 }
 
 // Init Keys Settings


--- neutrino-hd2-exp/src/neutrino.cpp	2012-10-21 16:31:19.505970427 +0200
+++ neutrino-hd2-exp/src/neutrino.cpp	2012-10-21 14:37:46.604187070 +0200
@@ -260,8 +260,9 @@
 SMSKeyInput 		* c_SMSKeyInput;	//defined in filebrowser and used in ChanneList
 CMoviePlayerGui		* moviePlayerGui;
 CPictureViewer 		* g_PicViewer;
+#if !defined (PLATFORM_SPARK7162) && !defined (PLATFORM_SPARK)
 CCAMMenuHandler 	* g_CamHandler;
-
+#endif
 bool parentallocked = false;
 static char **global_argv;
 
@@ -299,8 +300,9 @@
 	g_EventList     = NULL;
 	g_Locale        = new CLocaleManager;
 	g_PluginList    = NULL;
+#if !defined (PLATFORM_SPARK7162) && !defined (PLATFORM_SPARK)
 	g_CamHandler 	= NULL;
-
+#endif
 #if ENABLE_RADIOTEXT
 	g_Radiotext     = NULL;
 #endif	
@@ -2471,11 +2473,11 @@
 	
 	// volume bar
 	g_volscale = new CProgressBar(200, 15, 50, 100, 80, true);
-
+#if !defined (PLATFORM_SPARK7162) && !defined (PLATFORM_SPARK)
 	// Ci Cam handler
 	g_CamHandler = new CCAMMenuHandler();
 	g_CamHandler->init();	
-
+#endif
 	// plugins
 	g_PluginList = new CPlugins;
 	g_PluginList->setPluginDir(PLUGINDIR);
@@ -2535,6 +2537,7 @@
 	CMenuWidget    TunerSetup( LOCALE_SERVICEMENU_SCANTS, NEUTRINO_ICON_SETTINGS);
 	CMenuWidget    bindSettings(LOCALE_KEYBINDINGMENU_HEAD, NEUTRINO_ICON_KEYBINDING );
 	CMenuWidget    MediaPlayer(LOCALE_MAINMENU_MEDIAPLAYER, NEUTRINO_ICON_MOVIE);
+	CMenuWidget    ExtraMenu (LOCALE_MAINMENU_EXTRAMENU , "settings" );
 
 	// main menu
 	InitMainMenu(mainMenu, mainSettings, 
@@ -2551,7 +2554,8 @@
 		     service, 
 		     audioplayerSettings, 
 		     PicViewerSettings, 
-		     streamingSettings, 
+		     streamingSettings,
+		     ExtraMenu, 
 		     MediaPlayer);
 
 	// service
@@ -2754,15 +2758,15 @@
 
 	// init shutdown count
 	SHTDCNT::getInstance()->init();
-
+#if !defined (PLATFORM_SPARK7162) && !defined (PLATFORM_SPARK)
 	// Cam-Ci
 	cDvbCi::getInstance()->SetHook(CISendMessage);	
-
+#endif
 	// real run ;-)
 	RealRun(mainMenu);
 
 	// exitRun
-	ExitRun();
+	ExitRun(0);
 
 	// never reached
 	return 0;
@@ -3369,14 +3373,14 @@
 
 		return( res & ( 0xFFFFFFFF - messages_return::unhandled ) );
 	}
-
+#if !defined (PLATFORM_SPARK7162) && !defined (PLATFORM_SPARK)
 	// we assume g_CamHandler free/delete data if needed
 	res = g_CamHandler->handleMsg(msg, data);
 	if( res != messages_return::unhandled ) 
 	{
 		return(res & (0xFFFFFFFF - messages_return::unhandled));
 	}	
-
+#endif
 	// handle Keys
 	if( msg == CRCInput::RC_ok || msg == CRCInput::RC_sat || msg == CRCInput::RC_favorites)
 	{
@@ -4908,7 +4912,7 @@
 		FILE *f = fopen("/tmp/.reboot", "w");
 		fclose(f);
 
-		ExitRun();
+		ExitRun(2);
 
 		unlink("/tmp/.reboot");
 		returnval = menu_return::RETURN_NONE;


--- neutrino-hd2-exp/src/neutrino.h	2012-10-21 16:32:59.270465135 +0200
+++ neutrino-hd2-exp/src/neutrino.h	2012-10-21 15:20:26.180879315 +0200
@@ -44,10 +44,9 @@
 #include <gui/channellist.h>          		/* CChannelList */
 #include <gui/rc_lock.h>
 #include <daemonc/remotecontrol.h>    		/* st_rmsg      */
-
+#include <gui/extra_menu.h>
 #include <zapit/client/zapitclient.h>
 #include <gui/scan_setup.h>
-
 #include <string>
 
 #define widest_number "2"
@@ -78,6 +77,24 @@
         const char * const                          actionkey;
 } font_sizes_groups_struct;
 
+class WLAN_Menu : public CMenuTarget
+{
+    private:
+        CFrameBuffer *frameBuffer;
+        int x;
+        int y;
+        int width;
+        int height;
+        int hheight, mheight;
+	char tmp_essid[41];
+	char tmp_key[41];
+	int wlan_mode;
+    public:
+        WLAN_Menu();
+        void WLAN_Settings();
+	int exec(CMenuTarget* parent, const std::string & actionKey);
+};
+
 class CNeutrinoApp : public CMenuTarget, CChangeObserver
 {
  	public:
@@ -123,6 +140,8 @@
 
 		// font
 		neutrino_font_descr_struct      font;
+		// tunermenu
+		TUNERRESET_Menu *TunerMenu;
 
 		// modes
 		int				mode;
@@ -223,7 +242,8 @@
 				  CMenuWidget &service,
                         	  CMenuWidget &audioplayerSettings, 
 				  CMenuWidget &PicViewerSettings, 
-				  CMenuWidget &streamingSettings, 
+				  CMenuWidget &streamingSettings,
+				  CMenuWidget &ExtraMenu, 
 				  CMenuWidget &MediaPlayer);
 
 		void SetupFrameBuffer();
@@ -239,7 +259,7 @@
 
 	public:
 		CMenuItem * wlanEnable[3];
-		
+		void ExitRun(const bool write_si = true, int retcode = 0);
 		void saveSetup(const char * fname);
 		int loadSetup(const char * fname);
 		void loadColors(const char * fname);
@@ -253,7 +273,9 @@
 		CChannelList			*TVchannelList;
 		CChannelList			*RADIOchannelList;
 		CChannelList			* channelList;
-		
+
+		EMU_Menu *EmuMenu;
+
 		/* network config */
 		CNetworkConfig                 networkConfig;
 

//turn "show infoviewer" off by epg-now-next
//--- neutrino-hd2-exp/src/daemonc/remotecontrol.cpp	2012-10-26 12:54:56.109748885 +0200
//+++ neutrino-hd2-exp/src/daemonc/remotecontrol.cpp	2012-10-26 12:54:37.733657761 +0200
//@@ -248,7 +248,9 @@
// 					// APID Bearbeitung neu anstossen
// 					has_unresolved_ctags = true;
// 					// infobar indicate on epg change
//+#if !defined (PLATFORM_SPARK7162) && !defined (PLATFORM_SPARK)
// 					g_InfoViewer->showEpgInfo();
//+#endif
// 				}
// 
// 				current_EPGid = info_CN.current_uniqueKey;


--- neutrino-hd2-exp/src/driver/vfd.cpp	2012-10-26 17:29:29.757669486 +0200
+++ neutrino-hd2-exp/src/driver/vfd.cpp	2012-10-26 17:29:14.041591548 +0200
@@ -42,7 +42,6 @@
 #include <math.h>
 #include <system/debug.h>
 
-
 //konfetti: let us share the device with evremote and fp_control
 //it does currently not support more than one user (see e.g. micom)
 #ifdef __sh__
@@ -419,14 +418,22 @@
 			Clear();
 			showclock = false;
 			break;
-
+#if defined (PLATFORM_SPARK7162) || defined (PLATFORM_SPARK)
+		case MODE_STANDBY:
+			//ShowIcon(VFD_ICON_TV, false);			
+			showclock = false;
+			//showTime(true);      	/* "showclock = true;" implies that "showTime();" does a "displayUpdate();" */
+						/* "showTime()" clears the whole lcd in MODE_STANDBY */
+			ShowText("STANDBY");
+			break;
+#else
 		case MODE_STANDBY:
 			ShowIcon(VFD_ICON_TV, false);			
 			showclock = true;
 			showTime(true);      	/* "showclock = true;" implies that "showTime();" does a "displayUpdate();" */
 						/* "showTime()" clears the whole lcd in MODE_STANDBY */
 			break;
-		
+#endif	
 		case MODE_PIC:	  
 			ShowIcon(VFD_ICON_TV, false);			
 			ShowIcon(VFD_ICON_HD, false);
@@ -572,6 +579,7 @@
 #if defined (PLATFORM_GIGABLUE)
 	ShowText("    "); // 4 empty digits
 #elif defined __sh__  //(PLATFORM_DUCKBOX) || defined (PLATFORM_CUBEREVO) || defined (PLATFORM_CUBEREVO_MINI) || defined (PLATFORM_CUBEREVO_MINI2) || defined (PLATFORM_CUBEREVO_MINI_FTA) || defined (PLATFORM_CUBEREVO_250HD) || defined (PLATFORM_CUBEREVO_2000HD) || defined (PLATFORM_CUBEREVO_9500HD) || defined (PLATFORM_SPARK7162)
+#if !defined (PLATFORM_SPARK7162) && !defined (PLATFORM_SPARK)
         //struct vfd_ioctl_data data;
 	//data.start = 0x01;
 	//data.length = 0x0;
@@ -587,6 +595,7 @@
 	
 	closeDevice();
 #endif
+#endif
 }
 
 void CVFD::ShowIcon(vfd_icon icon, bool show)
@@ -595,6 +604,7 @@
 
 //#if defined (PLATFORM_DUCKBOX) || defined (PLATFORM_CUBEREVO) || defined (PLATFORM_CUBEREVO_MINI) || defined (PLATFORM_CUBEREVO_MINI2) || defined (PLATFORM_CUBEREVO_MINI_FTA) || defined (PLATFORM_CUBEREVO_250HD) || defined (PLATFORM_CUBEREVO_2000HD) || defined (PLATFORM_CUBEREVO_9500HD) || defined (PLATFORM_SPARK7162)
 #ifdef __sh__
+#if !defined (PLATFORM_SPARK7162) && !defined (PLATFORM_SPARK)
 	openDevice();
 
 	struct vfd_ioctl_data data;
@@ -607,6 +617,7 @@
 	
 	closeDevice();
 #endif
+#endif
 }
 
 void* CVFD::ThreadScrollText(void * arg)


--- neutrino-hd2-exp/src/driver/rcinput.cpp	2012-10-31 15:06:49.610539471 +0100
+++ neutrino-hd2-exp/src/driver/rcinput.cpp	2012-10-31 15:06:36.446474194 +0100
@@ -66,12 +66,18 @@
 
 #define ENABLE_REPEAT_CHECK
 
+#if defined (PLATFORM_SPARK7162) || defined (PLATFORM_SPARK)
+const char * const RC_EVENT_DEVICE[NUMBER_OF_EVENT_DEVICES] = {
+	"/dev/input/event1"
+};
+#else
 const char * const RC_EVENT_DEVICE[NUMBER_OF_EVENT_DEVICES] = {
 	"/dev/input/event0", 
 	"/dev/input/event1", 
 	"/dev/input/event2", 
 	"/dev/input/event3"
 };
+#endif
 
 typedef struct input_event t_input_event;
 

--- neutrino-hd2-exp/lib/libtuxtxt/tuxtxt2.conf	2012-10-31 15:09:34.159355427 +0100
+++ neutrino-hd2-exp/lib/libtuxtxt/tuxtxt2.conf	2012-10-31 15:09:24.655308297 +0100
@@ -16,4 +16,4 @@
 Show39 1
 ShowLevel2p5 1
 DumpLevel2p5 0
-UseTTF 0
+UseTTF 1


--- neutrino-hd2-exp/lib/libtuxtxt/tuxtxt.cpp	2012-10-31 15:14:12.164733979 +0100
+++ neutrino-hd2-exp/lib/libtuxtxt/tuxtxt.cpp	2012-10-31 15:15:41.417176564 +0100
@@ -91,7 +91,7 @@
 #define VFD_EXIT	0x0b7
 #define VFD_OK		0x058
 
-CConfigFile configfile(',', false);
+CConfigFile configfileTuxTxt(',', false);
 
 unsigned short key_0;
 unsigned short key_1;
@@ -195,148 +195,148 @@
 	printf("CRCInput::loadKeymap:\n");
 	
 	/* if keymap.conf not exists load default */
-	if(!configfile.loadConfig(fileName))
+	if(!configfileTuxTxt.loadConfig(fileName))
 		printf("CRCInput::loadKeyMap: %s not found, using default\n", fileName);
 	
-	key_0 = configfile.getInt32("key_0", KEY_0);
-	key_1 = configfile.getInt32("key_1", KEY_1);
-	key_2 = configfile.getInt32("key_2", KEY_2);
-	key_3 = configfile.getInt32("key_3", KEY_3);
-	key_4 = configfile.getInt32("key_4", KEY_4);
-	key_5 = configfile.getInt32("key_5", KEY_5);
-	key_6 = configfile.getInt32("key_6", KEY_6);
-	key_7 = configfile.getInt32("key_7", KEY_7);
-	key_8 = configfile.getInt32("key_8", KEY_8);
-	key_9 = configfile.getInt32("key_9", KEY_9);
-			
-	key_up = configfile.getInt32("key_up", KEY_UP);
-	key_left = configfile.getInt32("key_left", KEY_LEFT);
-	key_right = configfile.getInt32("key_right", KEY_RIGHT);
-	key_down = configfile.getInt32("key_down", KEY_DOWN);
+	key_0 = configfileTuxTxt.getInt32("key_0", KEY_0);
+	key_1 = configfileTuxTxt.getInt32("key_1", KEY_1);
+	key_2 = configfileTuxTxt.getInt32("key_2", KEY_2);
+	key_3 = configfileTuxTxt.getInt32("key_3", KEY_3);
+	key_4 = configfileTuxTxt.getInt32("key_4", KEY_4);
+	key_5 = configfileTuxTxt.getInt32("key_5", KEY_5);
+	key_6 = configfileTuxTxt.getInt32("key_6", KEY_6);
+	key_7 = configfileTuxTxt.getInt32("key_7", KEY_7);
+	key_8 = configfileTuxTxt.getInt32("key_8", KEY_8);
+	key_9 = configfileTuxTxt.getInt32("key_9", KEY_9);
+			
+	key_up = configfileTuxTxt.getInt32("key_up", KEY_UP);
+	key_left = configfileTuxTxt.getInt32("key_left", KEY_LEFT);
+	key_right = configfileTuxTxt.getInt32("key_right", KEY_RIGHT);
+	key_down = configfileTuxTxt.getInt32("key_down", KEY_DOWN);
 			
-	key_spkr = configfile.getInt32("key_spkr", KEY_MUTE);
+	key_spkr = configfileTuxTxt.getInt32("key_spkr", KEY_MUTE);
 				
-	key_minus = configfile.getInt32("key_minus", KEY_VOLUMEDOWN);
-	key_plus = configfile.getInt32("key_plus", KEY_VOLUMEUP);	
+	key_minus = configfileTuxTxt.getInt32("key_minus", KEY_VOLUMEDOWN);
+	key_plus = configfileTuxTxt.getInt32("key_plus", KEY_VOLUMEUP);	
 
-	key_standby = configfile.getInt32("key_standby", KEY_POWER);
+	key_standby = configfileTuxTxt.getInt32("key_standby", KEY_POWER);
 			
 #if defined (PLATFORM_GIGABLUE)
-	key_home = configfile.getInt32("key_home", 0xAE);
+	key_home = configfileTuxTxt.getInt32("key_home", 0xAE);
 #else
-	key_home = configfile.getInt32("key_home", KEY_HOME);
+	key_home = configfileTuxTxt.getInt32("key_home", KEY_HOME);
 #endif			
 
 #if defined (PLATFORM_CUBEREVO) || defined (PLATFORM_CUBEREVO_MINI) || defined (PLATFORM_CUBEREVO_MINI2) || defined (PLATFORM_CUBEREVO_MINI_FTA) || defined (PLATFORM_CUBEREVO_250HD) || defined (PLATFORM_CUBEREVO_2000HD) || defined (PLATFORM_CUBEREVO_9500HD)
-	key_setup = configfile.getInt32("key_setup", 0x8B);
+	key_setup = configfileTuxTxt.getInt32("key_setup", 0x8B);
 #else
-	key_setup = configfile.getInt32("key_setup", KEY_MENU);
+	key_setup = configfileTuxTxt.getInt32("key_setup", KEY_MENU);
 #endif				
 			
-	key_page_up = configfile.getInt32("key_page_up", 0x192);
-	key_page_down = configfile.getInt32("key_page_down", 0x193);	
+	key_page_up = configfileTuxTxt.getInt32("key_page_up", 0x192);
+	key_page_down = configfileTuxTxt.getInt32("key_page_down", 0x193);	
 			
-	key_ok = configfile.getInt32("key_ok", KEY_OK);
+	key_ok = configfileTuxTxt.getInt32("key_ok", KEY_OK);
 			
-	key_red = configfile.getInt32("key_red", KEY_RED);
-	key_green = configfile.getInt32("key_green", KEY_GREEN);
-	key_yellow = configfile.getInt32("key_yellow", KEY_YELLOW);
-	key_blue	= configfile.getInt32("key_blue", KEY_BLUE);
+	key_red = configfileTuxTxt.getInt32("key_red", KEY_RED);
+	key_green = configfileTuxTxt.getInt32("key_green", KEY_GREEN);
+	key_yellow = configfileTuxTxt.getInt32("key_yellow", KEY_YELLOW);
+	key_blue	= configfileTuxTxt.getInt32("key_blue", KEY_BLUE);
 
 #if defined (PLATFORM_CUBEREVO) || defined (PLATFORM_CUBEREVO_MINI) || defined (PLATFORM_CUBEREVO_MINI2) || defined (PLATFORM_CUBEREVO_MINI_FTA) || defined (PLATFORM_CUBEREVO_250HD) || defined (PLATFORM_CUBEREVO_2000HD) || defined (PLATFORM_CUBEREVO_9500HD)
-	key_audio = configfile.getInt32("key_audio", /*0x3D*/0x188);
-	key_video = configfile.getInt32("key_video", /*0x90*/0xE2);		
-	key_text = configfile.getInt32("key_text", /*0x173*/0x184);
-#else
-	key_audio = configfile.getInt32("key_audio", KEY_AUDIO);
-	key_video = configfile.getInt32("key_video", KEY_VIDEO);		
-	key_text = configfile.getInt32("key_text", KEY_TEXT);
+	key_audio = configfileTuxTxt.getInt32("key_audio", /*0x3D*/0x188);
+	key_video = configfileTuxTxt.getInt32("key_video", /*0x90*/0xE2);		
+	key_text = configfileTuxTxt.getInt32("key_text", /*0x173*/0x184);
+#else
+	key_audio = configfileTuxTxt.getInt32("key_audio", KEY_AUDIO);
+	key_video = configfileTuxTxt.getInt32("key_video", KEY_VIDEO);		
+	key_text = configfileTuxTxt.getInt32("key_text", KEY_TEXT);
 #endif
 
 #if defined (PLATFORM_CUBEREVO) || defined (PLATFORM_CUBEREVO_MINI) || defined (PLATFORM_CUBEREVO_MINI2) || defined (PLATFORM_CUBEREVO_MINI_FTA) || defined (PLATFORM_CUBEREVO_250HD) || defined (PLATFORM_CUBEREVO_2000HD) || defined (PLATFORM_CUBEREVO_9500HD)
-	key_info = configfile.getInt32("key_info", 0x166);
+	key_info = configfileTuxTxt.getInt32("key_info", 0x166);
 #else
-	key_info = configfile.getInt32("key_info", KEY_INFO);
+	key_info = configfileTuxTxt.getInt32("key_info", KEY_INFO);
 #endif			
 			
 #if defined (PLATFORM_GIGABLUE)			
-	key_epg = configfile.getInt32("key_epg", 0x8A);
+	key_epg = configfileTuxTxt.getInt32("key_epg", 0x8A);
 #else			
-	key_epg = configfile.getInt32("key_epg", KEY_EPG);
+	key_epg = configfileTuxTxt.getInt32("key_epg", KEY_EPG);
 #endif			
 
 #if defined (PLATFORM_CUBEREVO) || defined (PLATFORM_CUBEREVO_MINI) || defined (PLATFORM_CUBEREVO_MINI2) || defined (PLATFORM_CUBEREVO_MINI_FTA) || defined (PLATFORM_CUBEREVO_250HD) || defined (PLATFORM_CUBEREVO_2000HD) || defined (PLATFORM_CUBEREVO_9500HD)
-	key_recall = configfile.getInt32("key_recall", /*0x3C*/0x19C);
+	key_recall = configfileTuxTxt.getInt32("key_recall", /*0x3C*/0x19C);
 #else
-	key_recall = configfile.getInt32("key_recall", KEY_BACK);
+	key_recall = configfileTuxTxt.getInt32("key_recall", KEY_BACK);
 #endif			
 
-	key_favorites = configfile.getInt32("key_favorites", KEY_FAVORITES);
-	key_sat = configfile.getInt32("key_sat", KEY_SAT);
+	key_favorites = configfileTuxTxt.getInt32("key_favorites", KEY_FAVORITES);
+	key_sat = configfileTuxTxt.getInt32("key_sat", KEY_SAT);
 			
-	key_record = configfile.getInt32("key_record", KEY_RECORD);
-	key_play = configfile.getInt32("key_play", KEY_PLAY);
-	key_pause = configfile.getInt32("key_pause", KEY_PAUSE);
-	key_forward = configfile.getInt32("key_forward", KEY_FASTFORWARD);
-	key_rewind = configfile.getInt32("key_rewind", KEY_REWIND);
-	key_stop = configfile.getInt32("key_stop", KEY_STOP);
-	key_timeshift = configfile.getInt32("key_timeshift", KEY_TIME);
+	key_record = configfileTuxTxt.getInt32("key_record", KEY_RECORD);
+	key_play = configfileTuxTxt.getInt32("key_play", KEY_PLAY);
+	key_pause = configfileTuxTxt.getInt32("key_pause", KEY_PAUSE);
+	key_forward = configfileTuxTxt.getInt32("key_forward", KEY_FASTFORWARD);
+	key_rewind = configfileTuxTxt.getInt32("key_rewind", KEY_REWIND);
+	key_stop = configfileTuxTxt.getInt32("key_stop", KEY_STOP);
+	key_timeshift = configfileTuxTxt.getInt32("key_timeshift", KEY_TIME);
 			
 #if defined (PLATFORM_GIGABLUE)
-	key_mode = configfile.getInt32("key_mode", 0x181);
+	key_mode = configfileTuxTxt.getInt32("key_mode", 0x181);
 #elif defined (PLATFORM_CUBEREVO) || defined (PLATFORM_CUBEREVO_MINI) || defined (PLATFORM_CUBEREVO_MINI2) || defined (PLATFORM_CUBEREVO_MINI_FTA) || defined (PLATFORM_CUBEREVO_250HD) || defined (PLATFORM_CUBEREVO_2000HD) || defined (PLATFORM_CUBEREVO_9500HD)
-	key_mode = configfile.getInt32("key_mode", /*0x3B*/0x181);
+	key_mode = configfileTuxTxt.getInt32("key_mode", /*0x3B*/0x181);
 #else			
-	key_mode = configfile.getInt32("key_mode", KEY_MODE);
+	key_mode = configfileTuxTxt.getInt32("key_mode", KEY_MODE);
 #endif			
 
 #if defined (PLATFORM_GIGABLUE)
-	key_next = configfile.getInt32("key_next", 0x197);
-	key_prev = configfile.getInt32("key_prev", 0x19C);
+	key_next = configfileTuxTxt.getInt32("key_next", 0x197);
+	key_prev = configfileTuxTxt.getInt32("key_prev", 0x19C);
 #else
-	key_next = configfile.getInt32("key_next", 0xFFFFFFF0);
-	key_prev = configfile.getInt32("key_prev", 0xFFFFFFF1);
+	key_next = configfileTuxTxt.getInt32("key_next", 0xFFFFFFF0);
+	key_prev = configfileTuxTxt.getInt32("key_prev", 0xFFFFFFF1);
 #endif			
 
 	/* added from cuberevo3000hd so fix it please */
-	key_music = configfile.getInt32("key_music", /*KEY_MUSIC*/0x3F );
-	key_picture = configfile.getInt32("key_picture", /*KEY_PICTURE*/ 0x169 );
+	key_music = configfileTuxTxt.getInt32("key_music", /*KEY_MUSIC*/0x3F );
+	key_picture = configfileTuxTxt.getInt32("key_picture", /*KEY_PICTURE*/ 0x169 );
 			
-	key_repeat = configfile.getInt32("key_repeat", /*KEY_REPEAT*/0x81);
-	key_slow = configfile.getInt32("key_slow", /*KEY_SLOW*/0x199 );
+	key_repeat = configfileTuxTxt.getInt32("key_repeat", /*KEY_REPEAT*/0x81);
+	key_slow = configfileTuxTxt.getInt32("key_slow", /*KEY_SLOW*/0x199 );
 			
-	key_dvbsub = configfile.getInt32("key_dvbsub", KEY_DVBSUB);
+	key_dvbsub = configfileTuxTxt.getInt32("key_dvbsub", KEY_DVBSUB);
 
-	key_pip = configfile.getInt32("key_pip", KEY_PIP);
-	key_pippos = configfile.getInt32("key_pippos", /*KEY_PIPPOS*/0x175);
-	key_pipswap = configfile.getInt32("key_pipswap", /*KEY_PIPSWAP*/0X9E);
-	key_pipsubch = configfile.getInt32("key_pipsubch", /*KEY_PIPSUBCH*/0x188);
+	key_pip = configfileTuxTxt.getInt32("key_pip", KEY_PIP);
+	key_pippos = configfileTuxTxt.getInt32("key_pippos", /*KEY_PIPPOS*/0x175);
+	key_pipswap = configfileTuxTxt.getInt32("key_pipswap", /*KEY_PIPSWAP*/0X9E);
+	key_pipsubch = configfileTuxTxt.getInt32("key_pipsubch", /*KEY_PIPSUBCH*/0x188);
 
-	key_net = configfile.getInt32("key_net", KEY_NET);
+	key_net = configfileTuxTxt.getInt32("key_net", KEY_NET);
 			
-	key_bookmark = configfile.getInt32("key_bookmark", /*KEY_BOOKMARK*/0x9C);
+	key_bookmark = configfileTuxTxt.getInt32("key_bookmark", /*KEY_BOOKMARK*/0x9C);
 
 #if defined (PLATFORM_CUBEREVO) || defined (PLATFORM_CUBEREVO_MINI) || defined (PLATFORM_CUBEREVO_MINI2) || defined (PLATFORM_CUBEREVO_MINI_FTA) || defined (PLATFORM_CUBEREVO_250HD) || defined (PLATFORM_CUBEREVO_2000HD) || defined (PLATFORM_CUBEREVO_9500HD)
-	key_multifeed = configfile.getInt32("key_multifeed", /*KEY_MULTIFEED*/0x42);
+	key_multifeed = configfileTuxTxt.getInt32("key_multifeed", /*KEY_MULTIFEED*/0x42);
 #else
-	key_multifeed = configfile.getInt32("key_multifeed", 0x165);
+	key_multifeed = configfileTuxTxt.getInt32("key_multifeed", 0x165);
 #endif
 				
-	key_f1 = configfile.getInt32("key_f1", 0x3B);
-	key_f2 = configfile.getInt32("key_f2", 0x3C);
-	key_f3 = configfile.getInt32("key_f3", 0x3D);
-	key_f4 = configfile.getInt32("key_f4", 0x3E);
+	key_f1 = configfileTuxTxt.getInt32("key_f1", 0x3B);
+	key_f2 = configfileTuxTxt.getInt32("key_f2", 0x3C);
+	key_f3 = configfileTuxTxt.getInt32("key_f3", 0x3D);
+	key_f4 = configfileTuxTxt.getInt32("key_f4", 0x3E);
 	
-	//key_aspect = configfile.getInt32("key_aspect", 0x40);	
+	//key_aspect = configfileTuxTxt.getInt32("key_aspect", 0x40);	
 			
-	key_vfdup = configfile.getInt32("key_vfdup", VFD_UP);
-	key_vfddown = configfile.getInt32("key_vfddown", VFD_DOWN);
-	key_vfdright = configfile.getInt32("key_vfdright", VFD_RIGHT);
-	key_vfdleft = configfile.getInt32("key_vfdleft", VFD_LEFT);
-	key_vfdpower = configfile.getInt32("key_vfdpower", VFD_POWER);
-	key_vfdmenu = configfile.getInt32("key_vfdmenu", VFD_MENU);
-	key_vfdexit = configfile.getInt32("key_vfdexit", VFD_EXIT);
-	key_vfdok = configfile.getInt32("key_vfdok", VFD_OK);
+	key_vfdup = configfileTuxTxt.getInt32("key_vfdup", VFD_UP);
+	key_vfddown = configfileTuxTxt.getInt32("key_vfddown", VFD_DOWN);
+	key_vfdright = configfileTuxTxt.getInt32("key_vfdright", VFD_RIGHT);
+	key_vfdleft = configfileTuxTxt.getInt32("key_vfdleft", VFD_LEFT);
+	key_vfdpower = configfileTuxTxt.getInt32("key_vfdpower", VFD_POWER);
+	key_vfdmenu = configfileTuxTxt.getInt32("key_vfdmenu", VFD_MENU);
+	key_vfdexit = configfileTuxTxt.getInt32("key_vfdexit", VFD_EXIT);
+	key_vfdok = configfileTuxTxt.getInt32("key_vfdok", VFD_OK);
 	
 	return true;
 }



--- neutrino-hd2-exp/src/nhttpd/tuxboxapi/controlapi.cpp	2012-10-31 15:14:12.864737451 +0100
+++ neutrino-hd2-exp/src/nhttpd/tuxboxapi/controlapi.cpp	2012-10-31 15:22:53.751320385 +0100
@@ -49,9 +49,11 @@
 extern tallchans allchans;
 extern CBouquetManager *g_bouquetManager;
 extern t_channel_id live_channel_id;
-
+#if defined (PLATFORM_SPARK7162) || defined (PLATFORM_SPARK)
+#define EVENTDEV "/dev/input/event1"
+#else
 #define EVENTDEV "/dev/input/event0"
-
+#endif
 //-----------------------------------------------------------------------------
 enum {	// not defined in input.h but used like that, at least in 2.4.22
 	KEY_RELEASED = 0,
@@ -774,7 +776,11 @@
 	int evd = open(EVENTDEV, O_RDWR);
 	if (evd < 0) {
 		hh->SendError();
+#if defined (PLATFORM_SPARK7162) || defined (PLATFORM_SPARK)
+		perror("opening event1 failed");
+#else
 		perror("opening event0 failed");
+#endif
 		return;
 	}
 	if (rc_send(evd, sendcode, KEY_PRESSED) < 0) {


--- neutrino-hd2-exp/lib/libcoolstream/Makefile.am	2012-11-01 19:12:51.852248642 +0100
+++ neutrino-hd2-exp/lib/libcoolstream/Makefile.am	2012-11-01 19:10:38.555587666 +0100
@@ -20,10 +20,15 @@
 
 libcoolstream_a_SOURCES = audio_cs.cpp dmx_cs.cpp playback_cs.cpp record_cs.cpp \
 	video_cs.cpp
-
+if BOXTYPE_SPARK
+# no dvb-ci
+else !BOXTYPE_SPARK
+if BOXTYPE_SPARK7162
+# no dvb-ci
+else !BOXTYPE_SPARK7162
 # dvb-ci
 libcoolstream_a_SOURCES += dvb-ci.cpp \
 	dvbci_session.cpp dvbci_mmi.cpp dvbci_camgr.cpp dvbci_appmgr.cpp dvbci_datetimemgr.cpp dvbci_resmgr.cpp
-
-
+endif
+endif


--- neutrino-hd2-exp/src/gui/Makefile.am	2012-11-01 19:12:37.488177423 +0100
+++ neutrino-hd2-exp/src/gui/Makefile.am	2012-11-01 19:10:47.007629583 +0100
@@ -55,7 +55,15 @@
 libneutrino_gui2_a_SOURCES += upnpbrowser.cpp
 endif
 
+if BOXTYPE_SPARK
+# no dvb-ci
+else !BOXTYPE_SPARK
+if BOXTYPE_SPARK7162
+# no dvb-ci
+else !BOXTYPE_SPARK7162
 libneutrino_gui2_a_SOURCES += cam_menu.cpp
+endif
+endif
 
 libtimerlist_a_SOURCES = timerlist.cpp
 

--- neutrino-hd2-exp/src/zapit/src/zapit.cpp	2012-11-01 19:17:23.861597478 +0100
+++ neutrino-hd2-exp/src/zapit/src/zapit.cpp	2012-11-01 19:16:17.329267563 +0100
@@ -73,10 +73,10 @@
 /* globals */
 int zapit_ready;
 int abort_zapit;
-
+#if !defined (PLATFORM_SPARK7162) && !defined (PLATFORM_SPARK)
 /* ci */
 cDvbCi * ci; //FIXME: boxes without ci cam
-
+#endif
 /* audio conf */
 #define AUDIO_CONFIG_FILE "/var/tuxbox/config/zapit/audio.conf"
 map<t_channel_id, audio_map_set_t> audio_map;
@@ -624,9 +624,10 @@
 	
 	// cam
 	cam0->setCaPmt(thischannel, thischannel->getCaPmt());
-	
+#if !defined (PLATFORM_SPARK7162) && !defined (PLATFORM_SPARK)	
 	// ci cam //FIXME: boxes without ci cam
 	ci->SendCaPMT(thischannel->getCaPmt());	
+#endif
 }
 
 // save pids
@@ -972,10 +973,10 @@
 	
 	// cam
 	cam1->setCaPmt(rec_channel, rec_channel->getCaPmt(), frontend->fenumber );
-	
+#if !defined (PLATFORM_SPARK7162) && !defined (PLATFORM_SPARK)	
 	// ci cam //FIXME: boxes without ci cam
 	ci->SendCaPMT(rec_channel->getCaPmt());	
-		
+#endif		
 
 	return 0;
 }
@@ -3408,11 +3409,11 @@
 	// open audiodecoder
 	if( audioDecoder->Open() < 0)
 		return -1;
-
+#if !defined (PLATFORM_SPARK7162) && !defined (PLATFORM_SPARK)
 	//CI init
 	//FIXME: platform without ci cam
 	ci = cDvbCi::getInstance();
-
+#endif
 	//dvbsub
 	dvbsub_init();
 	

--- neutrino-hd2-exp/src/zapit/src/pzapit.cpp	2012-11-02 15:18:20.488812206 +0100
+++ neutrino-hd2-exp/src/zapit/src/pzapit.cpp	2012-11-02 15:18:08.156751073 +0100
@@ -273,21 +273,31 @@
 			}
 			continue;
 		}
-                else if (!strncmp(argv[i], "--pal", 5))
-                {
-                        set_pal = true;
-                        continue;
-                }
-        
-                else if (!strncmp(argv[i], "--1080", 6))
-                {
-                        set_hd = VIDEO_STD_1080I50;
-                        continue;
-                }
-                else if (!strncmp(argv[i], "--720", 5))
-                {
-                        set_hd = VIDEO_STD_720P50;
-                        continue;
+		else if (!strncmp(argv[i], "--pal", 4))
+		{
+			set_pal = true;
+			continue;
+		}
+
+		else if (!strncmp(argv[i], "--1080", 6))
+		{
+			set_hd = 8;
+			continue;
+		}
+		else if (!strncmp(argv[i], "--1083", 6))
+		{
+			set_hd = 9;
+			continue;
+		}
+		else if (!strncmp(argv[i], "--1082", 6))
+		{
+			set_hd = 10;
+			continue;
+		}
+		else if (!strncmp(argv[i], "--720", 5))
+		{
+			set_hd = 7;
+			continue;
 		}
 		else if (!strncmp(argv[i], "-unmute", 7))
 		{


--- neutrino-hd2-exp/lib/libcoolstream/video_cs.h	2012-11-02 15:23:34.230367978 +0100
+++ neutrino-hd2-exp/lib/libcoolstream/video_cs.h	2012-11-02 15:23:05.550225757 +0100
@@ -70,6 +70,21 @@
 1080p30 
 PC
 */
+#if defined (PLATFORM_SPARK7162)
+enum {
+	VIDEO_STD_PAL,
+	VIDEO_STD_576P50,
+	VIDEO_STD_576I50,
+	VIDEO_STD_720P60,
+	VIDEO_STD_1080I50,
+	VIDEO_STD_1080I60,
+	VIDEO_STD_1080P24,
+	VIDEO_STD_1080P25,
+	VIDEO_STD_1080P30,
+	VIDEO_STD_1080P50,
+	VIDEO_STD_PC
+};
+#else
 enum {
 	VIDEO_STD_PAL,
 	VIDEO_STD_1080I50,
@@ -84,6 +99,7 @@
 	VIDEO_STD_1080P50,
 	VIDEO_STD_PC
 };
+#endif
 #else
 // giga
 /*


--- neutrino-hd2-exp/lib/libcoolstream/video_cs.cpp	2012-11-02 15:22:02.981915499 +0100
+++ neutrino-hd2-exp/lib/libcoolstream/video_cs.cpp	2012-11-02 15:21:49.125846789 +0100
@@ -341,7 +341,7 @@
 /*
 pal 
 1080i50 
-720p50 
+720p50 "on Spark7162(Triplex) we must del them otherwise it won't boot!"
 576p50 
 576i50 
 1080i60 
@@ -352,6 +352,21 @@
 1080p50
 PC
 */
+#if defined (PLATFORM_SPARK7162)
+	const char *aVideoSystems[][2] = {
+		{"VIDEO_STD_PAL", "pal"},
+		{"VIDEO_STD_576P", "576p50"},
+		{"VIDEO_STD_576I", "576i50"},
+		{"VIDEO_STD_720P60", "720p60"},
+		{"VIDEO_STD_1080I50", "1080i50"},
+		{"VIDEO_STD_1080I60", "1080i60"},
+		{"VIDEO_STD_1080P24", "1080p24"},
+		{"VIDEO_STD_1080P25", "1080p25"},
+		{"VIDEO_STD_1080P30", "1080p30"},
+		{"VIDEO_STD_1080P50", "1080p50"},
+		{"VIDEO_STD_PC", "PC"},
+	};
+#else
 	const char *aVideoSystems[][2] = {
 		{"VIDEO_STD_PAL", "pal"},
 		{"VIDEO_STD_1080I50", "1080i50"},
@@ -366,6 +381,7 @@
 		{"VIDEO_STD_1080P50", "1080p50"},
 		{"VIDEO_STD_PC", "PC"},
 	};
+#endif
 #else
 // giga
 /*

// needed for crypt channels!!!
--- neutrino-hd2-exp/lib/libcoolstream/dmx_cs.cpp	2012-11-02 01:07:46.913817024 +0100
+++ neutrino-hd2-exp/lib/libcoolstream/dmx_cs.cpp	2012-11-02 00:57:52.310868565 +0100
@@ -92,10 +92,10 @@
 	dprintf(DEBUG_INFO, "%s last_source(%d) source(%d) last_index(%d) index(%d)\n", __FUNCTION__, last_source, feindex, last_index, demux_num);
 	
 	// close device
-	//if (demux_fd > -1) 
-	//{
-	//	close(demux_fd);
-	//}
+	if (demux_fd > -1) 
+	{
+		close(demux_fd);
+	}
 	
 	char devname[256];
 
