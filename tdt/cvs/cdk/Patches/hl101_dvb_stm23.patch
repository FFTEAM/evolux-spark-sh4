diff -rcN linux-sh4-2.6.23.17_stm23_0119_orig/drivers/media/dvb/dvb-core/dvb_frontend.c linux-sh4/drivers/media/dvb/dvb-core/dvb_frontend.c
*** linux-sh4-2.6.23.17_stm23_0119_orig/drivers/media/dvb/dvb-core/dvb_frontend.c	Thu Feb 25 02:05:55 2010
--- linux-sh4/drivers/media/dvb/dvb-core/dvb_frontend.c	Thu Feb 25 01:06:32 2010
***************
*** 140,145 ****
--- 140,146 ----
  	unsigned int check_wrapped;
  
  	enum dvbfe_search	algo_status;
+ 	enum dvbfe_delsys	delsys;
  };
  
  static void dvb_frontend_wakeup(struct dvb_frontend *fe);
***************
*** 230,236 ****
  		*old_fec = FEC_AUTO;
  		break;
  	default:
! 		printk("%s: Unsupported FEC\n", __func__);
  		return -EINVAL;
  	}
  
--- 231,237 ----
  		*old_fec = FEC_AUTO;
  		break;
  	default:
! 		printk("%s: Unsupported FEC %x\n", __func__, new_fec);
  		return -EINVAL;
  	}
  
***************
*** 271,277 ****
  		*new_fec = DVBFE_FEC_AUTO;
  		break;
  	default:
! 		printk("%s: Unsupported FEC\n", __func__);
  		return -EINVAL;
  	}
  
--- 272,278 ----
  		*new_fec = DVBFE_FEC_AUTO;
  		break;
  	default:
! 		printk("%s: Unsupported FEC %x\n", __func__, old_fec);
  		return -EINVAL;
  	}
  
***************
*** 309,315 ****
  		*old_mod = VSB_16;
  		break;
  	default:
! 		printk("%s: Unsupported Modulation\n", __func__);
  		return -EINVAL;
  	}
  
--- 310,316 ----
  		*old_mod = VSB_16;
  		break;
  	default:
! 		printk("%s: Unsupported Modulation %x\n", __func__, new_mod);
  		return -EINVAL;
  	}
  
***************
*** 347,360 ****
  		*new_mod = DVBFE_MOD_VSB16;
  		break;
  	default:
! 		printk("%s: Unsupported Modulation\n", __func__);
  		return -EINVAL;
  	}
  
  	return 0;
  }
  
! int newapi_to_olddrv(struct dvbfe_params *params,
  		     struct dvb_frontend_parameters *p,
  		     enum dvbfe_delsys delsys)
  {
--- 348,361 ----
  		*new_mod = DVBFE_MOD_VSB16;
  		break;
  	default:
! 		printk("%s: Unsupported Modulation %x\n", __func__, old_mod);
  		return -EINVAL;
  	}
  
  	return 0;
  }
  
! int newapi_to_oldapi(struct dvbfe_params *params,
  		     struct dvb_frontend_parameters *p,
  		     enum dvbfe_delsys delsys)
  {
***************
*** 396,402 ****
  			ofdm->bandwidth		= BANDWIDTH_AUTO;
  			break;
  		default:
! 			dprintk("%s: Unsupported bandwidth\n", __func__);
  			return -EINVAL;
  		}
  		newfec_to_oldfec(dvbt->code_rate_HP, &ofdm->code_rate_HP);
--- 397,403 ----
  			ofdm->bandwidth		= BANDWIDTH_AUTO;
  			break;
  		default:
! 			dprintk("%s: Unsupported bandwidth %x\n", __func__, dvbt->bandwidth);
  			return -EINVAL;
  		}
  		newfec_to_oldfec(dvbt->code_rate_HP, &ofdm->code_rate_HP);
***************
*** 413,419 ****
  			ofdm->transmission_mode = TRANSMISSION_MODE_AUTO;
  			break;
  		default:
! 			dprintk("%s: Unsupported transmission mode\n", __func__);
  			return -EINVAL;
  		}
  		switch (dvbt->guard_interval) {
--- 414,420 ----
  			ofdm->transmission_mode = TRANSMISSION_MODE_AUTO;
  			break;
  		default:
! 			dprintk("%s: Unsupported transmission mode %x\n", __func__, dvbt->transmission_mode);
  			return -EINVAL;
  		}
  		switch (dvbt->guard_interval) {
***************
*** 454,459 ****
--- 455,461 ----
  			}
  			break;
  		}
+ 		break;
  	case DVBFE_DELSYS_ATSC:
  		newmod_to_oldmod(atsc->modulation, &vsb->modulation);
  		break;
***************
*** 463,476 ****
  		printk("%s: SORRY ! Backward compatibility unavailable for these delivery systems !!\n", __func__);
  		break;
  	default:
! 		dprintk("%s: Unsupported delivery system\n", __func__);
  		return -EINVAL;
  		break;
  	}
  	return 0;
  }
  
! int olddrv_to_newapi(struct dvb_frontend *fe,
  		     struct dvbfe_params *params,
  		     struct dvb_frontend_parameters *p,
  		     enum fe_type fe_type)
--- 465,478 ----
  		printk("%s: SORRY ! Backward compatibility unavailable for these delivery systems !!\n", __func__);
  		break;
  	default:
! 		dprintk("%s: Unsupported delivery system %x\n", __func__, delsys);
  		return -EINVAL;
  		break;
  	}
  	return 0;
  }
  
! int oldapi_to_newapi(struct dvb_frontend *fe,
  		     struct dvbfe_params *params,
  		     struct dvb_frontend_parameters *p,
  		     enum fe_type fe_type)
***************
*** 566,575 ****
  		}
  		break;
  	case FE_ATSC:
! 		newmod_to_oldmod(atsc->modulation, &vsb->modulation);
  		break;
  	default:
! 		dprintk("%s: Unsupported delivery system\n", __func__);
  		return -EINVAL;
  		break;
  	}
--- 568,577 ----
  		}
  		break;
  	case FE_ATSC:
! 		oldmod_to_newmod(vsb->modulation, &atsc->modulation);
  		break;
  	default:
! 		dprintk("%s: Unsupported delivery system %x\n", __func__, fe_type);
  		return -EINVAL;
  		break;
  	}
***************
*** 597,606 ****
  
  	e = &events->events[events->eventw];
  
! 	if (fe->legacy)
  		memcpy(&e->parameters, &fepriv->parameters, sizeof (struct dvb_frontend_parameters));
! 	else
  		memcpy(&e->fe_params, &fepriv->fe_params, sizeof (struct dvbfe_params));
  
  	if (fe->legacy) {
  		/* Legacy	*/
--- 599,611 ----
  
  	e = &events->events[events->eventw];
  
! 	if (fe->legacy) {
  		memcpy(&e->parameters, &fepriv->parameters, sizeof (struct dvb_frontend_parameters));
! 		e->status = status;
! 	} else {
  		memcpy(&e->fe_params, &fepriv->fe_params, sizeof (struct dvbfe_params));
+ 		e->fe_events.status = status;
+ 	}
  
  	if (fe->legacy) {
  		/* Legacy	*/
***************
*** 612,618 ****
--- 617,625 ----
  			if (fe->ops.get_params)
  				fe->ops.get_params(fe, &e->fe_params);
  	}
+ 
  	events->eventw = wp;
+ 
  	up (&events->sem);
  	e->status = status;
  	wake_up_interruptible (&events->wait_queue);
***************
*** 627,633 ****
  	    (fepriv->fe_params.frequency > fepriv->fe_info.frequency_max))
  		return -EINVAL;
  
! 	switch (fepriv->fe_params.delivery) {
  	case DVBFE_DELSYS_DVBS:
  		if (!(fepriv->fe_params.delsys.dvbs.modulation &
  		      fepriv->fe_info.delsys.dvbs.modulation))
--- 634,640 ----
  	    (fepriv->fe_params.frequency > fepriv->fe_info.frequency_max))
  		return -EINVAL;
  
! 	switch (fepriv->delsys) {
  	case DVBFE_DELSYS_DVBS:
  		if (!(fepriv->fe_params.delsys.dvbs.modulation &
  		      fepriv->fe_info.delsys.dvbs.modulation))
***************
*** 738,743 ****
--- 745,752 ----
  	if (fe->ops.init)
  		fe->ops.init(fe);
  	if (fe->ops.tuner_ops.init) {
+ 		if (fe->ops.i2c_gate_ctrl)
+ 			fe->ops.i2c_gate_ctrl(fe, 1);
  		fe->ops.tuner_ops.init(fe);
  		if (fe->ops.i2c_gate_ctrl)
  			fe->ops.i2c_gate_ctrl(fe, 0);
***************
*** 1119,1124 ****
--- 1128,1135 ----
  	struct dvb_frontend_private *fepriv = fe->frontend_priv;
  	unsigned long timeout;
  	fe_status_t s;
+ 	u32 status;
+ 
  	enum dvbfe_algo algo;
  
  	/* Legacy datatype	*/
***************
*** 1156,1161 ****
--- 1167,1174 ----
  			break;
  
  		if (fepriv->reinitialise) {
+          printk("dvb_frontend_init\n");
+ 
  			dvb_frontend_init(fe);
  			if (fepriv->tone != -1) {
  				fe->ops.set_tone(fe, fepriv->tone);
***************
*** 1183,1189 ****
  					fe->ops.tune(fe, params, fepriv->tune_mode_flags, &fepriv->delay, &s);
  					dprintk("%s: TUNE callback exists at 0x%p\n", __func__, fe->ops.tune);
  				}
- 
  				if (s != fepriv->status) {
  					dprintk("%s: state changed, adding current state\n", __func__);
  					dvb_frontend_add_event(fe, s);
--- 1196,1201 ----
***************
*** 1209,1243 ****
  				 * 2. User asked us to retune again for some reason, possibly
  				 *    requesting a search with a new set of parameters
  				 */
! 				if ((!(fepriv->algo_status & DVBFE_ALGO_SEARCH_SUCCESS)) ||
! 				      (fepriv->algo_status & DVBFE_ALGO_SEARCH_AGAIN)) {
! 
  					if (fe->ops.search) {
  						fepriv->algo_status = fe->ops.search(fe, fe_params);
  						dprintk("%s: SEARCH callback exists at 0x%p\n", __func__, fe->ops.search);
  						/* We did do a search as was requested, the flags are
  						 * now unset as well and has the flags wrt to search.
  						 */
  					}
  				}
  				/* Track the carrier if the search was successful	*/
  				if (fepriv->algo_status == DVBFE_ALGO_SEARCH_SUCCESS) {
! 					dprintk("%s: status = DVBFE_ALGO_SEARCH_SUCCESS\n", __func__);
  					if (fe->ops.track) {
  						dprintk("%s: TRACK callback exists at 0x%p\n", __func__, fe->ops.track);
! 						fe->ops.track(fe, fe_params);
! 						dvb_frontend_add_event(fe, s); /* update event list	*/
! 						fepriv->status = s;
  					}
  				}
  				break;
  			default:
  				dprintk("%s: UNDEFINED ALGO !\n", __func__);
  				break;
  			}
  
  		} else {
- 
  			dvb_frontend_swzigzag(fe);
  		}
  	}
--- 1221,1273 ----
  				 * 2. User asked us to retune again for some reason, possibly
  				 *    requesting a search with a new set of parameters
  				 */
! 				if (fepriv->algo_status & DVBFE_ALGO_SEARCH_AGAIN) {
  					if (fe->ops.search) {
  						fepriv->algo_status = fe->ops.search(fe, fe_params);
  						dprintk("%s: SEARCH callback exists at 0x%p\n", __func__, fe->ops.search);
  						/* We did do a search as was requested, the flags are
  						 * now unset as well and has the flags wrt to search.
  						 */
+ 					} else {
+ 						fepriv->algo_status &= ~DVBFE_ALGO_SEARCH_AGAIN;
  					}
  				}
  				/* Track the carrier if the search was successful	*/
  				if (fepriv->algo_status == DVBFE_ALGO_SEARCH_SUCCESS) {
! 					dprintk("%s: STATUS = DVBFE_ALGO_SEARCH_SUCCESS\n", __func__);
  					if (fe->ops.track) {
  						dprintk("%s: TRACK callback exists at 0x%p\n", __func__, fe->ops.track);
! #if 0
! 						if (fe->ops.tuner_ops.get_status)
! 							fe->ops.tuner_ops.get_status(fe, &status);
! 						if (!status)
! 							printk("%s: Tuner LOCK LOST!\n", __func__);
! #endif
! 						fe->ops.track(fe, fe_params, &fepriv->delay);
! 					}
! 				} else {
! 					fepriv->algo_status |= DVBFE_ALGO_SEARCH_AGAIN;
! 					fepriv->delay = HZ / 2;
! 				}
! 				fe->ops.read_status(fe, &s);
! 				if (s != fepriv->status) {
! 					dvb_frontend_add_event(fe, s); /* update event list */
! 					fepriv->status = s;
! 					if (!(s & FE_HAS_LOCK)) {
! 						fepriv->delay = HZ / 10;
! 						fepriv->algo_status |= DVBFE_ALGO_SEARCH_AGAIN;
! 					} else {
! 						fepriv->delay = 60 * HZ;
  					}
  				}
  				break;
  			default:
+ 				down(&fepriv->sem);
  				dprintk("%s: UNDEFINED ALGO !\n", __func__);
  				break;
  			}
  
  		} else {
  			dvb_frontend_swzigzag(fe);
  		}
  	}
***************
*** 1276,1281 ****
--- 1306,1312 ----
  		return;
  
  	kthread_stop(fepriv->thread);
+ 
  	init_MUTEX (&fepriv->sem);
  	fepriv->state = FESTATE_IDLE;
  
***************
*** 1365,1370 ****
--- 1396,1460 ----
  	return 0;
  }
  
+ static void dvb_frontend_get_frequeny_limits(struct dvb_frontend *fe,
+ 					u32 *freq_min, u32 *freq_max)
+ {
+ 	*freq_min = max(fe->ops.info.frequency_min, fe->ops.tuner_ops.info.frequency_min);
+ 
+ 	if (fe->ops.info.frequency_max == 0)
+ 		*freq_max = fe->ops.tuner_ops.info.frequency_max;
+ 	else if (fe->ops.tuner_ops.info.frequency_max == 0)
+ 		*freq_max = fe->ops.info.frequency_max;
+ 	else
+ 		*freq_max = min(fe->ops.info.frequency_max, fe->ops.tuner_ops.info.frequency_max);
+ 
+ 	if (*freq_min == 0 || *freq_max == 0)
+ 		printk(KERN_WARNING "DVB: frontend %u frequency limits undefined - fix the driver\n",
+ 		       fe->dvb->num);
+ }
+ 
+ static int dvb_frontend_check_parameters(struct dvb_frontend *fe,
+ 				struct dvb_frontend_parameters *parms)
+ {
+ 	u32 freq_min;
+ 	u32 freq_max;
+ 
+ 	/* range check: frequency */
+ 	dvb_frontend_get_frequeny_limits(fe, &freq_min, &freq_max);
+ 	if ((freq_min && parms->frequency < freq_min) ||
+ 	    (freq_max && parms->frequency > freq_max)) {
+ 		printk(KERN_WARNING "DVB: frontend %u frequency %u out of range (%u..%u)\n",
+ 		       fe->dvb->num, parms->frequency, freq_min, freq_max);
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* range check: symbol rate */
+ 	if (fe->ops.info.type == FE_QPSK) {
+ 		if ((fe->ops.info.symbol_rate_min &&
+ 		     parms->u.qpsk.symbol_rate < fe->ops.info.symbol_rate_min) ||
+ 		    (fe->ops.info.symbol_rate_max &&
+ 		     parms->u.qpsk.symbol_rate > fe->ops.info.symbol_rate_max)) {
+ 			printk(KERN_WARNING "DVB: frontend %u symbol rate %u out of range (%u..%u)\n",
+ 			       fe->dvb->num, parms->u.qpsk.symbol_rate,
+ 			       fe->ops.info.symbol_rate_min, fe->ops.info.symbol_rate_max);
+ 			return -EINVAL;
+ 		}
+ 
+ 	} else if (fe->ops.info.type == FE_QAM) {
+ 		if ((fe->ops.info.symbol_rate_min &&
+ 		     parms->u.qam.symbol_rate < fe->ops.info.symbol_rate_min) ||
+ 		    (fe->ops.info.symbol_rate_max &&
+ 		     parms->u.qam.symbol_rate > fe->ops.info.symbol_rate_max)) {
+ 			printk(KERN_WARNING "DVB: frontend %u symbol rate %u out of range (%u..%u)\n",
+ 			       fe->dvb->num, parms->u.qam.symbol_rate,
+ 			       fe->ops.info.symbol_rate_min, fe->ops.info.symbol_rate_max);
+ 			return -EINVAL;
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
  static int dvb_frontend_ioctl(struct inode *inode, struct file *file,
  			unsigned int cmd, void *parg)
  {
***************
*** 1391,1396 ****
--- 1481,1487 ----
  	case FE_GET_INFO: {
  		struct dvb_frontend_info* info = parg;
  		memcpy(info, &fe->ops.info, sizeof(struct dvb_frontend_info));
+ 		dvb_frontend_get_frequeny_limits(fe, &info->frequency_min, &info->frequency_max);
  
  		/* Force the CAN_INVERSION_AUTO bit on. If the frontend doesn't
  		 * do it, it is done for it. */
***************
*** 1402,1407 ****
--- 1493,1499 ----
  	case FE_READ_STATUS: {
  		fe_status_t* status = parg;
  
+ 	printk ("FE_READ_STATUS\n");
  		/* if retune was requested but hasn't occured yet, prevent
  		 * that user get signal state from previous tuning */
  		if(fepriv->state == FESTATE_RETUNE) {
***************
*** 1415,1441 ****
--- 1507,1538 ----
  		break;
  	}
  	case FE_READ_BER:
+ 	printk ("FE_READ_BER\n");
  		if (fe->ops.read_ber)
  			err = fe->ops.read_ber(fe, (__u32*) parg);
  		break;
  
  	case FE_READ_SIGNAL_STRENGTH:
+ 	printk ("FE_READ_SIGNAL_STRENGTH\n");
  		if (fe->ops.read_signal_strength)
  			err = fe->ops.read_signal_strength(fe, (__u16*) parg);
  		break;
  
  	case FE_READ_SNR:
+ 	printk ("FE_READ_SNR\n");
  		if (fe->ops.read_snr)
  			err = fe->ops.read_snr(fe, (__u16*) parg);
  		break;
  
  	case FE_READ_UNCORRECTED_BLOCKS:
+ 	printk ("FE_READ_UNCORRECTED_BLOCKS\n");
  		if (fe->ops.read_ucblocks)
  			err = fe->ops.read_ucblocks(fe, (__u32*) parg);
  		break;
  
  
  	case FE_DISEQC_RESET_OVERLOAD:
+ 	printk ("FE_DISEQC_RESET_OVERLOAD\n");
  		if (fe->ops.diseqc_reset_overload) {
  			err = fe->ops.diseqc_reset_overload(fe);
  			fepriv->state = FESTATE_DISEQC;
***************
*** 1444,1449 ****
--- 1541,1547 ----
  		break;
  
  	case FE_DISEQC_SEND_MASTER_CMD:
+ 	printk ("FE_DISEQC_SEND_MASTER_CMD\n");
  		if (fe->ops.diseqc_send_master_cmd) {
  			err = fe->ops.diseqc_send_master_cmd(fe, (struct dvb_diseqc_master_cmd*) parg);
  			fepriv->state = FESTATE_DISEQC;
***************
*** 1452,1457 ****
--- 1550,1556 ----
  		break;
  
  	case FE_DISEQC_SEND_BURST:
+ 	printk ("FE_DISEQC_SEND_BURST\n");
  		if (fe->ops.diseqc_send_burst) {
  			err = fe->ops.diseqc_send_burst(fe, (fe_sec_mini_cmd_t) parg);
  			fepriv->state = FESTATE_DISEQC;
***************
*** 1460,1465 ****
--- 1559,1565 ----
  		break;
  
  	case FE_SET_TONE:
+ 	printk ("FE_SET_TONE\n");
  		if (fe->ops.set_tone) {
  			err = fe->ops.set_tone(fe, (fe_sec_tone_mode_t) parg);
  			fepriv->tone = (fe_sec_tone_mode_t) parg;
***************
*** 1469,1474 ****
--- 1569,1575 ----
  		break;
  
  	case FE_SET_VOLTAGE:
+ 	printk ("FE_SET_VOLTAGE\n");
  		if (fe->ops.set_voltage) {
  			err = fe->ops.set_voltage(fe, (fe_sec_voltage_t) parg);
  			fepriv->voltage = (fe_sec_voltage_t) parg;
***************
*** 1478,1483 ****
--- 1579,1585 ----
  		break;
  
  	case FE_DISHNETWORK_SEND_LEGACY_CMD:
+ 	printk ("FE_DISHNETWORK_SEND_LEGACY_CMD\n");
  		if (fe->ops.dishnetwork_send_legacy_command) {
  			err = fe->ops.dishnetwork_send_legacy_command(fe, (unsigned long) parg);
  			fepriv->state = FESTATE_DISEQC;
***************
*** 1499,1511 ****
  			 * initialization, so parg is 8 bits and does not
  			 * include the initialization or start bit
  			 */
! 			unsigned long cmd = ((unsigned long) parg) << 1;
  			struct timeval nexttime;
  			struct timeval tv[10];
  			int i;
  			u8 last = 1;
  			if (dvb_frontend_debug)
! 				printk("%s switch command: 0x%04lx\n", __FUNCTION__, cmd);
  			do_gettimeofday(&nexttime);
  			if (dvb_frontend_debug)
  				memcpy(&tv[0], &nexttime, sizeof(struct timeval));
--- 1601,1613 ----
  			 * initialization, so parg is 8 bits and does not
  			 * include the initialization or start bit
  			 */
! 			unsigned long swcmd = ((unsigned long) parg) << 1;
  			struct timeval nexttime;
  			struct timeval tv[10];
  			int i;
  			u8 last = 1;
  			if (dvb_frontend_debug)
! 				printk("%s switch command: 0x%04lx\n", __func__, swcmd);
  			do_gettimeofday(&nexttime);
  			if (dvb_frontend_debug)
  				memcpy(&tv[0], &nexttime, sizeof(struct timeval));
***************
*** 1518,1535 ****
  			for (i = 0; i < 9; i++) {
  				if (dvb_frontend_debug)
  					do_gettimeofday(&tv[i + 1]);
! 				if ((cmd & 0x01) != last) {
  					/* set voltage to (last ? 13V : 18V) */
  					fe->ops.set_voltage(fe, (last) ? SEC_VOLTAGE_13 : SEC_VOLTAGE_18);
  					last = (last) ? 0 : 1;
  				}
! 				cmd = cmd >> 1;
  				if (i != 8)
  					dvb_frontend_sleep_until(&nexttime, 8000);
  			}
  			if (dvb_frontend_debug) {
  				printk("%s(%d): switch delay (should be 32k followed by all 8k\n",
! 					__FUNCTION__, fe->dvb->num);
  				for (i = 1; i < 10; i++)
  					printk("%d: %d\n", i, timeval_usec_diff(tv[i-1] , tv[i]));
  			}
--- 1620,1637 ----
  			for (i = 0; i < 9; i++) {
  				if (dvb_frontend_debug)
  					do_gettimeofday(&tv[i + 1]);
! 				if ((swcmd & 0x01) != last) {
  					/* set voltage to (last ? 13V : 18V) */
  					fe->ops.set_voltage(fe, (last) ? SEC_VOLTAGE_13 : SEC_VOLTAGE_18);
  					last = (last) ? 0 : 1;
  				}
! 				swcmd = swcmd >> 1;
  				if (i != 8)
  					dvb_frontend_sleep_until(&nexttime, 8000);
  			}
  			if (dvb_frontend_debug) {
  				printk("%s(%d): switch delay (should be 32k followed by all 8k\n",
! 					__func__, fe->dvb->num);
  				for (i = 1; i < 10; i++)
  					printk("%d: %d\n", i, timeval_usec_diff(tv[i-1] , tv[i]));
  			}
***************
*** 1540,1562 ****
  		break;
  
  	case FE_DISEQC_RECV_SLAVE_REPLY:
  		if (fe->ops.diseqc_recv_slave_reply)
  			err = fe->ops.diseqc_recv_slave_reply(fe, (struct dvb_diseqc_slave_reply*) parg);
  		break;
  
  	case FE_ENABLE_HIGH_LNB_VOLTAGE:
  		if (fe->ops.enable_high_lnb_voltage)
  			err = fe->ops.enable_high_lnb_voltage(fe, (long) parg);
  		break;
  
  	case FE_SET_FRONTEND: {
  		struct dvb_frontend_tune_settings fetunesettings;
- 		fe->legacy = 1;
  
  		memcpy(&fepriv->parameters, parg, sizeof (struct dvb_frontend_parameters));
  		memset(&fetunesettings, 0, sizeof(struct dvb_frontend_tune_settings));
  		memcpy(&fetunesettings.parameters, parg, sizeof (struct dvb_frontend_parameters));
  
  		/* force auto frequency inversion if requested */
  		if (dvb_force_auto_inversion) {
  			fepriv->parameters.inversion = INVERSION_AUTO;
--- 1642,1678 ----
  		break;
  
  	case FE_DISEQC_RECV_SLAVE_REPLY:
+ 	   printk ("FE_DISEQC_RECV_SLAVE_REPLY\n");
+ 
  		if (fe->ops.diseqc_recv_slave_reply)
  			err = fe->ops.diseqc_recv_slave_reply(fe, (struct dvb_diseqc_slave_reply*) parg);
  		break;
  
  	case FE_ENABLE_HIGH_LNB_VOLTAGE:
+ 	   printk ("FE_ENABLE_HIGH_LNB_VOLTAGE\n");
+ 
  		if (fe->ops.enable_high_lnb_voltage)
  			err = fe->ops.enable_high_lnb_voltage(fe, (long) parg);
  		break;
  
  	case FE_SET_FRONTEND: {
  		struct dvb_frontend_tune_settings fetunesettings;
  
+ 		if (dvb_frontend_check_parameters(fe, parg) < 0) {
+ 			err = -EINVAL;
+ 			break;
+ 		}
+ 
+    	printk ("FE_SET_FRONTEND\n");
+ 
+ 		fe->legacy = 1;
  		memcpy(&fepriv->parameters, parg, sizeof (struct dvb_frontend_parameters));
  		memset(&fetunesettings, 0, sizeof(struct dvb_frontend_tune_settings));
  		memcpy(&fetunesettings.parameters, parg, sizeof (struct dvb_frontend_parameters));
  
+ 		/* Request the search algorithm to search */
+ 		fepriv->algo_status |= DVBFE_ALGO_SEARCH_AGAIN;
+ 
  		/* force auto frequency inversion if requested */
  		if (dvb_force_auto_inversion) {
  			fepriv->parameters.inversion = INVERSION_AUTO;
***************
*** 1605,1610 ****
--- 1721,1747 ----
  		if (dvb_override_tune_delay > 0)
  			fepriv->min_delay = (dvb_override_tune_delay * HZ) / 1000;
  
+ 		if (oldapi_to_newapi(fe, &fepriv->fe_params, &fepriv->parameters, fe->ops.info.type) == -EINVAL)
+ 			printk("%s: ERROR !!! Converting Old parameters --> New parameters\n", __func__);
+ 
+ 		/* set delivery system to the default old-API one */
+ 		if (fe->ops.set_delsys) {
+ 			switch(fe->ops.info.type) {
+ 			case FE_QPSK:
+ 				fe->ops.set_delsys(fe, DVBFE_DELSYS_DVBS);
+ 				break;
+ 			case FE_QAM:
+ 				fe->ops.set_delsys(fe, DVBFE_DELSYS_DVBC);
+ 				break;
+ 			case FE_OFDM:
+ 				fe->ops.set_delsys(fe, DVBFE_DELSYS_DVBT);
+ 				break;
+ 			case FE_ATSC:
+ 				fe->ops.set_delsys(fe, DVBFE_DELSYS_ATSC);
+ 				break;
+ 			}
+ 		}
+ 
  		fepriv->state = FESTATE_RETUNE;
  		dvb_frontend_wakeup(fe);
  		dvb_frontend_add_event(fe, 0);
***************
*** 1622,1627 ****
--- 1759,1771 ----
  		if (fe->ops.get_frontend) {
  			memcpy (parg, &fepriv->parameters, sizeof (struct dvb_frontend_parameters));
  			err = fe->ops.get_frontend(fe, (struct dvb_frontend_parameters*) parg);
+ 		} else if (fe->ops.get_params) {
+ 			err = fe->ops.get_params(fe, &fepriv->fe_params);
+ 			if (!err) {
+ 				if (newapi_to_oldapi(&fepriv->fe_params, &fepriv->parameters, fepriv->delsys)  == -EINVAL)
+ 					printk("%s: ERROR !!! Converting New parameters --> Old parameters\n", __func__);
+ 				memcpy(parg, &fepriv->parameters, sizeof (struct dvb_frontend_parameters));
+ 			}
  		}
  		break;
  
***************
*** 1632,1646 ****
  
  	case DVBFE_SET_PARAMS: {
  		struct dvb_frontend_tune_settings fetunesettings;
- 
  		fe->legacy = 0;
  		memcpy(&fepriv->fe_params, parg, sizeof (struct dvbfe_params));
  		memset(&fetunesettings, 0, sizeof (struct dvb_frontend_tune_settings));
  		memcpy(&fetunesettings.fe_params, parg, sizeof (struct dvbfe_params));
  
! 		if (newapi_to_olddrv(&fepriv->fe_params, &fepriv->parameters, fepriv->fe_info.delivery)  == -EINVAL)
! 			printk("%s: ERROR !!! Converting New parameters --> Old parameters\n", __func__);
  
  		/* Request the search algorithm to search	*/
  		fepriv->algo_status |= DVBFE_ALGO_SEARCH_AGAIN;
  
--- 1776,1796 ----
  
  	case DVBFE_SET_PARAMS: {
  		struct dvb_frontend_tune_settings fetunesettings;
  		fe->legacy = 0;
+ 		enum dvbfe_delsys delsys = fepriv->delsys;
+ 
  		memcpy(&fepriv->fe_params, parg, sizeof (struct dvbfe_params));
  		memset(&fetunesettings, 0, sizeof (struct dvb_frontend_tune_settings));
  		memcpy(&fetunesettings.fe_params, parg, sizeof (struct dvbfe_params));
  
! 		if ((delsys & DVBFE_DELSYS_DVBS) ||
! 		    (delsys & DVBFE_DELSYS_DVBC) ||
! 		    (delsys & DVBFE_DELSYS_DVBT) ||
! 		    (delsys & DVBFE_DELSYS_ATSC)) {
  
+ 			if (newapi_to_oldapi(&fepriv->fe_params, &fepriv->parameters, fepriv->delsys)  == -EINVAL)
+ 				printk("%s: ERROR !!! Converting New parameters --> Old parameters\n", __func__);
+ 		}
  		/* Request the search algorithm to search	*/
  		fepriv->algo_status |= DVBFE_ALGO_SEARCH_AGAIN;
  
***************
*** 1672,1685 ****
  			fepriv->step_size = fetunesettings.step_size;
  		} else {
  			/* default values */
! 			switch (fepriv->fe_info.delivery) {
  			case DVBFE_DELSYS_DVBS:
- 			case DVBFE_DELSYS_DSS:
- 			case DVBFE_DELSYS_DVBS2:
  				fepriv->min_delay = HZ / 20;
  				fepriv->step_size = fepriv->fe_params.delsys.dvbs.symbol_rate / 16000;
  				fepriv->max_drift = fepriv->fe_params.delsys.dvbs.symbol_rate / 2000;
  				break;
  			case DVBFE_DELSYS_DVBC:
  				fepriv->min_delay = HZ / 20;
  				fepriv->step_size = 0; /* no zigzag */
--- 1822,1843 ----
  			fepriv->step_size = fetunesettings.step_size;
  		} else {
  			/* default values */
! 			switch (fepriv->delsys) {
  			case DVBFE_DELSYS_DVBS:
  				fepriv->min_delay = HZ / 20;
  				fepriv->step_size = fepriv->fe_params.delsys.dvbs.symbol_rate / 16000;
  				fepriv->max_drift = fepriv->fe_params.delsys.dvbs.symbol_rate / 2000;
  				break;
+ 			case DVBFE_DELSYS_DSS:
+ 				fepriv->min_delay = HZ / 20;
+ 				fepriv->step_size = fepriv->fe_params.delsys.dss.symbol_rate / 16000;
+ 				fepriv->max_drift = fepriv->fe_params.delsys.dss.symbol_rate / 2000;
+ 				break;
+ 			case DVBFE_DELSYS_DVBS2:
+ 				fepriv->min_delay = HZ / 20;
+ 				fepriv->step_size = fepriv->fe_params.delsys.dvbs2.symbol_rate / 16000;
+ 				fepriv->max_drift = fepriv->fe_params.delsys.dvbs2.symbol_rate / 2000;
+ 				break;
  			case DVBFE_DELSYS_DVBC:
  				fepriv->min_delay = HZ / 20;
  				fepriv->step_size = 0; /* no zigzag */
***************
*** 1691,1697 ****
  				fepriv->step_size = fepriv->fe_info.frequency_step * 2;
  				fepriv->max_drift = (fepriv->fe_info.frequency_step * 2) + 1;
  				break;
- 				break;
  			case DVBFE_DELSYS_ATSC:
  				fepriv->min_delay = HZ / 20;
  				fepriv->step_size = 0;
--- 1849,1854 ----
***************
*** 1718,1735 ****
  		if (fe->ops.get_params) {
  			memcpy(parg, &fepriv->fe_params, sizeof (struct dvbfe_params));
  			err = fe->ops.get_params(fe, (struct dvbfe_params *) parg);
- 
  		} else if (fe->ops.get_frontend) {
! 			memcpy (parg, &fepriv->parameters, sizeof (struct dvb_frontend_parameters));
! 			err = fe->ops.get_frontend(fe, (struct dvb_frontend_parameters*) parg);
! 			if (olddrv_to_newapi(fe, &fepriv->fe_params, &fepriv->parameters, fe->ops.info.type) == -EINVAL)
! 				printk("%s: ERROR !!! Converting Old parameters --> New parameters\n", __func__);
  		}
  		break;
  	case DVBFE_GET_DELSYS:
  		fe->legacy = 0;
  		if (fe->ops.get_delsys) {
  			err = fe->ops.get_delsys(fe, (enum dvbfe_delsys *) parg);
  		}
  		break;
  	case DVBFE_GET_INFO:
--- 1875,1934 ----
  		if (fe->ops.get_params) {
  			memcpy(parg, &fepriv->fe_params, sizeof (struct dvbfe_params));
  			err = fe->ops.get_params(fe, (struct dvbfe_params *) parg);
  		} else if (fe->ops.get_frontend) {
! 			err = fe->ops.get_frontend(fe, &fepriv->parameters);
! 			if (!err) {
! 				if (oldapi_to_newapi(fe, &fepriv->fe_params, &fepriv->parameters, fe->ops.info.type) == -EINVAL)
! 					printk("%s: ERROR !!! Converting Old parameters --> New parameters\n", __func__);
! 				memcpy(parg, &fepriv->fe_params, sizeof (struct dvbfe_params));
! 			}
  		}
  		break;
  	case DVBFE_GET_DELSYS:
  		fe->legacy = 0;
  		if (fe->ops.get_delsys) {
  			err = fe->ops.get_delsys(fe, (enum dvbfe_delsys *) parg);
+ 		} else {
+ 			switch (fe->ops.info.type) {
+ 				case FE_QPSK:
+ 					*((enum dvbfe_delsys *) parg) = DVBFE_DELSYS_DVBS;
+ 					break;
+ 				case FE_QAM:
+ 					*((enum dvbfe_delsys *) parg) = DVBFE_DELSYS_DVBC;
+ 					break;
+ 				case FE_OFDM:
+ 					*((enum dvbfe_delsys *) parg) = DVBFE_DELSYS_DVBT;
+ 					break;
+ 				default:
+ 					up (&fepriv->sem);
+ 					return -EINVAL;
+ 			}
+ 			err = 0;
+ 		}
+ 		break;
+ 	case DVBFE_SET_DELSYS:
+ 		memcpy(&fepriv->delsys, (enum dvbfe_delsys *) parg, sizeof (enum dvbfe_delsys));
+ 		if (fe->ops.set_delsys) {
+ 			fe->ops.set_delsys(fe, fepriv->delsys);
+ 			err = 0;
+ 		} else {
+ 			err = 0;
+ 			switch (fe->ops.info.type) {
+ 				case FE_QPSK:
+ 					if (fepriv->delsys != DVBFE_DELSYS_DVBS)
+ 						err = -EINVAL;
+ 					break;
+ 				case FE_QAM:
+ 					if (fepriv->delsys != DVBFE_DELSYS_DVBC)
+ 						err = -EINVAL;
+ 					break;
+ 				case FE_OFDM:
+ 					if (fepriv->delsys != DVBFE_DELSYS_DVBT)
+ 						err = -EINVAL;
+ 					break;
+ 				default:
+ 					err = -EINVAL;
+ 			}
  		}
  		break;
  	case DVBFE_GET_INFO:
***************
*** 1739,1752 ****
  			memcpy(&fepriv->fe_info, (struct dvbfe_info *) parg, sizeof (struct dvbfe_info));
  			err = fe->ops.get_info(fe, &fepriv->fe_info);
  			memcpy((struct dvbfe_info *) parg, &fepriv->fe_info, sizeof (struct dvbfe_info));
  		}
  		break;
  	};
  	up (&fepriv->sem);
  	return err;
  }
  
- 
  static unsigned int dvb_frontend_poll(struct file *file, struct poll_table_struct *wait)
  {
  	struct dvb_device *dvbdev = file->private_data;
--- 1938,2016 ----
  			memcpy(&fepriv->fe_info, (struct dvbfe_info *) parg, sizeof (struct dvbfe_info));
  			err = fe->ops.get_info(fe, &fepriv->fe_info);
  			memcpy((struct dvbfe_info *) parg, &fepriv->fe_info, sizeof (struct dvbfe_info));
+ 		} else {
+ 			memset(&fepriv->fe_info, 0, sizeof(struct dvbfe_info));
+ 			switch (fe->ops.info.type) {
+ 				case FE_QPSK:
+ 					fepriv->delsys = DVBFE_DELSYS_DVBS;
+ 					fepriv->fe_info.delsys.dvbs.modulation = DVBFE_MOD_QPSK;
+ 					if (fe->ops.info.caps & FE_CAN_FEC_1_2)
+ 						fepriv->fe_info.delsys.dvbs.fec |= DVBFE_FEC_1_2;
+ 					if (fe->ops.info.caps & FE_CAN_FEC_2_3)
+ 						fepriv->fe_info.delsys.dvbs.fec |= DVBFE_FEC_2_3;
+ 					if (fe->ops.info.caps & FE_CAN_FEC_3_4)
+ 						fepriv->fe_info.delsys.dvbs.fec |= DVBFE_FEC_3_4;
+ 					if (fe->ops.info.caps & FE_CAN_FEC_4_5)
+ 						fepriv->fe_info.delsys.dvbs.fec |= DVBFE_FEC_4_5;
+ 					if (fe->ops.info.caps & FE_CAN_FEC_5_6)
+ 						fepriv->fe_info.delsys.dvbs.fec |= DVBFE_FEC_5_6;
+ 					if (fe->ops.info.caps & FE_CAN_FEC_6_7)
+ 						fepriv->fe_info.delsys.dvbs.fec |= DVBFE_FEC_6_7;
+ 					if (fe->ops.info.caps & FE_CAN_FEC_7_8)
+ 						fepriv->fe_info.delsys.dvbs.fec |= DVBFE_FEC_7_8;
+ 					if (fe->ops.info.caps & FE_CAN_FEC_8_9)
+ 						fepriv->fe_info.delsys.dvbs.fec |= DVBFE_FEC_8_9;
+ 					if (fe->ops.info.caps & FE_CAN_FEC_AUTO)
+ 						fepriv->fe_info.delsys.dvbs.fec |= DVBFE_FEC_AUTO;
+ 					break;
+ 				case FE_QAM:
+ 					fepriv->delsys = DVBFE_DELSYS_DVBC;
+ 					if (fe->ops.info.caps & FE_CAN_QAM_16)
+ 						fepriv->fe_info.delsys.dvbc.modulation |= DVBFE_MOD_QAM16;
+ 					if (fe->ops.info.caps & FE_CAN_QAM_32)
+ 						fepriv->fe_info.delsys.dvbc.modulation |= DVBFE_MOD_QAM32;
+ 					if (fe->ops.info.caps & FE_CAN_QAM_64)
+ 						fepriv->fe_info.delsys.dvbc.modulation |= DVBFE_MOD_QAM64;
+ 					if (fe->ops.info.caps & FE_CAN_QAM_128)
+ 						fepriv->fe_info.delsys.dvbc.modulation |= DVBFE_MOD_QAM128;
+ 					if (fe->ops.info.caps & FE_CAN_QAM_256)
+ 						fepriv->fe_info.delsys.dvbc.modulation |= DVBFE_MOD_QAM256;
+ 					if (fe->ops.info.caps & FE_CAN_QAM_AUTO)
+ 						fepriv->fe_info.delsys.dvbc.modulation |= DVBFE_MOD_QAMAUTO;
+ 					break;
+ 				case FE_OFDM:
+ 					fepriv->delsys = DVBFE_DELSYS_DVBT;
+ 					if (fe->ops.info.caps & FE_CAN_QPSK)
+ 						fepriv->fe_info.delsys.dvbt.modulation |= DVBFE_MOD_QPSK;
+ 					if (fe->ops.info.caps & FE_CAN_QAM_16)
+ 						fepriv->fe_info.delsys.dvbt.modulation |= DVBFE_MOD_QAM16;
+ 					if (fe->ops.info.caps & FE_CAN_QAM_64)
+ 						fepriv->fe_info.delsys.dvbt.modulation |= DVBFE_MOD_QAM64;
+ 					if (fe->ops.info.caps & FE_CAN_QAM_AUTO)
+ 						fepriv->fe_info.delsys.dvbt.modulation |= DVBFE_MOD_QAMAUTO;
+ 					break;
+ 				default:
+ 					up (&fepriv->sem);
+ 					return -EINVAL;
+ 			}
+ 			memcpy(&fepriv->fe_info.name, &fe->ops.info.name, 128);
+ 			fepriv->fe_info.frequency_min         = fe->ops.info.frequency_min;
+ 			fepriv->fe_info.frequency_max         = fe->ops.info.frequency_max;
+ 			fepriv->fe_info.frequency_step        = fe->ops.info.frequency_stepsize;
+ 			fepriv->fe_info.symbol_rate_min       = fe->ops.info.symbol_rate_min;
+ 			fepriv->fe_info.symbol_rate_max       = fe->ops.info.symbol_rate_max;
+ 			fepriv->fe_info.symbol_rate_tolerance = fe->ops.info.symbol_rate_tolerance;
+ 
+ 			memcpy((struct dvbfe_info *) parg, &fepriv->fe_info, sizeof (struct dvbfe_info));
+ 			err = 0;
  		}
  		break;
  	};
+ 
  	up (&fepriv->sem);
  	return err;
  }
  
  static unsigned int dvb_frontend_poll(struct file *file, struct poll_table_struct *wait)
  {
  	struct dvb_device *dvbdev = file->private_data;
diff -rcN linux-sh4-2.6.23.17_stm23_0119_orig/drivers/media/dvb/dvb-core/dvb_frontend.h linux-sh4/drivers/media/dvb/dvb-core/dvb_frontend.h
*** linux-sh4-2.6.23.17_stm23_0119_orig/drivers/media/dvb/dvb-core/dvb_frontend.h	Thu Feb 25 02:05:55 2010
--- linux-sh4/drivers/media/dvb/dvb-core/dvb_frontend.h	Thu Feb 25 01:06:32 2010
***************
*** 260,271 ****
  	int (*get_params)(struct dvb_frontend *fe, struct dvbfe_params *fe_params);
  	int (*get_info)(struct dvb_frontend *fe, struct dvbfe_info *fe_info);
  	int (*get_delsys)(struct dvb_frontend *fe, enum dvbfe_delsys *fe_delsys);
  
  	/* These callbacks are for devices that implement their own
  	 * tuning algorithms, rather than a simple swzigzag
  	 */
  	enum dvbfe_search (*search)(struct dvb_frontend *fe, struct dvbfe_params *fe_params);
! 	int (*track)(struct dvb_frontend *fe, struct dvbfe_params *fe_params);
  
  	struct dvb_tuner_ops tuner_ops;
  };
--- 260,272 ----
  	int (*get_params)(struct dvb_frontend *fe, struct dvbfe_params *fe_params);
  	int (*get_info)(struct dvb_frontend *fe, struct dvbfe_info *fe_info);
  	int (*get_delsys)(struct dvb_frontend *fe, enum dvbfe_delsys *fe_delsys);
+ 	int (*set_delsys)(struct dvb_frontend *fe, enum dvbfe_delsys fe_delsys);
  
  	/* These callbacks are for devices that implement their own
  	 * tuning algorithms, rather than a simple swzigzag
  	 */
  	enum dvbfe_search (*search)(struct dvb_frontend *fe, struct dvbfe_params *fe_params);
! 	int (*track)(struct dvb_frontend *fe, struct dvbfe_params *fe_params, int *delay);
  
  	struct dvb_tuner_ops tuner_ops;
  };
diff -rcN linux-sh4-2.6.23.17_stm23_0119_orig/include/linux/dvb/frontend.h linux-sh4/include/linux/dvb/frontend.h
*** linux-sh4-2.6.23.17_stm23_0119_orig/include/linux/dvb/frontend.h	Thu Feb 25 02:05:55 2010
--- linux-sh4/include/linux/dvb/frontend.h	Thu Feb 25 01:06:15 2010
***************
*** 681,686 ****
--- 681,687 ----
  	__u8				pad[128];
  };
  #define DVBFE_GET_INFO			_IOWR('o', 85, struct dvbfe_info)
+ #define DVBFE_SET_DELSYS		_IOW('o', 87, enum dvbfe_delsys)
  
  enum dvbfe_status {
  	DVBFE_HAS_SIGNAL		= (1 <<  0),	/*  something above noise floor	*/
