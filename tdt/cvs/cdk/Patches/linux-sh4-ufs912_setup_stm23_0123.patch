*** a/arch/sh/boards/st/mb618/setup.c	2011-01-02 21:06:57.000000000 +0100
--- b/setup.c	2011-01-03 01:48:35.607316546 +0100
***************
*** 21,26 ****
--- 21,27 ----
  #include <linux/mtd/mtd.h>
  #include <linux/mtd/physmap.h>
  #include <linux/mtd/partitions.h>
+ #include <linux/bpa2.h>
  #include <linux/mtd/nand.h>
  #include <linux/phy.h>
  #include <linux/lirc.h>
***************
*** 33,53 ****
  #include <asm/io.h>
  #include "../common/common.h"
  
  /* Whether the hardware supports NOR or NAND Flash depends on J34.
   * In position 1-2 CSA selects NAND, in position 2-3 is selects NOR.
   * Note that J30A must be in position 2-3 to select the on board Flash
   * (both NOR and NAND).
   */
- #define FLASH_NOR
  
! static int ascs[2] __initdata = { 2, 3 };
  
  static void __init mb618_setup(char** cmdline_p)
  {
  	printk("STMicroelectronics STx7111 Mboard initialisation\n");
  
  	stx7111_early_device_init();
! 	stx7111_configure_asc(ascs, 2, 0);
  }
  
  static struct plat_stm_pwm_data pwm_private_info = {
--- 34,81 ----
  #include <asm/io.h>
  #include "../common/common.h"
  
+ const char *LMI_IO_partalias[] = { "v4l2-coded-video-buffers", "BPA2_Region1", "v4l2-video-buffers" ,
+                                     "coredisplay-video", "gfx-memory", "BPA2_Region0", "LMI_VID", NULL };
+  
+ /*
+ 0x40000000 - 0x403FFFFF - cocpu 1 ram (4mb)
+ 0x40400000 - 0x407FFFFF - cocpu 2 ram (4mb)
+ 0x40800000 - 0x47FFFFFF - linux   (120mb) 
+ 0x48000000 - 0x49FFFFFF - bigphys ( 32mb)
+ 0x4A000000 - 0x4FFFFFFF - lmi_io  ( 96mb)
+ */
+ static struct bpa2_partition_desc bpa2_parts_table[] = {
+     {
+  	    .name  = "bigphysarea",
+  	    .start = 0x48000000,
+  	    .size  = 0x02000000, /* 32 Mb */
+  	    .flags = 0,
+  	    .aka   = NULL
+     }, 
+     {
+  	    .name  = "LMI_IO",
+  	    .start = 0x4A000000,
+  	    .size  = 0x06000000, /* 92 Mb */
+  	    .flags = 0,
+  	    .aka   = LMI_IO_partalias
+     }, 
+  };
+ 
  /* Whether the hardware supports NOR or NAND Flash depends on J34.
   * In position 1-2 CSA selects NAND, in position 2-3 is selects NOR.
   * Note that J30A must be in position 2-3 to select the on board Flash
   * (both NOR and NAND).
   */
  
! static int ascs[1] __initdata = { 1 };
  
  static void __init mb618_setup(char** cmdline_p)
  {
  	printk("STMicroelectronics STx7111 Mboard initialisation\n");
  
  	stx7111_early_device_init();
! 	stx7111_configure_asc(ascs, 1, 0);
!   	bpa2_init(bpa2_parts_table, ARRAY_SIZE(bpa2_parts_table));
  }
  
  static struct plat_stm_pwm_data pwm_private_info = {
***************
*** 56,62 ****
  
  static struct plat_ssc_data ssc_private_info = {
  	.capability  =
! 		ssc0_has(SSC_SPI_CAPABILITY) |
  		ssc1_has(SSC_I2C_CAPABILITY) |
  		ssc2_has(SSC_I2C_CAPABILITY) |
  		ssc3_has(SSC_I2C_CAPABILITY),
--- 84,90 ----
  
  static struct plat_ssc_data ssc_private_info = {
  	.capability  =
! 		ssc0_has(SSC_I2C_CAPABILITY) |
  		ssc1_has(SSC_I2C_CAPABILITY) |
  		ssc2_has(SSC_I2C_CAPABILITY) |
  		ssc3_has(SSC_I2C_CAPABILITY),
***************
*** 123,144 ****
  
  static void set_vpp(struct map_info * info, int enable)
  {
! 	stpio_set_pin(vpp_pio, enable);
! }
  
! static struct mtd_partition mtd_parts_table[3] = {
  	{
! 		.name = "Boot firmware",
! 		.size = 0x00040000,
  		.offset = 0x00000000,
  	}, {
! 		.name = "Kernel",
! 		.size = 0x00100000,
! 		.offset = 0x00040000,
! 	}, {
! 		.name = "Root FS",
  		.size = MTDPART_SIZ_FULL,
! 		.offset = 0x00140000,
  	}
  };
  
--- 151,168 ----
  
  static void set_vpp(struct map_info * info, int enable)
  {
! /*	stpio_set_pin(vpp_pio, enable);
! */}
  
! static struct mtd_partition mtd_parts_table[] = {
  	{
! 		.name = "NOR U-BOOT :    0xA000.0000-0xA007.FFFF (512KB)",
! 		.size = 0x00080000,
  		.offset = 0x00000000,
  	}, {
! 		.name = "NOR ROOT :      0xA008.0000-0xA03F.FFFF (3,5MB)",
  		.size = MTDPART_SIZ_FULL,
! 		.offset = 0x00080000,
  	}
  };
  
***************
*** 156,162 ****
  	.resource	= (struct resource[]) {
  		{
  			.start		= 0x00000000,
! 			.end		= 32*1024*1024 - 1,
  			.flags		= IORESOURCE_MEM,
  		}
  	},
--- 180,186 ----
  	.resource	= (struct resource[]) {
  		{
  			.start		= 0x00000000,
! 			.end		= 4*1024*1024 - 1, /* NOR Flashsize = 0x400000 */
  			.flags		= IORESOURCE_MEM,
  		}
  	},
***************
*** 179,185 ****
  static struct plat_stmmacphy_data phy_private_data = {
  	/* SMSC LAN 8700 */
  	.bus_id = 0,
! 	.phy_addr = -1,
  	.phy_mask = 0,
  	.interface = PHY_INTERFACE_MODE_MII,
  	.phy_reset = &mb618_phy_reset,
--- 203,209 ----
  static struct plat_stmmacphy_data phy_private_data = {
  	/* SMSC LAN 8700 */
  	.bus_id = 0,
! 	.phy_addr = 3,
  	.phy_mask = 0,
  	.interface = PHY_INTERFACE_MODE_MII,
  	.phy_reset = &mb618_phy_reset,
***************
*** 219,235 ****
  	},
  };
  
! /* J34 must be in the 1-2 position to enable NAND Flash */
! static struct mtd_partition mb618_nand_parts[] = {
! 	{
! 		.name	= "NAND root",
! 		.offset	= 0,
! 		.size 	= 0x00800000
! 	}, {
! 		.name	= "NAND home",
! 		.offset	= MTDPART_OFS_APPEND,
! 		.size	= MTDPART_SIZ_FULL
! 	},
  };
  
  static struct plat_stmnand_data mb618_nand_config = {
--- 243,290 ----
  	},
  };
  
! /* J34 must be in the 1-2 position to enable NOR Flash */
! static struct mtd_partition nand_partitions[] = {
! #ifdef ORIGINAL_MTD
! 	 {
! 	 .name = "NAND KERNEL :          0x0000.0000-0x002F.FFFF",
! 	 .size = 0x300000,
! 	 .offset = 0,
! 	 },
! 	 {
! 	 .name = "NAND ROOT :            0x0030.0000-0x027F.FFFF",
! 	 .size = 0x2500000,
! 	 .offset = 0x300000,
! 	 },
! 	 {
! 	 .name = "NAND CONFIG :          0x0280.0000-0x04FF.FFFF",
! 	 .size = 0x2800000,
! 	 .offset = 0x2800000,
! 	 },
! 	 {
! 	 .name = "NAND DATA :            0x0500.0000-0x07FF.FFFF",
! 	 .size = MTDPART_SIZ_FULL,	/* will expand to the end of the flash */
! 	 .offset = 0x05000000,
! 	 },
! #else
! 	 {
! 	 .name = "NAND KERNEL :   0x0000.0000-0x003F.FFFF (  4MB)",
! 	 .size = 0x400000,
! 	 .offset = 0,
! 	 }, {
! 	 .name = "NAND FW :       0x0040.0000-0x00BF.FFFF ( 8MB)",
! 	 .size = 0x800000,
! 	 .offset = 0x400000,
! 	 }, {
! 	 .name = "NAND ROOT :     0x00C0.0000-0x04BF.FFFF ( 64MB)",
! 	 .size = 0x4000000,
! 	 .offset = 0xC00000,
! 	 }, {
! 	 .name = "NAND DATA :     0x04C0.0000-0x07FF.FFFF ( 52MB)",
! 	 .size = MTDPART_SIZ_FULL,	/* will expand to the end of the flash */
! 	 .offset = 0x04C00000,
! 	 },
! #endif
  };
  
  static struct plat_stmnand_data mb618_nand_config = {
***************
*** 257,263 ****
  /* Platform data for STM_NAND_EMI/FLEX/AFM. */
  static struct platform_device mb618_nand_device =
  	STM_NAND_DEVICE("stm-nand-emi", 0, &mb618_nand_config,
! 			mb618_nand_parts, ARRAY_SIZE(mb618_nand_parts), 0);
  
  
  static struct pci_config_data mb618_pci_config = {
--- 312,318 ----
  /* Platform data for STM_NAND_EMI/FLEX/AFM. */
  static struct platform_device mb618_nand_device =
  	STM_NAND_DEVICE("stm-nand-emi", 0, &mb618_nand_config,
! 			nand_partitions, ARRAY_SIZE(nand_partitions), 0);
  
  
  static struct pci_config_data mb618_pci_config = {
***************
*** 289,301 ****
  }
  
  static struct platform_device *mb618_devices[] __initdata = {
- 	&mb618_leds,
  	&epld_device,
! #ifdef FLASH_NOR
! 	&physmap_flash,
! #endif
  	&mb618_phy_device,
- 	&mb618_button_device,
  };
  
  /* Configuration based on Futarque-RC signals train. */
--- 344,352 ----
  }
  
  static struct platform_device *mb618_devices[] __initdata = {
  	&epld_device,
! 	&physmap_flash, /* FLASH_NOR */
  	&mb618_phy_device,
  };
  
  /* Configuration based on Futarque-RC signals train. */
***************
*** 343,359 ****
  
  static int __init device_init(void)
  {
! 	stx7111_configure_pci(&mb618_pci_config);
  	stx7111_configure_pwm(&pwm_private_info);
! 	stx7111_configure_ssc(&ssc_private_info);
  	stx7111_configure_usb(1); /* Enable inverter */
  	stx7111_configure_ethernet(1, 0, 0, 0);
          stx7111_configure_lirc(&lirc_scd);
  
  	vpp_pio = stpio_request_pin(3,4, "VPP", STPIO_OUT);
! 
  #ifdef CONFIG_SND
! 	i2c_register_board_info(1, &mb618_scart_audio, 1);
  #endif
  
  #ifndef FLASH_NOR
--- 394,413 ----
  
  static int __init device_init(void)
  {
! /*	stx7111_configure_pci(&mb618_pci_config);
  	stx7111_configure_pwm(&pwm_private_info);
! */	stx7111_configure_ssc(&ssc_private_info);
  	stx7111_configure_usb(1); /* Enable inverter */
  	stx7111_configure_ethernet(1, 0, 0, 0);
+ /* 
          stx7111_configure_lirc(&lirc_scd);
  
  	vpp_pio = stpio_request_pin(3,4, "VPP", STPIO_OUT);
! */
  #ifdef CONFIG_SND
!  	//disable the in-kernel scart handling otherwise probing
!  	//of avs will fail later
!  	//i2c_register_board_info(1, &mb618_scart_audio, 1);
  #endif
  
  #ifndef FLASH_NOR
***************
*** 361,369 ****
  	/* The MTD NAND code doesn't understand the concept of VPP,
  	 * (or hardware write protect) so permanently enable it.
  	 */
! 	stpio_set_pin(vpp_pio, 1);
  #endif
  
  	return platform_add_devices(mb618_devices, ARRAY_SIZE(mb618_devices));
  }
  arch_initcall(device_init);
--- 415,433 ----
  	/* The MTD NAND code doesn't understand the concept of VPP,
  	 * (or hardware write protect) so permanently enable it.
  	 */
! /*	stpio_set_pin(vpp_pio, 1);
! */
  #endif
  
+ /* kdhong */
+ 	{
+ 		struct stpio_pin *pin;
+ 		pin = stpio_request_pin(4,4, "PHY_RESET", STPIO_OUT);
+ 		stpio_set_pin(pin, 1);
+ //		stpio_free_pin( pin );
+ 	}
+ /* kdhong */
+ 
  	return platform_add_devices(mb618_devices, ARRAY_SIZE(mb618_devices));
  }
  arch_initcall(device_init);
*** a/arch/sh/kernel/cpu/sh4/setup-stx7111.c	2011-01-02 21:06:57.000000000 +0100
--- b/setup-stx7111.c	2011-01-03 01:04:51.322067881 +0100
***************
*** 237,242 ****
--- 237,255 ----
  		platform_device_register(&stssc_devices[i]);
  	}
  
+         /* some additional sysconfig settings to enable i2c, cic and cec */
+ 	ssc_sc = sysconf_claim(SYS_CFG, 5, 0, 0, "cic");
+         sysconf_write(ssc_sc, 1);
+ 
+ 	ssc_sc = sysconf_claim(SYS_CFG, 5, 17, 17, "cic");
+         sysconf_write(ssc_sc, 1);
+ 
+ 	ssc_sc = sysconf_claim(SYS_CFG, 5, 8, 8, "cec");
+         sysconf_write(ssc_sc, 1);
+ 
+         ssc_sc = sysconf_claim(SYS_CFG, 7, 15, 15, "i2c");
+         sysconf_write(ssc_sc, 1);
+ 
  	/* I2C buses number reservation (to prevent any hot-plug device
  	 * from using it) */
  #ifdef CONFIG_I2C_BOARDINFO
***************
*** 390,401 ****
  	STASC_DEVICE(0xfd030000, evt2irq(0x1160), 11, 15,
  		     0, 0, 1, 4, 7,
  		STPIO_ALT_OUT, STPIO_IN, STPIO_IN, STPIO_ALT_OUT), /* oe pin: 6 */
  	STASC_DEVICE(0xfd031000, evt2irq(0x1140), 12, 16,
  		     1, 0, 1, 4, 5,
  		STPIO_ALT_OUT, STPIO_IN, STPIO_IN, STPIO_ALT_OUT), /* oe pin: 6 */
! 	STASC_DEVICE(0xfd032000, evt2irq(0x1120), 13, 17,
! 		     4, 3, 2, 4, 5,
  		STPIO_ALT_OUT, STPIO_IN, STPIO_IN, STPIO_ALT_OUT),
  	STASC_DEVICE(0xfd033000, evt2irq(0x1100), 14, 18,
  		     5, 0, 1, 2, 3,
  		STPIO_ALT_OUT, STPIO_IN, STPIO_IN, STPIO_ALT_OUT),
--- 403,417 ----
  	STASC_DEVICE(0xfd030000, evt2irq(0x1160), 11, 15,
  		     0, 0, 1, 4, 7,
  		STPIO_ALT_OUT, STPIO_IN, STPIO_IN, STPIO_ALT_OUT), /* oe pin: 6 */
+ //console
  	STASC_DEVICE(0xfd031000, evt2irq(0x1140), 12, 16,
  		     1, 0, 1, 4, 5,
  		STPIO_ALT_OUT, STPIO_IN, STPIO_IN, STPIO_ALT_OUT), /* oe pin: 6 */
! //fp
! 	STASC_DEVICE(0xfd032000, evt2irq(0x1120), /* 13 */ -1, /*17 */ -1,
! 		     4, 3, 2, /*4 konfetti */ -1, 5,
  		STPIO_ALT_OUT, STPIO_IN, STPIO_IN, STPIO_ALT_OUT),
+ 
  	STASC_DEVICE(0xfd033000, evt2irq(0x1100), 14, 18,
  		     5, 0, 1, 2, 3,
  		STPIO_ALT_OUT, STPIO_IN, STPIO_IN, STPIO_ALT_OUT),
***************
*** 468,474 ****
  			break;
  		}
  
! 		pdev->id = i;
  		((struct stasc_uart_data*)(pdev->dev.platform_data))->flags = flags;
  		stasc_configured_devices[stasc_configured_devices_count++] = pdev;
  	}
--- 484,491 ----
  			break;
  		}
  
!                 pdev->id = i;
!                 
  		((struct stasc_uart_data*)(pdev->dev.platform_data))->flags = flags;
  		stasc_configured_devices[stasc_configured_devices_count++] = pdev;
  	}
*** a/drivers/mtd/chips/cfi_probe.c	2011-01-02 21:05:30.000000000 +0100
--- b/cfi_probe.c	2011-01-05 20:38:36.087467593 +0100
***************
*** 255,260 ****
--- 255,276 ----
  	for (i=0; i<cfi->cfiq->NumEraseRegions; i++) {
  		cfi->cfiq->EraseRegionInfo[i] = le32_to_cpu(cfi->cfiq->EraseRegionInfo[i]);
  
+ 	/* kdhong */
+ 	printk( "CFI MFR = %x DEV = %x\n", cfi->mfr, cfi->id );
+ 
+ 	if( cfi->mfr == 0x00c2 && cfi->id == 0x227e )
+ 	{
+ 		int devsize = (1 << cfi->cfiq->DevSize) * cfi->interleave;
+ 
+ 		printk( "devsize = %x\n", devsize );
+ 
+ 		if( devsize == 0x400000 )
+ 		{
+ 			cfi->cfiq->EraseRegionInfo[i] = 0x100003f;
+ 		}
+ 	}
+ 	/* kdhong */
+ 
  #ifdef DEBUG_CFI
  		printk("  Erase Region #%d: BlockSize 0x%4.4X bytes, %d blocks\n",
  		       i, (cfi->cfiq->EraseRegionInfo[i] >> 8) & ~0xff,
