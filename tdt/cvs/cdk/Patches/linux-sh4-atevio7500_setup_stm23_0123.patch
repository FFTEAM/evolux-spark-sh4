*** a/arch/sh/boards/st/pdk7105/setup.c	2011-01-05 22:26:18.000000000 +0100
--- b/setup.c	2011-01-07 18:14:26.612869637 +0100
***************
*** 23,28 ****
--- 23,29 ----
  #include <linux/mtd/mtd.h>
  #include <linux/mtd/physmap.h>
  #include <linux/mtd/partitions.h>
+ #include <linux/bpa2.h>
  #include <linux/mtd/nand.h>
  #include <linux/stm/nand.h>
  #include <linux/spi/spi.h>
***************
*** 57,70 ****
   *
   */
  
! static int ascs[2] __initdata = { 2, 3 };
  
  static void __init pdk7105_setup(char** cmdline_p)
  {
  	printk("STMicroelectronics PDK7105-SDK board initialisation\n");
  
  	stx7105_early_device_init();
! 	stx7105_configure_asc(ascs, 2, 0);
  }
  
  static struct plat_stm_pwm_data pwm_private_info = {
--- 58,100 ----
   *
   */
  
! const char *LMI_IO_partalias[] = { "v4l2-coded-video-buffers", "BPA2_Region1", "v4l2-video-buffers" ,
!                                     "coredisplay-video", "gfx-memory", "BPA2_Region0", "LMI_VID", NULL };
!  
! /*
! 0x40000000 - 0x403FFFFF - cocpu 1 ram (4mb)
! 0x40400000 - 0x407FFFFF - cocpu 2 ram (4mb)
! 0x40800000 - 0x47FFFFFF - linux   (120mb) 
! 0x48000000 - 0x49FFFFFF - bigphys ( 32mb)
! 0x4A000000 - 0x4FFFFFFF - lmi_io  ( 96mb)
! */
! static struct bpa2_partition_desc bpa2_parts_table[] = {
!     {
!  	    .name  = "bigphysarea",
!  	    .start = 0x48000000,
!  	    .size  = 0x02000000, /* 32 Mb */
!  	    .flags = 0,
!  	    .aka   = NULL
!     }, 
!     {
!  	    .name  = "LMI_IO",
!  	    .start = 0x4A000000,
!  	    .size  = 0x06000000, /* 92 Mb */
!  	    .flags = 0,
!  	    .aka   = LMI_IO_partalias
!     }, 
!  };
! 
! 
! static int ascs[1] __initdata = { 2 | (STASC_FLAG_NORTSCTS << 8)};
  
  static void __init pdk7105_setup(char** cmdline_p)
  {
  	printk("STMicroelectronics PDK7105-SDK board initialisation\n");
  
  	stx7105_early_device_init();
! 	stx7105_configure_asc(ascs, 1, 0);
!    	bpa2_init(bpa2_parts_table, ARRAY_SIZE(bpa2_parts_table));
  }
  
  static struct plat_stm_pwm_data pwm_private_info = {
***************
*** 75,81 ****
  static struct plat_ssc_data ssc_private_info = {
  	.capability  =
  		ssc0_has(SSC_I2C_CAPABILITY) |
! 		ssc1_has(SSC_I2C_CAPABILITY) |
  		ssc2_has(SSC_I2C_CAPABILITY) |
  		ssc3_has(SSC_I2C_CAPABILITY),
  	.routing =
--- 105,111 ----
  static struct plat_ssc_data ssc_private_info = {
  	.capability  =
  		ssc0_has(SSC_I2C_CAPABILITY) |
! 		ssc1_has(SSC_SPI_CAPABILITY) |
  		ssc2_has(SSC_I2C_CAPABILITY) |
  		ssc3_has(SSC_I2C_CAPABILITY),
  	.routing =
***************
*** 87,95 ****
  	{
  		.oc_en = 1,
  		.oc_actlow = 1,
! 		.oc_pinsel = USB0_OC_PIO4_4,
  		.pwr_en = 1,
! 		.pwr_pinsel = USB0_PWR_PIO4_5,
  	}, {
  		.oc_en = 1,
  		.oc_actlow = 1,
--- 117,125 ----
  	{
  		.oc_en = 1,
  		.oc_actlow = 1,
! 		.oc_pinsel = USB0_OC_PIO12_5,
  		.pwr_en = 1,
! 		.pwr_pinsel = USB0_PWR_PIO12_6,
  	}, {
  		.oc_en = 1,
  		.oc_actlow = 1,
***************
*** 324,333 ****
  
  static struct platform_device *pdk7105_devices[] __initdata = {
  	&pdk7105_physmap_flash,
! 	&pdk7105_leds,
! 	&pdk7105_front_panel,
  	&pdk7105_phy_device,
! 	&spi_pio_device[0],
  };
  
  /* Configuration based on Futarque-RC signals train. */
--- 354,363 ----
  
  static struct platform_device *pdk7105_devices[] __initdata = {
  	&pdk7105_physmap_flash,
! /*	&pdk7105_leds,
! 	&pdk7105_front_panel,*/
  	&pdk7105_phy_device,
! /* &spi_pio_device[0],*/
  };
  
  /* Configuration based on Futarque-RC signals train. */
***************
*** 402,408 ****
  	stx7105_configure_pci(&pdk7105_pci_config);
  
  	stx7105_configure_sata(0);
! 	stx7105_configure_pwm(&pwm_private_info);
  	stx7105_configure_ssc(&ssc_private_info);
  
  	/*
--- 432,438 ----
  	stx7105_configure_pci(&pdk7105_pci_config);
  
  	stx7105_configure_sata(0);
! /*	stx7105_configure_pwm(&pwm_private_info);*/
  	stx7105_configure_ssc(&ssc_private_info);
  
  	/*
***************
*** 419,438 ****
  	stx7105_configure_usb(0, &usb_init[0]);
  	stx7105_configure_usb(1, &usb_init[1]);
  
! 	phy_reset_pin = stpio_request_set_pin(15, 5, "eth_phy_reset",
  					      STPIO_OUT, 1);
  	stx7105_configure_ethernet(0, stx7105_ethernet_mii, 0, 0, 0, 0);
! 	stx7105_configure_lirc(&lirc_scd);
  	stx7105_configure_audio_pins(0, 0, 1, 0);
! 
  	/*
  	 * FLASH_WP is shared by NOR and NAND.  However, since MTD NAND has no
  	 * concept of WP/VPP, we must permanently enable it
  	 */
! 	stpio_request_set_pin(6, 4, "FLASH_WP", STPIO_OUT, 1);
  
  	stx7105_configure_nand(&nand_device);
! 	spi_register_board_info(spi_serialflash, ARRAY_SIZE(spi_serialflash));
  
  	return platform_add_devices(pdk7105_devices, ARRAY_SIZE(pdk7105_devices));
  }
--- 449,471 ----
  	stx7105_configure_usb(0, &usb_init[0]);
  	stx7105_configure_usb(1, &usb_init[1]);
  
! 	phy_reset_pin = stpio_request_set_pin(5, 5, "eth_phy_reset",
  					      STPIO_OUT, 1);
  	stx7105_configure_ethernet(0, stx7105_ethernet_mii, 0, 0, 0, 0);
! /*	stx7105_configure_lirc(&lirc_scd);
  	stx7105_configure_audio_pins(0, 0, 1, 0);
! */
  	/*
  	 * FLASH_WP is shared by NOR and NAND.  However, since MTD NAND has no
  	 * concept of WP/VPP, we must permanently enable it
  	 */
! 	stpio_request_set_pin(15, 0, "FLASH_WP", STPIO_OUT, 1);
  
  	stx7105_configure_nand(&nand_device);
! /*	spi_register_board_info(spi_serialflash, ARRAY_SIZE(spi_serialflash));*/
! 
! /* enable optical out */
!     stpio_request_pin (10, 6, "opt_out", STPIO_ALT_OUT);
  
  	return platform_add_devices(pdk7105_devices, ARRAY_SIZE(pdk7105_devices));
  }

*** linux-sh4/drivers/net/stmmac/stmmac_main.c	2010-02-07 22:14:38.470923501 +0100
--- linux-sh4/drivers/net/stmmac/stmmac_main.c	2010-01-31 11:02:03.000000000 +0100
***************
*** 370,375 ****
--- 370,404 ----
  	return;
  }
  
+ #include <linux/ctype.h>
+ 
+ static unsigned long simple_strtoul2(const char *cp,char **endp,unsigned int base)
+ {
+ 	unsigned long result = 0,value;
+ 
+ 	if (*cp == '0') {
+ 		cp++;
+ 		if ((*cp == 'x') && isxdigit(cp[1])) {
+ 			base = 16;
+ 			cp++;
+ 		}
+ 		if (!base) {
+ 			base = 8;
+ 		}
+ 	}
+ 	if (!base) {
+ 		base = 10;
+ 	}
+ 	while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp-'0' : (islower(*cp)
+ 	    ? toupper(*cp) : *cp)-'A'+10) < base) {
+ 		result = result*base + value;
+ 		cp++;
+ 	}
+ 	if (endp)
+ 		*endp = (char *)cp;
+ 	return result;
+ }
+ 
  /**
   * get_mac_addr
   * @ioaddr: device I/O address
***************
*** 378,391 ****
   * @low: low register offset
   * Description: the function gets the hardware MAC address
   */
  static void get_mac_address(unsigned long ioaddr, unsigned char *addr,
  			    unsigned int high, unsigned int low)
  {
  	unsigned int hi_addr, lo_addr;
  
  	/* Read the MAC address from the hardware */
! 	hi_addr = readl(ioaddr + high);
! 	lo_addr = readl(ioaddr + low);
  
  	/* Extract the MAC address from the high and low words */
  	addr[0] = lo_addr & 0xff;
--- 407,453 ----
   * @low: low register offset
   * Description: the function gets the hardware MAC address
   */
+ 
+ char g_env_mac[]="00:50:FD:00:00:00";
+ 
  static void get_mac_address(unsigned long ioaddr, unsigned char *addr,
  			    unsigned int high, unsigned int low)
  {
  	unsigned int hi_addr, lo_addr;
  
+     int env_size,reg,env_present=0, tmp_count;
+     char *s = NULL, *e,  es[] = "00:00:00:00:00:00";
+     unsigned char s_env_mac[64], v_env_mac[6];
+ 
  	/* Read the MAC address from the hardware */
! 	env_size = 17;
! 	memcpy(s_env_mac, g_env_mac, 17);
! 
! 	if (env_size > 0) {
! 			env_present = 1;
! 			s = s_env_mac;
! 		}
! 
! 	//by doliyu ...patch for mac address write error!
! 	for(tmp_count =0 ; tmp_count < 17; tmp_count++)
! 	{
! 		if(s_env_mac[tmp_count] == ' ')
! 			s_env_mac[tmp_count]='0';
! 		printk("s_env_mac[%d] = %c\n", tmp_count, s_env_mac[tmp_count]);
! 	}
! 	
! 	for (reg = 0; reg < 6; ++reg) { /* turn string into mac value */
! 		v_env_mac[reg] = s ? simple_strtoul2 (s, &e, 16) : 0;
! 		if (s)
! 			s = (*e) ? e + 1 : e;
! 	}
! 
!     printk("get ether addr = %x, %x, %x, %x, %x, %x \n", v_env_mac[0],v_env_mac[1],v_env_mac[2],v_env_mac[3],v_env_mac[4],v_env_mac[5]);
!     hi_addr = (int)(v_env_mac[5]) <<8 | (int)(v_env_mac[4]);
!     lo_addr = (int)(v_env_mac[3]) << 24 | (int)(v_env_mac[2]) << 16 | (int)(v_env_mac[1]) <<8 | v_env_mac[0];
! 
! //	hi_addr = readl(ioaddr + high);
! //	lo_addr = readl(ioaddr + low);
  
  	/* Extract the MAC address from the high and low words */
  	addr[0] = lo_addr & 0xff;
***************
*** 2309,2314 ****
--- 2371,2379 ----
  			tmrate = simple_strtoul(opt + 7, NULL, 0);
  #endif
  		}
+ 		else if( !strncmp(opt,"ethaddr:", 8)) {
+ 			memcpy(g_env_mac, opt + 8, 17);
+ 		}
  	}
  	return 0;
  }
