*** linux-sh4/arch/sh/kernel/setup.c	2011-01-05 10:45:31.000000000 +0100
--- setup.c.patched	2011-01-22 12:22:31.340928000 +0100
***************
*** 276,281 ****
--- 276,287 ----
  #endif
  #endif
  
+ 	char org_command_line[] = "console=ttyAS0,115200 root=/dev/mtdblock3";
+ 	char tdt_command_line[] = "console=ttyAS0,115200 root=/dev/mtdblock4 rw rootfstype=jffs2 init=/bin/devinit coprocessor_mem=4m@0x40000000,4m@0x40400000 printk=1";
+ 
+ 	if(strncmp(command_line, org_command_line, strlen(org_command_line)) == 0)
+ 		strlcpy(command_line, tdt_command_line, sizeof(tdt_command_line));
+ 
  	/* Save unparsed command line copy for /proc/cmdline */
  	memcpy(boot_command_line, command_line, COMMAND_LINE_SIZE);
  	*cmdline_p = command_line;

*** linux-sh4/arch/sh/boards/st/pdk7105/setup.c	2011-02-02 01:06:34.097847325 +0100
--- setup.c.patched	2011-02-02 01:11:32.928138606 +0100
***************
*** 23,28 ****
--- 23,29 ----
  #include <linux/mtd/mtd.h>
  #include <linux/mtd/physmap.h>
  #include <linux/mtd/partitions.h>
+ #include <linux/bpa2.h>
  #include <linux/mtd/nand.h>
  #include <linux/stm/nand.h>
  #include <linux/spi/spi.h>
***************
*** 57,70 ****
   *
   */
  
! static int ascs[2] __initdata = { 2, 3 };
  
  static void __init pdk7105_setup(char** cmdline_p)
  {
  	printk("STMicroelectronics PDK7105-SDK board initialisation\n");
  
  	stx7105_early_device_init();
! 	stx7105_configure_asc(ascs, 2, 0);
  }
  
  static struct plat_stm_pwm_data pwm_private_info = {
--- 58,100 ----
   *
   */
  
! const char *LMI_IO_partalias[] = { "v4l2-coded-video-buffers", "BPA2_Region1", "v4l2-video-buffers" ,
!                                     "coredisplay-video", "gfx-memory", "BPA2_Region0", "LMI_VID", NULL };
!  
! /*
! 0x40000000 - 0x403FFFFF - cocpu 1 ram (4mb)
! 0x40400000 - 0x407FFFFF - cocpu 2 ram (4mb)
! 0x40800000 - 0x47FFFFFF - linux   (120mb) 
! 0x48000000 - 0x49FFFFFF - bigphys ( 32mb)
! 0x4A000000 - 0x4FFFFFFF - lmi_io  ( 96mb)
! */
! static struct bpa2_partition_desc bpa2_parts_table[] = {
!     {
!  	    .name  = "bigphysarea",
!  	    .start = 0x48000000,
!  	    .size  = 0x02000000, /* 32 Mb */
!  	    .flags = 0,
!  	    .aka   = NULL
!     }, 
!     {
!  	    .name  = "LMI_IO",
!  	    .start = 0x4A000000,
!  	    .size  = 0x06000000, /* 92 Mb */
!  	    .flags = 0,
!  	    .aka   = LMI_IO_partalias
!     }, 
!  };
! 
! 
! static int ascs[1] __initdata = { 2 | (STASC_FLAG_NORTSCTS << 8)};
  
  static void __init pdk7105_setup(char** cmdline_p)
  {
  	printk("STMicroelectronics PDK7105-SDK board initialisation\n");
  
  	stx7105_early_device_init();
! 	stx7105_configure_asc(ascs, 1, 0);
!    	bpa2_init(bpa2_parts_table, ARRAY_SIZE(bpa2_parts_table));
  }
  
  static struct plat_stm_pwm_data pwm_private_info = {
*************** static struct plat_stm_pwm_data pwm_priv
*** 75,81 ****
  static struct plat_ssc_data ssc_private_info = {
  	.capability  =
  		ssc0_has(SSC_I2C_CAPABILITY) |
! 		ssc1_has(SSC_I2C_CAPABILITY) |
  		ssc2_has(SSC_I2C_CAPABILITY) |
  		ssc3_has(SSC_I2C_CAPABILITY),
  	.routing =
--- 105,111 ----
  static struct plat_ssc_data ssc_private_info = {
  	.capability  =
  		ssc0_has(SSC_I2C_CAPABILITY) |
! 		ssc1_has(SSC_SPI_CAPABILITY) |
  		ssc2_has(SSC_I2C_CAPABILITY) |
  		ssc3_has(SSC_I2C_CAPABILITY),
  	.routing =
*************** static struct plat_ssc_data ssc_private_
*** 85,91 ****
  
  static struct usb_init_data usb_init[2] __initdata = {
  	{
! 		.oc_en = 1,
  		.oc_actlow = 1,
  		.oc_pinsel = USB0_OC_PIO4_4,
  		.pwr_en = 1,
--- 115,121 ----
  
  static struct usb_init_data usb_init[2] __initdata = {
  	{
! 		.oc_en = 0,
  		.oc_actlow = 1,
  		.oc_pinsel = USB0_OC_PIO4_4,
  		.pwr_en = 1,
*************** static struct platform_device pdk7105_ph
*** 198,219 ****
  		.platform_data = &phy_private_data,
  	}
  };
! 
! static struct mtd_partition mtd_parts_table[3] = {
  	{
! 		.name = "Boot firmware",
  		.size = 0x00040000,
  		.offset = 0x00000000,
  	}, {
  		.name = "Kernel",
! 		.size = 0x00200000,
  		.offset = 0x00040000,
  	}, {
! 		.name = "Root FS",
! 		.size = MTDPART_SIZ_FULL,
! 		.offset = 0x00240000,
  	}
  };
  
  static struct physmap_flash_data pdk7105_physmap_flash_data = {
  	.width		= 2,
--- 228,302 ----
  		.platform_data = &phy_private_data,
  	}
  };
! #ifdef FUP_CAN_FLASH_CONFIG
! static struct mtd_partition mtd_parts_table[8] = {
  	{
! 		.name = "U-BOOT",
  		.size = 0x00040000,
  		.offset = 0x00000000,
  	}, {
  		.name = "Kernel",
! 		.size = 0x00300000,
! 		.offset = 0x00100000,
! 	}, {
! 		.name = "FW",
! 		.size = 0x006E0000,
! 		.offset = 0x00B20000,
! 	}, {
! 		.name = "EXT2",
! 		.size = 0x00BE0000,
! 		.offset = 0x01220000,
! 	}, {
! 		.name = "ROOT",
! 		.size = 0x0021E0000,
! 		.offset = 0x01E20000,
! 	}, { 
! 		.name = "EXT1",
! 		.size = 0x006E0000,
! 		.offset = 0x00420000,
! 	}, { 
! 		.name = "U-BOOT ENV",
! 		.size = 0x00020000,
  		.offset = 0x00040000,
+ 	}, { 
+  		.name = "Full", 
+  		.size = MTDPART_SIZ_FULL, 
+ 		.offset = 0x00100000, 
+ 	}
+ };
+ #else
+ static struct mtd_partition mtd_parts_table[7] = {
+ 	{
+ 		.name = "U-BOOT",
+ 		.size = 0x00040000,
+ 		.offset = 0x00000000,
  	}, {
! 		.name = "Kernel",
! 		.size = 0x00300000,
! 		.offset = 0x00100000,
! 	}, {
! 		.name = "FW",
! 		.size = 0x006E0000,
! 		.offset = 0x00B20000,
! 	}, {
! 		.name = "EXT",
! 		.size = 0x00BE0000,
! 		.offset = 0x01220000,
! 	}, {
! 		.name = "ROOT",
! 		.size = 0x001E00000,
! 		.offset = 0x02200000,
! 	}, { 
! 		.name = "U-BOOT ENV",
! 		.size = 0x00020000,
! 		.offset = 0x00040000,
! 	}, { 
!  		.name = "Full", 
!  		.size = MTDPART_SIZ_FULL, 
! 		.offset = 0x00100000, 
  	}
  };
+ #endif
  
  static struct physmap_flash_data pdk7105_physmap_flash_data = {
  	.width		= 2,
*************** STM_NAND_DEVICE("stm-nand-flex", 2, &nan
*** 324,333 ****
  
  static struct platform_device *pdk7105_devices[] __initdata = {
  	&pdk7105_physmap_flash,
! 	&pdk7105_leds,
! 	&pdk7105_front_panel,
  	&pdk7105_phy_device,
! 	&spi_pio_device[0],
  };
  
  /* Configuration based on Futarque-RC signals train. */
--- 407,416 ----
  
  static struct platform_device *pdk7105_devices[] __initdata = {
  	&pdk7105_physmap_flash,
! /*	&pdk7105_leds,
! 	&pdk7105_front_panel,*/
  	&pdk7105_phy_device,
! /* &spi_pio_device[0],*/
  };
  
  /* Configuration based on Futarque-RC signals train. */
*************** static int __init device_init(void)
*** 390,395 ****
--- 473,479 ----
  		nand_device.id = 0;
  	}
  
+ #ifdef USE_IT
  	/* Setup the PCI_SERR# PIO */
  	if (gpio_request(PDK7105_GPIO_PCI_SERR, "PCI_SERR#") == 0) {
  		gpio_direction_input(PDK7105_GPIO_PCI_SERR);
*************** static int __init device_init(void)
*** 400,408 ****
  		printk(KERN_WARNING "pdk7105: Failed to claim PCI SERR PIO!\n");
  	}
  	stx7105_configure_pci(&pdk7105_pci_config);
  
  	stx7105_configure_sata(0);
! 	stx7105_configure_pwm(&pwm_private_info);
  	stx7105_configure_ssc(&ssc_private_info);
  
  	/*
--- 484,493 ----
  		printk(KERN_WARNING "pdk7105: Failed to claim PCI SERR PIO!\n");
  	}
  	stx7105_configure_pci(&pdk7105_pci_config);
+ #endif    
  
  	stx7105_configure_sata(0);
! /*	stx7105_configure_pwm(&pwm_private_info);*/
  	stx7105_configure_ssc(&ssc_private_info);
  
  	/*
*************** static int __init device_init(void)
*** 419,438 ****
  	stx7105_configure_usb(0, &usb_init[0]);
  	stx7105_configure_usb(1, &usb_init[1]);
  
! 	phy_reset_pin = stpio_request_set_pin(15, 5, "eth_phy_reset",
  					      STPIO_OUT, 1);
  	stx7105_configure_ethernet(0, stx7105_ethernet_mii, 0, 0, 0, 0);
! 	stx7105_configure_lirc(&lirc_scd);
  	stx7105_configure_audio_pins(0, 0, 1, 0);
! 
  	/*
  	 * FLASH_WP is shared by NOR and NAND.  However, since MTD NAND has no
  	 * concept of WP/VPP, we must permanently enable it
  	 */
! 	stpio_request_set_pin(6, 4, "FLASH_WP", STPIO_OUT, 1);
  
  	stx7105_configure_nand(&nand_device);
! 	spi_register_board_info(spi_serialflash, ARRAY_SIZE(spi_serialflash));
  
  	return platform_add_devices(pdk7105_devices, ARRAY_SIZE(pdk7105_devices));
  }
--- 504,526 ----
  	stx7105_configure_usb(0, &usb_init[0]);
  	stx7105_configure_usb(1, &usb_init[1]);
  
! 	phy_reset_pin = stpio_request_set_pin(5, 5, "eth_phy_reset",
  					      STPIO_OUT, 1);
  	stx7105_configure_ethernet(0, stx7105_ethernet_mii, 0, 0, 0, 0);
! /*	stx7105_configure_lirc(&lirc_scd);
  	stx7105_configure_audio_pins(0, 0, 1, 0);
! */
  	/*
  	 * FLASH_WP is shared by NOR and NAND.  However, since MTD NAND has no
  	 * concept of WP/VPP, we must permanently enable it
  	 */
! 	stpio_request_set_pin(15, 0, "FLASH_WP", STPIO_OUT, 1);
  
  	stx7105_configure_nand(&nand_device);
! /*	spi_register_board_info(spi_serialflash, ARRAY_SIZE(spi_serialflash));*/
! 
! /* enable optical out */
!     stpio_request_pin (10, 6, "opt_out", STPIO_ALT_OUT);
  
  	return platform_add_devices(pdk7105_devices, ARRAY_SIZE(pdk7105_devices));
  }
--- linux-sh4/drivers/net/stmmac/stmmac_main.c	2011-01-04 16:02:05.000000000 +0100
+++ linux-sh4/drivers/net/stmmac/stmmac_main.c.patched	2011-01-12 17:21:54.000000000 +0100
@@ -389,6 +389,96 @@
 	return 0;
 }
 
+#include <linux/ctype.h>
+
+static unsigned long simple_strtoul2(const char *cp,char **endp,unsigned int base)
+{
+	unsigned long result = 0,value;
+
+	if (*cp == '0') {
+		cp++;
+		if ((*cp == 'x') && isxdigit(cp[1])) {
+			base = 16;
+			cp++;
+		}
+		if (!base) {
+			base = 8;
+		}
+	}
+	if (!base) {
+		base = 10;
+	}
+	while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp-'0' : (islower(*cp)
+	    ? toupper(*cp) : *cp)-'A'+10) < base) {
+		result = result*base + value;
+		cp++;
+	}
+	if (endp)
+		*endp = (char *)cp;
+	return result;
+}
+
+/**
+ * get_mac_addr
+ * @ioaddr: device I/O address
+ * @addr: mac address
+ * @high: High register offset
+ * @low: low register offset
+ * Description: the function gets the hardware MAC address
+ */
+
+char g_env_mac[]="00:50:FD:00:00:00";
+
+static void get_mac_address(unsigned long ioaddr, unsigned char *addr,
+			    unsigned int high, unsigned int low)
+{
+	unsigned int hi_addr, lo_addr;
+
+    int env_size,reg,env_present=0, tmp_count;
+    char *s = NULL, *e,  es[] = "00:00:00:00:00:00";
+    unsigned char s_env_mac[64], v_env_mac[6];
+
+	/* Read the MAC address from the hardware */
+	env_size = 17;
+	memcpy(s_env_mac, g_env_mac, 17);
+
+	if (env_size > 0) {
+			env_present = 1;
+			s = s_env_mac;
+		}
+
+	//by doliyu ...patch for mac address write error!
+	for(tmp_count =0 ; tmp_count < 17; tmp_count++)
+	{
+		if(s_env_mac[tmp_count] == ' ')
+			s_env_mac[tmp_count]='0';
+		printk("s_env_mac[%d] = %c\n", tmp_count, s_env_mac[tmp_count]);
+	}
+	
+	for (reg = 0; reg < 6; ++reg) { /* turn string into mac value */
+		v_env_mac[reg] = s ? simple_strtoul2 (s, &e, 16) : 0;
+		if (s)
+			s = (*e) ? e + 1 : e;
+	}
+
+    printk("get ether addr = %x, %x, %x, %x, %x, %x \n", v_env_mac[0],v_env_mac[1],v_env_mac[2],v_env_mac[3],v_env_mac[4],v_env_mac[5]);
+    hi_addr = (int)(v_env_mac[5]) <<8 | (int)(v_env_mac[4]);
+    lo_addr = (int)(v_env_mac[3]) << 24 | (int)(v_env_mac[2]) << 16 | (int)(v_env_mac[1]) <<8 | v_env_mac[0];
+
+//	hi_addr = readl(ioaddr + high);
+//	lo_addr = readl(ioaddr + low);
+
+	/* Extract the MAC address from the high and low words */
+	addr[0] = lo_addr & 0xff;
+	addr[1] = (lo_addr >> 8) & 0xff;
+	addr[2] = (lo_addr >> 16) & 0xff;
+	addr[3] = (lo_addr >> 24) & 0xff;
+	addr[4] = hi_addr & 0xff;
+	addr[5] = (hi_addr >> 8) & 0xff;
+
+	return;
+}
+
 /**
  * stmmac_mac_enable_rx
  * @dev: net device structure
@@ -2348,6 +2438,9 @@
 			tmrate = simple_strtoul(opt + 7, NULL, 0);
 #endif
 		}
+		else if( !strncmp(opt,"ethaddr:", 8)) {
+			memcpy(g_env_mac, opt + 8, 17);
+		}
 	}
 	return 0;
 }
