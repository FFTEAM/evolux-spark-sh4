diff -Nur enigma2-nightly/acinclude.m4 enigma2-nightly.spark/acinclude.m4
--- enigma2-nightly/acinclude.m4	2010-08-11 18:16:49.430806541 +0800
+++ enigma2-nightly.spark/acinclude.m4	2010-08-11 18:12:24.718589030 +0800
@@ -370,7 +370,7 @@
 		
 		# FIXME: yes, this is wrong. sorry about that. (tmbinc)
 		cross_PYTHON_VERSION=$PYTHON_VERSION
-		python_path=
+		python_path=$PY_PATH/include/python2.6 
 		for i in $CPPFLAGS ; do
 			p=`echo $i | sed "s,^-I,,"`
 			p=`echo $p | sed "s,^-isystem,,"`
@@ -387,7 +387,7 @@
 
 		# Check for Python library path
 		AC_MSG_CHECKING([for Python library path])
-		python_path=
+		python_path=$PY_PATH/include/python2.6 
 		for i in $LDFLAGS; do
 			l=`echo $i | sed "s,^-L,,"`
 			python_path=`find $l -type f -name libpython$cross_PYTHON_VERSION.* -print | sed "1q"`
diff -Nur enigma2-nightly/autogen.sh enigma2-nightly.spark/autogen.sh
--- enigma2-nightly/autogen.sh	2010-08-11 18:16:49.430806541 +0800
+++ enigma2-nightly.spark/autogen.sh	2010-08-11 18:12:24.880297947 +0800
@@ -50,7 +50,7 @@
 echo "Generating configuration files for $package, please wait...."
 
 echo "  aclocal"
-aclocal
+aclocal -I m4
 echo "  libtoolize --automake"
 libtoolize --automake
 echo "  autoconf"
diff -Nur enigma2-nightly/configure.ac enigma2-nightly.spark/configure.ac
--- enigma2-nightly/configure.ac	2010-08-11 18:16:49.430806541 +0800
+++ enigma2-nightly.spark/configure.ac	2010-08-11 18:12:24.882616509 +0800
@@ -22,6 +22,26 @@
 fi
 AM_CONDITIONAL(HAVE_DDVDLIB, test "$have_ddvdlib" = "yes")
 
+AC_ARG_ENABLE([tf7700],
+        [AS_HELP_STRING(--enable-tf7700,    enable topfield tf7700 stuff)],
+#	AC_MSG_ERROR([bad value I${enableval}I for --enable-tf7700]))
+        [case "${enableval}" in
+                yes) enable_tf7700=true ;;
+                no) enable_tf7700=false ;;
+                *) AC_MSG_ERROR([bad value ${enableval} for --enable-tf7700]) ;;
+        esac])
+AM_CONDITIONAL([ENABLE_TF7700], [test x$enable_tf7700 = xtrue])
+
+AC_ARG_ENABLE([cuberevo],
+        [AS_HELP_STRING(--enable-cuberevo,    enable cuberevo stuff)],
+#	AC_MSG_ERROR([bad value I${enableval}I for --enable-cuberevo]))
+        [case "${enableval}" in
+                yes) enable_cuberevo=true ;;
+                no) enable_cuberevo=false ;;
+                *) AC_MSG_ERROR([bad value ${enableval} for --enable-cuberevo]) ;;
+        esac])
+AM_CONDITIONAL([ENABLE_CUBEREVO], [test x$enable_cuberevo = xtrue])
+
 AM_PATH_PYTHON()
 AC_PYTHON_DEVEL
 #AM_PATH_XINE(1.1.0,, AC_MSG_ERROR([*** Please install xine-lib (devel) first ***]))
@@ -58,10 +78,11 @@
 TUXBOX_APPS_LIB_PKGCONFIG(XML2,libxml-2.0)
 
 # ok, we are in trouble: XMLCCWRAP only defines C++ symbols. So let's just check if linking works,
-# and assume everything will be ok. Then just check for the "exit" symbol, which should be always there.
+# and assume everything will be ok. Then just check for the "main" symbol, which should be always there.
+# This check fails if the user decides to use the --pedantic CFLAG
 AC_LANG_SAVE
 AC_LANG_CPLUSPLUS
-TUXBOX_APPS_LIB_SYMBOL(XMLCCWRAP, xmlccwrap, exit)
+TUXBOX_APPS_LIB_SYMBOL(XMLCCWRAP, xmlccwrap, main)
 AC_LANG_RESTORE
 
 if test "$withsdl" = "yes" ; then
@@ -117,8 +138,6 @@
 lib/python/Components/Sources/Makefile
 lib/python/Screens/Makefile
 lib/python/Plugins/Makefile
-lib/python/Plugins/DemoPlugins/Makefile
-lib/python/Plugins/DemoPlugins/TestPlugin/Makefile
 lib/python/Plugins/Extensions/CutListEditor/Makefile
 lib/python/Plugins/Extensions/CutListEditor/meta/Makefile
 lib/python/Plugins/Extensions/DVDBurn/Makefile
@@ -133,15 +152,12 @@
 lib/python/Plugins/Extensions/MediaPlayer/meta/Makefile
 lib/python/Plugins/Extensions/MediaScanner/Makefile
 lib/python/Plugins/Extensions/MediaScanner/meta/Makefile
-lib/python/Plugins/Extensions/Modem/Makefile
 lib/python/Plugins/Extensions/PicturePlayer/Makefile
 lib/python/Plugins/Extensions/PicturePlayer/meta/Makefile
 lib/python/Plugins/Extensions/PicturePlayer/data/Makefile
 lib/python/Plugins/Extensions/SocketMMI/Makefile
 lib/python/Plugins/Extensions/SocketMMI/meta/Makefile
 lib/python/Plugins/Extensions/SocketMMI/src/Makefile
-lib/python/Plugins/Extensions/TuxboxPlugins/Makefile
-lib/python/Plugins/Extensions/TuxboxPlugins/meta/Makefile
 lib/python/Plugins/SystemPlugins/CleanupWizard/Makefile
 lib/python/Plugins/SystemPlugins/CleanupWizard/meta/Makefile
 lib/python/Plugins/SystemPlugins/CommonInterfaceAssignment/Makefile
@@ -180,6 +196,12 @@
 lib/python/Plugins/SystemPlugins/Videomode/meta/Makefile
 lib/python/Plugins/SystemPlugins/WirelessLan/Makefile
 lib/python/Plugins/SystemPlugins/WirelessLan/meta/Makefile
+lib/python/Plugins/Extensions/TopfieldVFD/Makefile
+lib/python/Plugins/Extensions/CuberevoVFD/Makefile
+lib/python/Plugins/SystemPlugins/Tuxtxt/Makefile
+lib/python/Plugins/SystemPlugins/Tuxtxt/tuxtxt/Makefile
+lib/python/Plugins/SystemPlugins/VFD-Icons/Makefile 
+lib/python/Plugins/SystemPlugins/VFD-Icons/meta/Makefile
 lib/python/Tools/Makefile
 lib/service/Makefile
 lib/components/Makefile
diff -Nur enigma2-nightly/data/Makefile.am enigma2-nightly.spark/data/Makefile.am
--- enigma2-nightly/data/Makefile.am	2010-08-11 18:16:49.430806541 +0800
+++ enigma2-nightly.spark/data/Makefile.am	2010-08-11 18:12:24.887918546 +0800
@@ -15,3 +15,5 @@
 	skin.xml \
 	startwizard.xml \
 	tutorialwizard.xml
+
+
diff -Nur enigma2-nightly/include/shmE2.h enigma2-nightly.spark/include/shmE2.h
--- enigma2-nightly/include/shmE2.h	1970-01-01 08:00:00.000000000 +0800
+++ enigma2-nightly.spark/include/shmE2.h	2010-08-11 18:12:24.900694948 +0800
@@ -0,0 +1,253 @@
+#ifndef SHME2
+#define SHME2
+
+#include <sys/ipc.h>
+#include <sys/shm.h>
+
+#define SHMSZ 27
+#define KEY 1234
+
+static char* createshm()
+{
+	int shmid;
+	key_t key = KEY;
+	char *shm = NULL;
+
+	if((shmid = shmget(key, SHMSZ, IPC_CREAT | 0666)) < 0) {
+		return NULL;
+	}
+
+	shm = (char *) shmat(shmid, NULL, 0);
+	if(shm == (char *) -1)
+		return NULL;
+
+	*shm = '\0';
+
+	return shm;
+}
+
+static char* findshm()
+{
+	int shmid;
+	key_t key = KEY;
+	char *shm = NULL;
+
+	if((shmid = shmget(key, SHMSZ, 0666)) < 0) {
+		return NULL;
+	}
+
+	shm = (char *) shmat(shmid, NULL, 0);
+	if(shm == (char *) -1)
+		return NULL;
+
+	return shm;
+}
+
+static int delshmentry(char *shm, char *key)
+{
+	if(shm == NULL) return -1;
+	char *vbuf = NULL, *shmbuf = NULL;
+	char *v, *s = shm;
+	int matchkey = 0;
+	int ret = 0;
+
+	vbuf = (char *) malloc(256);
+	if(vbuf == NULL)
+		return -1;
+	v = vbuf;
+	memset(vbuf, '\0', 256);
+
+	//FIXME: here we can have a segfault
+	shmbuf = (char *) malloc(4096);
+	if(shmbuf == NULL)
+	{
+		free(vbuf);
+		return -1;
+	}
+	memset(shmbuf, '\0', 4096);
+
+	while(*s != '\0')
+	{
+		*v++ = *s++;
+		*v = '\0';
+		if(strcmp(key, vbuf) == 0)
+		{
+			matchkey = 1;
+			ret = 1;
+		}
+		if(matchkey == 0 && *s == ';')
+		{
+			*v++ = ';';
+			*v = '\0';
+			strcat(shmbuf, vbuf);
+			v = vbuf;
+			s++;
+		}
+		if(matchkey == 1 && *s == ';')
+		{
+			matchkey = 0;
+			v = vbuf;
+			s++;
+		}
+	}
+	if(matchkey == 0)
+	{
+		*v++ = ';';
+		*v = '\0';
+		strcat(shmbuf, vbuf);
+		v = vbuf;
+	}
+	shmbuf[strlen(shmbuf)-1] = '\0';
+	*shm = '\0';
+	strcpy(shm, shmbuf);
+
+	free(vbuf);
+	free(shmbuf);
+
+	return ret;
+}
+
+static int setshmentry(char *shm, char *entry)
+{
+	if(shm == NULL) return -1;
+	char *buf = NULL;
+	char *c = NULL;
+	int pos = 0;
+
+	if(strlen(entry) > 255)
+		return -1;
+
+	buf = (char *) malloc(256);
+	if(buf == NULL)
+		return -1;
+	memset(buf, '\0', 256);
+
+	c = strchr(entry, '=');
+	if(c != NULL)
+		pos = (c - entry) + 1;
+	else
+	{
+		free(buf);
+		return -1;
+	}
+
+	strncpy(buf, entry, pos);
+	buf[pos] = '\0';
+
+	if(delshmentry(shm, buf) < 0)
+	{
+		free(buf);
+		return -1;
+	}
+
+	if(*shm != '\0')
+		strcat(shm, ";");
+	strcat(shm, entry);
+
+	free(buf);
+	return 1;
+}
+
+static int getshmentry(char *shm, char *key, char *buf, int buflen)
+{
+	if(shm == NULL) return -1;
+	char *v, *s = shm, *shmbuf;
+	int matchkey = 0;
+	int ret = 0;
+
+	shmbuf = (char *) malloc(256);
+	if(shmbuf == NULL)
+		return -1;
+	memset(shmbuf, '\0', 256);
+
+	v = shmbuf;
+
+	while(*s != '\0')
+	{
+		*v++ = *s++;
+		*v = '\0';
+		if(strcmp(key, shmbuf) == 0)
+		{
+			v = shmbuf;
+			matchkey = 1;
+			ret = 1;
+		}
+		if(matchkey == 0 && *s == ';')
+		{
+			v = shmbuf;
+			s++;
+		}
+		if(matchkey == 1 && *s == ';')
+		break;
+	}
+	if(matchkey == 0)
+	v = shmbuf;
+	*v = '\0';
+
+	strncpy(buf, shmbuf, buflen-1);
+	buf[buflen] = '\0';
+	free(shmbuf);
+
+	return ret;
+}
+
+static int checkshmentry(char *shm, char *key)
+{
+	if(shm == NULL) return -1;
+	char *v = NULL, *s = shm, *shmbuf = NULL;
+	int ret = 0;
+
+	shmbuf = (char *) malloc(256);
+	if(shmbuf == NULL)
+		return -1;
+	memset(shmbuf, '\0', 256);
+
+	v = shmbuf;
+
+	while(*s != '\0')
+	{
+		*v++ = *s++;
+		*v = '\0';
+		if(strcmp(key, shmbuf) == 0)
+		{
+ 		ret = 1;
+			break;
+		}
+		if(*s == ';')
+		{
+			v = shmbuf;
+			s++;
+		}
+	}
+	free(shmbuf);
+	return ret;
+}
+
+static int getshmentryall(char *shm, char *shmbuf, int buflen)
+{
+	if(shm == NULL) return -1;
+	char *v = shmbuf, *s = shm;
+	int count = 0;
+
+	while(*s != '\0')
+	{
+		*v++ = *s++;
+		*v = '\0';
+		count++;
+		if(*s == ';')
+		{
+			if(count >= buflen-1)
+				break;
+			s++;
+			*v++ = '\n';
+			count++;
+                }
+		if(count >= buflen-1)
+			break;
+	}
+	*v = '\0';
+
+	return 0;
+}
+
+#endif
diff -Nur enigma2-nightly/lib/base/estring.cpp enigma2-nightly.spark/lib/base/estring.cpp
--- enigma2-nightly/lib/base/estring.cpp	2010-08-11 18:16:49.550745342 +0800
+++ enigma2-nightly.spark/lib/base/estring.cpp	2010-08-11 18:12:24.888735071 +0800
@@ -5,6 +5,7 @@
 #include <lib/base/eerror.h>
 #include <lib/base/encoding.h>
 #include <lib/base/estring.h>
+#include "freesatv2.h"
 
 std::string buildShortName( const std::string &str )
 {
@@ -151,6 +152,8 @@
 0x00E0, 0x00E1, 0x00E2, 0x0103, 0x00E4, 0x0107, 0x00E6, 0x00E7, 0x00E8, 0x00E9, 0x00EA, 0x00EB, 0x00EC, 0x00ED, 0x00EE, 0x00EF,
 0x0111, 0x0144, 0x00F2, 0x00F3, 0x00F4, 0x0151, 0x00F6, 0x015B, 0x0171, 0x00F9, 0x00FA, 0x00FB, 0x00FC, 0x0119, 0x021B, 0x00FF};
 
+static freesatHuffmanDecoder huffmanDecoder;
+
 static unsigned long iso6397[96]={
 0x00A0, 0x00A1, 0x00A2, 0x00A3, 0x20AC, 0x00A5, 0x0000, 0x00A7, 0x00A4, 0x2018, 0x201C, 0x00AB, 0x2190, 0x2191, 0x2192, 0x2193,
 0x00B0, 0x00B1, 0x00B2, 0x00B3, 0x00D7, 0x00B5, 0x00B6, 0x00B7, 0x00F7, 0x2019, 0x201D, 0x00BB, 0x00BC, 0x00BD, 0x00BE, 0x00BF,
@@ -416,9 +419,24 @@
 			break;
 		case 0x15: // UTF-8 encoding of ISO/IEC 10646-1
 			return std::string((char*)data+1, len-1);
+		case 0x1F:
+			{
+				// Attempt to decode Freesat Huffman encoded string
+				unsigned char *temp = (unsigned char *) huffmanDecoder.decode(data, len);
+				if (temp)
+				{
+					int newlen = strlen((char*) temp);
+					std::string decoded_string = convertDVBUTF8(temp, newlen, table, tsidonid);
+					free(temp);
+					return decoded_string;
+				}
+			}
+			i++;
+			eDebug("failed to decode bbc freesat huffman");
+			break;
 		case 0x0:
 		case 0xC ... 0xF:
-		case 0x16 ... 0x1F:
+		case 0x16 ... 0x1E:
 			eDebug("reserved %d", data[0]);
 			++i;
 			break;
diff -Nur enigma2-nightly/lib/base/filepush.cpp enigma2-nightly.spark/lib/base/filepush.cpp
--- enigma2-nightly/lib/base/filepush.cpp	2010-08-11 18:16:49.551788011 +0800
+++ enigma2-nightly.spark/lib/base/filepush.cpp	2010-08-11 18:12:24.762548603 +0800
@@ -4,6 +4,20 @@
 #include <fcntl.h>
 #include <sys/ioctl.h>
 
+#if defined(__sh__) 
+#include <sys/vfs.h>
+#include "include/shmE2.h"
+
+#define USBDEVICE_SUPER_MAGIC 0x9fa2 
+#define EXT2_SUPER_MAGIC      0xEF53 
+#define EXT3_SUPER_MAGIC      0xEF53 
+#define SMB_SUPER_MAGIC       0x517B 
+#define NFS_SUPER_MAGIC       0x6969 
+#define MSDOS_SUPER_MAGIC     0x4d44            /* MD */
+
+extern char *shm;
+#endif
+
 #define PVR_COMMIT 1
 
 //FILE *f = fopen("/log.ts", "wb");
@@ -37,6 +51,11 @@
 	
 	size_t written_since_last_sync = 0;
 
+#ifdef __sh__
+	int file_count = 1;
+	unsigned long long total_bytes_written = 0;
+#endif
+
 	eDebug("FILEPUSH THREAD START");
 	
 		/* we set the signal to not restart syscalls, so we can detect our signal. */
@@ -49,7 +68,15 @@
 	
 	source_pos = m_raw_source.lseek(0, SEEK_CUR);
 	
+#if defined(__sh__)
+//Changes in this file are cause e2 doesnt tell the player to play reverse
+//No idea how this is handeld in dm drivers
+	int fd_video = open("/dev/dvb/adapter0/video0", O_RDONLY);
+#endif
 		/* m_stop must be evaluated after each syscall. */
+		
+	bool already_empty=false;
+		
 	while (!m_stop)
 	{
 			/* first try flushing the bufptr */
@@ -110,7 +137,11 @@
 			{
 				if (errno == EINTR || errno == EAGAIN || errno == EBUSY)
 					continue;
+#ifdef __sh__
+				eDebug("eFilePushThread WRITE ERROR (errno=%d, errstr=%s)", errno, strerror(errno));
+#else
 				eDebug("eFilePushThread WRITE ERROR");
+#endif
 				sendEvent(evtWriteError);
 				break;
 				// ... we would stop the thread
@@ -126,6 +157,37 @@
 				dest_pos -= toflush;
 				posix_fadvise(m_fd_dest, dest_pos, toflush, POSIX_FADV_DONTNEED);
 				written_since_last_sync -= toflush;
+#ifdef __sh__
+				//split file only after sync
+				if (m_record_split_size)
+				{
+					total_bytes_written += toflush;
+					if(total_bytes_written > m_record_split_size)
+					{
+						char filename[255];
+
+						close(m_fd_dest);
+						total_bytes_written = 0;
+						written_since_last_sync = 0;
+
+						if(m_record_split_type)
+							snprintf(filename, 255, "%s.%03d.ts", m_filename, file_count++);
+						else
+							snprintf(filename, 255, "%s.%03d", m_filename, file_count++);
+
+						eDebug("split record file - Recording to %s...", filename);
+
+						m_fd_dest = open(filename, m_flags, 0644);
+						if (m_fd_dest == -1)
+						{
+							eDebug("split record file - can't open recording file!");
+						}
+
+						/* turn off kernel caching strategies */
+						posix_fadvise(m_fd_dest, 0, 0, POSIX_FADV_RANDOM);
+					}
+				}
+#endif
 			}
 
 //			printf("FILEPUSH: wrote %d bytes\n", w);
@@ -137,6 +199,19 @@
 			
 		if (m_sg && !current_span_remaining)
 		{
+#if defined (__sh__)
+#define VIDEO_DISCONTINUITY             _IO('o',  84)
+#define DVB_DISCONTINUITY_SKIP  0x01
+#define DVB_DISCONTINUITY_CONTINUOUS_REVERSE  0x02
+			if((m_sg->getSkipMode() != 0))
+			{
+				// inform the player about the jump in the stream data
+				// this only works if the video device allows the discontinuity ioctl in read-only mode (patched)
+				int param = DVB_DISCONTINUITY_SKIP; // | DVB_DISCONTINUITY_CONTINUOUS_REVERSE;
+				int rc = ioctl(fd_video, VIDEO_DISCONTINUITY, (void*)param);
+				//eDebug("VIDEO_DISCONTINUITY (fd %d, rc %d)", fd_video, rc);
+			}
+#endif
 			m_sg->getNextSourceSpan(source_pos, bytes_read, current_span_offset, current_span_remaining);
 			ASSERT(!(current_span_remaining % m_blocksize));
 
@@ -194,7 +269,15 @@
 				{
 					case 0:
 						eDebug("wait for driver eof timeout");
-						continue;
+						if(already_empty)
+						{
+							break;
+						}
+						else
+						{
+							already_empty=true;
+							continue;
+						}
 					case 1:
 						eDebug("wait for driver eof ok");
 						break;
@@ -227,6 +310,7 @@
 			break;
 		} else
 		{
+			already_empty=false;
 			source_pos += m_buf_end;
 			bytes_read += m_buf_end;
 			if (m_sg)
@@ -235,10 +319,65 @@
 //		printf("FILEPUSH: read %d bytes\n", m_buf_end);
 	}
 	fdatasync(m_fd_dest);
+#if defined(__sh__)
+	close(fd_video);
+#endif
 
 	eDebug("FILEPUSH THREAD STOP");
 }
 
+#ifdef __sh__
+void eFilePushThread::start(int fd_source, int fd_dest, const char *filename)
+{
+	struct statfs sbuf;
+
+	m_raw_source.setfd(fd_source);
+	m_fd_dest = fd_dest;
+
+	m_record_split_size = 0;
+	m_record_split_type = 0;
+	m_flags = O_WRONLY|O_CREAT|O_LARGEFILE;
+
+	char record_split_size[3] = "";
+	getshmentry(shm, "record_split_size=", record_split_size, 3);
+	m_record_split_size = atoi(record_split_size);
+	m_record_split_size = m_record_split_size * 1000 * 1000 * 1000;
+	
+	char record_split_type[2] = "";
+	getshmentry(shm, "record_split_type=", record_split_type, 2);
+	m_record_split_type = atoi(record_split_type);
+
+	m_filename[0] = NULL;
+	strcpy(m_filename, filename);
+
+	if (statfs(m_filename, &sbuf) < 0)
+	{
+		eDebug("split record file - can't get fs type assuming none NFS!");
+	} else
+	{
+		if (sbuf.f_type == EXT3_SUPER_MAGIC)
+			eDebug("split record file - Ext2/3/4 Filesystem\n");
+		else
+		if (sbuf.f_type == NFS_SUPER_MAGIC)
+		{
+			eDebug("split record file - NFS Filesystem; add O_DIRECT to flags\n");
+			m_flags |= O_DIRECT;
+		}
+		else
+		if (sbuf.f_type == USBDEVICE_SUPER_MAGIC)
+			eDebug("split record file - USB Device\n");
+		else
+		if (sbuf.f_type == SMB_SUPER_MAGIC)
+			eDebug("split record file - SMBs Device\n");
+		else
+		if (sbuf.f_type == MSDOS_SUPER_MAGIC)
+			eDebug("split record file - MSDOS Device\n");
+	}
+
+	resume();
+}
+#endif
+
 void eFilePushThread::start(int fd_source, int fd_dest)
 {
 	m_raw_source.setfd(fd_source);
diff -Nur enigma2-nightly/lib/base/filepush.h enigma2-nightly.spark/lib/base/filepush.h
--- enigma2-nightly/lib/base/filepush.h	2010-08-11 18:16:49.551788011 +0800
+++ enigma2-nightly.spark/lib/base/filepush.h	2010-08-11 18:12:24.899466552 +0800
@@ -13,6 +13,11 @@
 public:
 	virtual void getNextSourceSpan(off_t current_offset, size_t bytes_read, off_t &start, size_t &size)=0;
 	virtual ~iFilePushScatterGather() {}
+#if defined(__sh__)
+	//Changes in this file are cause e2 doesnt tell the player to play reverse
+	//No idea how this is handeld in dm drivers
+	virtual int getSkipMode()=0;
+#endif
 };
 
 class eFilePushThread: public eThread, public Object
@@ -23,6 +28,9 @@
 	void thread();
 	void stop();
 	void start(int sourcefd, int destfd);
+#ifdef __sh__
+	void start(int sourcefd, int destfd, const char *filename);
+#endif
 	int start(const char *filename, int destfd);
 	
 	void pause();
@@ -51,7 +59,16 @@
 private:
 	iFilePushScatterGather *m_sg;
 	int m_stop;
-	unsigned char m_buffer[65536];
+#if defined(__sh__)
+        //align buffer to standard blocksize of 188
+        unsigned char m_buffer[348*188];
+	unsigned long long m_record_split_size;
+	int m_record_split_type;
+	char m_filename[256];
+	int m_flags;
+#else
+        unsigned char m_buffer[65536];
+#endif
 	int m_buf_start, m_buf_end, m_filter_end;
 	int m_fd_dest;
 	int m_send_pvr_commit;
diff -Nur enigma2-nightly/lib/base/freesatv2.cpp enigma2-nightly.spark/lib/base/freesatv2.cpp
--- enigma2-nightly/lib/base/freesatv2.cpp	1970-01-01 08:00:00.000000000 +0800
+++ enigma2-nightly.spark/lib/base/freesatv2.cpp	2010-08-11 18:12:24.890473506 +0800
@@ -0,0 +1,278 @@
+/* 
+FreeSat Huffman decoder for VDR
+Copyright (C) 2008  DOM http://www.rst38.org.uk/vdr/
+Port to C++ / Enigma 2
+Copyright (C) 2008  Martin Croome
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+*/
+
+#include "freesatv2.h"
+
+freesatHuffmanDecoder::freesatHuffmanDecoder() : m_tablesLoaded(false)
+{
+	int	i;
+
+	eDebug("[FREESAT] Init tables");
+	for ( i = 0 ; i < 256; i++ ) 
+	{
+		m_tables[0][i] = NULL;
+		m_tables[1][i] = NULL;
+	}
+}
+
+freesatHuffmanDecoder::~freesatHuffmanDecoder()
+{
+	int	i, j;
+	huffTableEntry *currentEntry, *nextEntry;
+	for ( j = 0 ; j < 2; j++ )
+	{ 
+		for ( i = 0 ; i < 256; i++ ) 
+		{
+			currentEntry = m_tables[j][i];
+			while ( currentEntry != NULL )
+			{
+				nextEntry = currentEntry->nextEntry;
+				delete currentEntry;
+				currentEntry = nextEntry;
+			}
+			m_tables[j][i] = NULL;
+		}
+	}
+}
+
+void freesatHuffmanDecoder::loadTables()
+{
+	if (! m_tablesLoaded )
+	{
+		eDebug("[FREESAT] Load tables");
+		loadFile(1, TABLE1_FILENAME);
+		loadFile(2, TABLE2_FILENAME);
+		m_tablesLoaded = true;
+	}
+}
+
+
+/** \brief Convert a textual character description into a value
+*
+*  \param str - Encoded (in someway) string
+*
+*  \return Raw character
+*/
+unsigned char freesatHuffmanDecoder::resolveChar(char *str)
+{
+	int val;
+
+	if (str[1] == 0) return str[0];
+
+	if ( strcmp(str,"ESCAPE") == 0 )
+	{
+		return ESCAPE;
+	}
+	else if ( strcmp(str,"STOP") == 0 )
+	{
+		return STOP;
+	}
+	else if ( strcmp(str,"START") == 0 )
+	{
+		return START;
+	}
+	else if ( sscanf(str,"0x%02x", &val) == 1 )
+	{
+		return val;
+	}
+	return str[0];
+}
+
+
+/** \brief Decode a binary string into a value
+*
+*  \param binary - Binary string to decode
+*
+*  \return Decoded value
+*/
+unsigned long freesatHuffmanDecoder::decodeBinary(char *binary)
+{
+	unsigned long mask = 0x80000000;
+	unsigned long val = 0;
+	size_t i, len = strlen(binary);
+
+	for ( i = 0; i < len; i++ )
+	{
+		if ( binary[i] == '1' )
+		{
+			val |= mask;
+		}
+		mask >>= 1;
+	}
+	return val;
+}
+
+/** \brief Load an individual freesat data file
+*
+*  \param tableid   - Table id that should be loaded
+*  \param filename  - Filename to load
+*/
+void freesatHuffmanDecoder::loadFile(int tableid, char *filename)
+{
+	char     buf[1024];
+	char    *from, *to, *binary;
+	FILE    *fp;
+
+	tableid--;
+
+	if ( ( fp = fopen(filename,"r") ) != NULL )
+	{
+		eDebug("[FREESAT] Loading table %d Filename <%s>",tableid + 1, filename);
+
+		while ( fgets(buf,sizeof(buf),fp) != NULL )
+		{
+			from = binary = to = NULL;
+			int elems = sscanf(buf,"%a[^:]:%a[^:]:%a[^:]:", &from, &binary, &to);
+			if ( elems == 3 )
+			{
+				int bin_len = strlen(binary);
+				int from_char = resolveChar(from);
+				char to_char = resolveChar(to);
+				unsigned long bin = decodeBinary(binary);
+
+				// Add entry to end of bucket
+				huffTableEntry **pCurrent = &m_tables[tableid][from_char];
+				while ( *pCurrent != NULL )
+				{
+					pCurrent = &((*pCurrent)->nextEntry);
+				}
+				*pCurrent = new huffTableEntry(bin, bin_len, to_char, NULL);
+			}
+			free(from);
+			free(to);
+			free(binary);
+		}
+		fclose(fp);
+	}
+	else
+	{
+		eDebug("[FREESAT] Cannot load <%s> for table %d",filename,tableid + 1);
+	}
+}
+
+
+/** \brief Decode an EPG string as necessary
+*
+*  \param src - Possibly encoded string
+*  \param size - Size of the buffer
+*
+*  \retval NULL - Can't decode
+*  \return A decoded string
+*/
+char  *freesatHuffmanDecoder::decode( const unsigned char *src, size_t size)
+{
+	int tableid;
+
+	loadTables();
+
+	if (src[0] == 0x1f && (src[1] == 1 || src[1] == 2))
+	{
+		int    uncompressed_len = 30;
+		char * uncompressed = (char *)calloc(1,uncompressed_len + 1);
+		unsigned value = 0, byte = 2, bit = 0;
+		int p = 0;
+		int lastch = START;
+
+		tableid = src[1] - 1;
+		while (byte < 6 && byte < size)
+		{
+			value |= src[byte] << ((5-byte) * 8);
+			byte++;
+		}
+
+		do
+		{
+			int found = 0;
+			unsigned bitShift = 0;
+			if (lastch == ESCAPE)
+			{
+				char nextCh = (value >> 24) & 0xff;
+				found = 1;
+				// Encoded in the next 8 bits.
+				// Terminated by the first ASCII character.
+				bitShift = 8;
+				if ((nextCh & 0x80) == 0)
+					lastch = nextCh;
+				if (p >= uncompressed_len)
+				{
+					uncompressed_len += 10;
+					uncompressed = (char *)realloc(uncompressed, uncompressed_len + 1);
+				}
+				uncompressed[p++] = nextCh;
+				uncompressed[p] = 0;
+			}
+			else
+			{
+				huffTableEntry * currentEntry = m_tables[tableid][lastch];
+				while ( currentEntry != NULL )
+				{
+					unsigned mask = 0, maskbit = 0x80000000;
+					short kk;
+					for ( kk = 0; kk < currentEntry->bits; kk++)
+					{
+						mask |= maskbit;
+						maskbit >>= 1;
+					}
+					if ((value & mask) == currentEntry->value)
+					{
+						char nextCh = currentEntry->next;
+						bitShift = currentEntry->bits;
+						if (nextCh != STOP && nextCh != ESCAPE)
+						{
+							if (p >= uncompressed_len)
+							{
+								uncompressed_len += 10;
+								uncompressed = (char *)realloc(uncompressed, uncompressed_len + 1);
+							}
+							uncompressed[p++] = nextCh;
+							uncompressed[p] = 0;
+						}
+						found = 1;
+						lastch = nextCh;
+						break;
+					}
+					currentEntry = currentEntry->nextEntry;
+				}
+			}
+			if (found)
+			{
+				// Shift up by the number of bits.
+				unsigned b;
+				for ( b = 0; b < bitShift; b++)
+				{
+					value = (value << 1) & 0xfffffffe;
+					if (byte < size)
+						value |= (src[byte] >> (7-bit)) & 1;
+					if (bit == 7)
+					{
+						bit = 0;
+						byte++;
+					}
+					else bit++;
+				}
+			}
+			else
+			{
+				eDebug("[FREESAT] Missing table %d entry: <%s>", tableid + 1, uncompressed);
+				return uncompressed;
+			}
+		} while (lastch != STOP && value != 0);
+
+		return uncompressed;
+	}
+	return NULL;
+}
diff -Nur enigma2-nightly/lib/base/freesatv2.h enigma2-nightly.spark/lib/base/freesatv2.h
--- enigma2-nightly/lib/base/freesatv2.h	1970-01-01 08:00:00.000000000 +0800
+++ enigma2-nightly.spark/lib/base/freesatv2.h	2010-08-11 18:12:24.890473506 +0800
@@ -0,0 +1,48 @@
+#ifndef FREESAT_H
+#define FREESAT_H
+
+#include <stdlib.h> 
+#include <string.h>
+#include <stdio.h>
+#include <unistd.h>
+
+#include <lib/base/ebase.h>
+
+#define START   '\0' 
+#define STOP    '\0' 
+#define ESCAPE  '\1' 
+
+#ifndef FREESAT_DATA_DIRECTORY
+#define FREESAT_DATA_DIRECTORY       DATADIR
+#endif
+#define TABLE1_FILENAME FREESAT_DATA_DIRECTORY "/enigma2/freesat.t1"
+#define TABLE2_FILENAME FREESAT_DATA_DIRECTORY "/enigma2/freesat.t2"
+
+class huffTableEntry {
+	friend class freesatHuffmanDecoder;
+private: 
+	__u32 value; 
+	__u16 bits; 
+	char next;
+	huffTableEntry * nextEntry;
+public: 
+	huffTableEntry(unsigned int value, short bits, char next, huffTableEntry * nextEntry) : value(value), bits(bits), next(next), nextEntry(nextEntry)
+	{ }
+};
+
+class freesatHuffmanDecoder 
+{
+private:
+	huffTableEntry	*m_tables[2][256];
+	void 		loadFile(int tableid, char *filename);
+	unsigned char 	resolveChar(char *str);
+	unsigned long 	decodeBinary(char *binary);
+	void 		loadTables();
+	bool		m_tablesLoaded;
+public:
+	freesatHuffmanDecoder();
+	~freesatHuffmanDecoder();
+	char		*decode( const unsigned char *src, size_t size);
+};
+#endif
+
diff -Nur enigma2-nightly/lib/base/ioprio.cpp enigma2-nightly.spark/lib/base/ioprio.cpp
--- enigma2-nightly/lib/base/ioprio.cpp	2010-08-11 18:16:49.552791117 +0800
+++ enigma2-nightly.spark/lib/base/ioprio.cpp	2010-08-11 18:12:24.765545647 +0800
@@ -28,6 +28,9 @@
 	#elif defined(__mips__)
 		#define __NR_ioprio_set		4284
 		#define __NR_ioprio_get		4285
+	#elif defined(__sh__) 
+		#define __NR_ioprio_set         288 
+		#define __NR_ioprio_get         289 
 	#else
 		#error "Unsupported arch"
 	#endif
diff -Nur enigma2-nightly/lib/base/Makefile.am enigma2-nightly.spark/lib/base/Makefile.am
--- enigma2-nightly/lib/base/Makefile.am	2010-08-11 18:16:49.545778085 +0800
+++ enigma2-nightly.spark/lib/base/Makefile.am	2010-08-11 18:12:24.891661044 +0800
@@ -8,5 +8,5 @@
 	init.cpp message.cpp thread.cpp \
 	smartptr.cpp estring.cpp connection.cpp \
 	filepush.cpp encoding.cpp console.cpp rawfile.cpp \
-	nconfig.cpp ioprio.cpp
+	nconfig.cpp ioprio.cpp freesatv2.cpp
 
diff -Nur enigma2-nightly/lib/base/object.h enigma2-nightly.spark/lib/base/object.h
--- enigma2-nightly/lib/base/object.h	2010-08-11 18:16:49.553803710 +0800
+++ enigma2-nightly.spark/lib/base/object.h	2010-08-11 18:12:24.767447751 +0800
@@ -169,6 +169,50 @@
 				if (!ref) \
 					delete this; \
 			}
+	#elif defined(__sh__)
+		#define DECLARE_REF(x)                  \
+			private: oRefCount ref;         \
+			public: void AddRef();          \
+					void Release();
+		#define DEFINE_REF(c) \
+			void c::AddRef() \
+			{ \
+				int tmp; \
+				volatile int* v = &(ref.count);\
+       				asm volatile( \
+                		"   .align 2              \n\t" \
+                		"   mova    1f,   r0      \n\t" \
+                		"   mov    r15,   r1      \n\t" \
+                		"   mov    #-6,   r15     \n\t" \
+                		"   mov.l  @%1,   %0      \n\t" \
+                		"   add     #1,   %0      \n\t" \
+                		"   mov.l   %0,   @%1     \n\t" \
+                		"1: mov     r1,   r15     \n\t" \
+                		: "=&r" (tmp),      \
+                  		  "+r"  (v) \
+				:                   \
+                		: "memory" , "r0", "r1" ); \
+			} \
+			void c::Release() \
+			{ \
+				int tmp; \
+				volatile int* v = &(ref.count);\
+			        asm volatile( \
+                		"   .align 2              \n\t" \
+		                "   mova    1f,   r0      \n\t" \
+                		"   mov    r15,   r1      \n\t" \
+ 		                "   mov    #-6,   r15     \n\t" \
+		                "   mov.l  @%1,   %0      \n\t" \
+		                "   add    #-1,   %0      \n\t" \
+		                "   mov.l   %0,   @%1     \n\t" \
+		                "1: mov     r1,   r15     \n\t" \
+		                : "=&r" (tmp),      \
+		                  "+r"  (v) \
+				:                   \
+		                : "memory" , "r0", "r1" ); \
+				if (!ref) \
+					delete this; \
+			}
 	#else
 		#warning use non optimized implementation of refcounting.
 		#define DECLARE_REF(x) 			\
diff -Nur enigma2-nightly/lib/driver/Makefile.am enigma2-nightly.spark/lib/driver/Makefile.am
--- enigma2-nightly/lib/driver/Makefile.am	2010-08-11 18:16:49.555743245 +0800
+++ enigma2-nightly.spark/lib/driver/Makefile.am	2010-08-11 18:12:24.768788369 +0800
@@ -4,4 +4,4 @@
 noinst_LIBRARIES = libenigma_driver.a
 
 libenigma_driver_a_SOURCES = \
-	rc.cpp rcinput.cpp rcconsole.cpp avswitch.cpp rfmod.cpp etimezone.cpp misc_options.cpp
+	rc.cpp rcinput.cpp rcconsole.cpp avswitch.cpp rfmod.cpp etimezone.cpp misc_options.cpp vfd.cpp
diff -Nur enigma2-nightly/lib/driver/rc.cpp enigma2-nightly.spark/lib/driver/rc.cpp
--- enigma2-nightly/lib/driver/rc.cpp	2010-08-11 18:16:49.557911898 +0800
+++ enigma2-nightly.spark/lib/driver/rc.cpp	2010-08-11 18:12:24.848701096 +0800
@@ -10,6 +10,11 @@
 #include <lib/base/init_num.h>
 #include <lib/base/eerror.h>
 
+#ifdef __sh__
+#include "include/shmE2.h"
+extern char *shm;
+#endif
+
 /*
  *  note on the enigma input layer:
  *  the enigma input layer (rc*) supports n different devices which
@@ -64,6 +69,10 @@
 	{
 		if (read(handle, &rccode, 2)!=2)
 			break;
+#ifdef __sh__
+		if(checkshmentry(shm, "stopRC=") == 1)
+			continue;
+#endif
 		if (enabled && !input->islocked())
 			for (std::list<eRCDevice*>::iterator i(listeners.begin()); i!=listeners.end(); ++i)
 				(*i)->handleCode(rccode);
@@ -97,6 +106,10 @@
 	{
 		if (read(handle, &ev, sizeof(struct input_event))!=sizeof(struct input_event))
 			break;
+#ifdef __sh__
+		if(checkshmentry(shm, "stopRC=") == 1)
+			continue;
+#endif
 		if (enabled && !input->islocked())
 			for (std::list<eRCDevice*>::iterator i(listeners.begin()); i!=listeners.end(); ++i)
 				(*i)->handleCode((long)&ev);
diff -Nur enigma2-nightly/lib/driver/vfd.cpp enigma2-nightly.spark/lib/driver/vfd.cpp
--- enigma2-nightly/lib/driver/vfd.cpp	1970-01-01 08:00:00.000000000 +0800
+++ enigma2-nightly.spark/lib/driver/vfd.cpp	2010-08-11 18:12:24.770080368 +0800
@@ -0,0 +1,376 @@
+#include <stdarg.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <sys/ioctl.h>
+#include <ctype.h>
+#include <sys/stat.h>
+#include  <pthread.h> 
+
+#include <lib/base/eerror.h>
+#include <lib/driver/vfd.h>
+
+#ifdef PLATFORM_TF7700
+#include "../../misc/tools/tffpctl/frontpanel.h"
+#endif
+
+#define VFD_DEVICE "/dev/vfd"
+#define VFDICONDISPLAYONOFF	0xc0425a0a
+#define	VFDDISPLAYCHARS 	0xc0425a00
+#define VFDBRIGHTNESS           0xc0425a03
+//light on off
+#define VFDDISPLAYWRITEONOFF    0xc0425a05
+
+bool startloop_running = false;
+static bool icon_onoff[32];
+static pthread_t thread_start_loop = 0;
+void * start_loop (void *arg);
+bool blocked = false;
+bool requested = false;
+char chars[64];
+
+
+struct vfd_ioctl_data {
+	unsigned char start;
+	unsigned char data[64];
+	unsigned char length;
+};
+
+
+
+evfd* evfd::instance = NULL;
+
+evfd* evfd::getInstance()
+{
+	if (instance == NULL)
+		instance = new evfd;
+	return instance;
+}
+
+
+evfd::evfd()
+{
+	file_vfd = 0;
+	memset ( chars, ' ', 63 );
+}
+
+void evfd::init()
+{
+	pthread_create (&thread_start_loop, NULL, &start_loop, NULL);	
+	return;
+}
+
+evfd::~evfd()
+{
+	//close (file_vfd);
+}
+
+#ifdef PLATFORM_TF7700
+char * getProgress()
+{
+	int n;
+	static char progress[20] = "0";
+	int fd = open ("/proc/progress", O_RDONLY);
+
+	if(fd < 0)
+		return 0;
+
+	n = read(fd, progress, sizeof(progress));
+	close(fd);
+
+	if(n < 0)
+		n = 0;
+	else if((n > 1) && (progress[n-1] == 0xa))
+		n--;
+
+	progress[n] = 0;
+
+	return progress;
+}
+
+#define MAX_CHARS 8
+
+void * start_loop (void *arg)
+{
+	int fplarge = open ("/dev/fplarge", O_WRONLY);
+	int fpsmall = open ("/dev/fpsmall", O_WRONLY);
+	int fpc = open ("/dev/fpc", O_WRONLY);
+
+	if((fplarge < 0) || (fpsmall < 0) || (fpc < 0))
+	{
+		printf("Failed opening devices (%d, %d, %d)\n",
+					fplarge, fpsmall, fpc);
+		return NULL;
+	}
+
+	blocked = true;
+
+	// set scroll mode
+	//frontpanel_ioctl_scrollmode scrollMode = {2, 10, 15};
+	//ioctl(fpc, FRONTPANELSCROLLMODE, &scrollMode);
+	
+	// display string
+	char str[] = "        TEAM DUCKTALES ENIGMA2";
+	int length = strlen(str);
+	char dispData[MAX_CHARS + 1];
+	int offset = 0;
+	int i;
+
+	frontpanel_ioctl_icons icons = {0, 0, 0xf};
+
+	// start the display loop
+	char * progress = getProgress();
+	int index = 2;
+	while(!requested)
+	{
+		// display the CD segments
+		icons.Icons2 = (((1 << index) - 1)) & 0x1ffe;
+		ioctl(fpc, FRONTPANELICON, &icons);
+		index++;
+		if(index > 13)
+		{
+			index = 2;
+			icons.BlinkMode = (~icons.BlinkMode) & 0xf;
+		}
+
+		// display the visible part of the string
+		for(i = 0; i < MAX_CHARS; i++)
+		{
+			dispData[i] = str[(offset + i) % length];
+		}
+		offset++;
+		write(fplarge, dispData, sizeof(dispData));
+		usleep(200000);
+		if((index % 4) == 0)
+		{
+		  // display progress
+		  progress = getProgress();
+		  write(fpsmall, progress, strlen(progress) + 1);
+		  if(strncmp("100", progress, 3) == 0)
+		    break;
+		}
+	}
+
+	// clear all icons
+	frontpanel_ioctl_icons iconsOff = {0xffffffff, 0xffffffff, 0x0};
+	ioctl(fpc, FRONTPANELICON, &iconsOff);
+
+	// clear display
+	write(fpsmall, "    ", 5);
+	write(fplarge, "        ", MAX_CHARS);
+
+	close(fplarge);
+	close(fpsmall);
+	close(fpc);
+	blocked = false;
+
+	return NULL;
+}
+
+#else
+
+void * start_loop (void *arg)
+{
+	evfd vfd;
+	blocked = true;
+	//vfd.vfd_clear_icons();
+	vfd.vfd_write_string(" Team Ducktales ", true);
+	//run 2 times through all icons 
+	for  (int vloop = 0; vloop < 128; vloop++) {
+		/*if (vloop%14 == 0 )
+			vfd.vfd_set_brightness(1);
+		else if (vloop%14 == 1 )
+			vfd.vfd_set_brightness(2);
+		else if (vloop%14 == 2 )
+			vfd.vfd_set_brightness(3);
+		else if (vloop%14 == 3 )
+			vfd.vfd_set_brightness(4);
+		else if (vloop%14 == 4 )
+			vfd.vfd_set_brightness(5);
+		else if (vloop%14 == 5 )
+			vfd.vfd_set_brightness(6);
+		else if (vloop%14 == 6 )
+			vfd.vfd_set_brightness(7);
+		else if (vloop%14 == 7 )
+			vfd.vfd_set_brightness(6);
+		else if (vloop%14 == 8 )
+			vfd.vfd_set_brightness(5);
+		else if (vloop%14 == 9 )
+			vfd.vfd_set_brightness(4);
+		else if (vloop%14 == 10 )
+			vfd.vfd_set_brightness(3);
+		else if (vloop%14 == 11 )
+			vfd.vfd_set_brightness(2);
+		else if (vloop%14 == 12 )
+			vfd.vfd_set_brightness(1);
+		else if (vloop%14 == 13 )
+			vfd.vfd_set_brightness(0);*/
+		if (vloop%2 == 1) {
+			vfd.vfd_set_icon( (tvfd_icon) (((vloop%32)/2)%16), ICON_OFF, true);
+			//usleep(1000);
+			vfd.vfd_set_icon( (tvfd_icon) ((((vloop%32)/2)%16)+1), ICON_ON, true);
+		}
+		usleep(75000);
+	}
+	vfd.vfd_set_brightness(7);
+	
+	//set all blocked icons
+	for (int id = 0x10; id < 0x20; id++) {
+		vfd.vfd_set_icon((tvfd_icon)id, icon_onoff[id]);	
+	}
+
+	blocked = false;
+	return NULL;
+}
+
+#endif
+
+//////////////////////////////////////////////////////////////////////////////////////
+
+void evfd::vfd_write_string(char * str)
+{
+	vfd_write_string(str, false);
+}
+
+void evfd::vfd_write_string(char * str, bool force)
+{
+	int i;
+	i = strlen ( str );
+	if ( i > 63 ) i = 63;
+	memset ( chars, ' ', 63 );
+	memcpy ( chars, str, i);	
+
+#ifdef PLATFORM_TF7700
+
+	// request the display to cancel the start loop
+	requested = true;
+	while(blocked) usleep(200000);
+
+	{
+#else
+	if (!blocked || force) {
+#endif
+		struct vfd_ioctl_data data;
+		memset ( data.data, ' ', 63 );
+		memcpy ( data.data, str, i );	
+
+		data.start = 0;
+		data.length = i;
+
+		file_vfd = open (VFD_DEVICE, O_WRONLY);
+		ioctl ( file_vfd, VFDDISPLAYCHARS, &data );
+		close (file_vfd);
+	}
+	return;
+}
+
+void evfd::vfd_write_string_scrollText(char* text) {
+	if (!blocked) {
+		int i, len = strlen(text);
+		char* out = (char *) malloc(16);
+
+		for (i=0; i<=(len-16); i++) { // scroll text till end
+			memset(out, ' ', 16);
+			memcpy(out, text+i, 16);
+			vfd_write_string(out);
+			usleep(200000);
+		}
+		for (i=1; i<16; i++) { // scroll text with whitespaces from right
+			memset(out, ' ', 16);
+			memcpy(out, text+len+i-16, 16-i);
+			vfd_write_string(out);
+			usleep(200000);
+		}
+
+		memcpy(out, text, 16); // display first 16 chars after scrolling
+		vfd_write_string(out);
+		free (out);
+	}
+	return;
+}
+
+void evfd::vfd_clear_string()
+{
+	vfd_write_string("                ");
+	return;
+}
+
+//////////////////////////////////////////////////////////////////////////////////////
+
+void evfd::vfd_set_icon(tvfd_icon id, bool onoff)
+{
+	vfd_set_icon(id, onoff, false);
+	return;
+}
+
+void evfd::vfd_set_icon(tvfd_icon id, bool onoff, bool force)
+{
+	icon_onoff[id] = onoff;
+
+	if (!blocked || force) {
+		struct vfd_ioctl_data data;
+
+		if (!startloop_running) {
+			memset(&data, 0, sizeof(struct vfd_ioctl_data));
+
+			data.start = 0x00;
+    			data.data[0] = id & 0x0f;
+    			data.data[4] = onoff;
+    			data.length = 5;
+
+			file_vfd = open (VFD_DEVICE, O_WRONLY);
+    			ioctl(file_vfd, VFDICONDISPLAYONOFF, &data);
+			close (file_vfd);
+		}
+	}
+	return;
+}
+
+void evfd::vfd_clear_icons()
+{
+	for (int id = 0x10; id < 0x20; id++) {
+		vfd_set_icon((tvfd_icon)id, false);	
+	}
+	return;
+}
+
+//////////////////////////////////////////////////////////////////////////////////////
+
+void evfd::vfd_set_brightness(unsigned char setting)
+{
+	struct vfd_ioctl_data data;
+
+	memset(&data, 0, sizeof(struct vfd_ioctl_data));
+	
+	data.start = setting & 0x07;
+	data.length = 0;
+
+	file_vfd = open (VFD_DEVICE, O_WRONLY);
+	ioctl ( file_vfd, VFDBRIGHTNESS, &data );
+	close (file_vfd);
+
+	return;
+}
+
+
+void evfd::vfd_set_light(bool onoff)
+{
+	struct vfd_ioctl_data data;
+
+	memset(&data, 0, sizeof(struct vfd_ioctl_data));
+
+	if (onoff)
+		data.start = 0x01;
+	else
+		data.start = 0x00;
+    	data.length = 0;
+
+	file_vfd = open (VFD_DEVICE, O_WRONLY);
+
+    	ioctl(file_vfd, VFDDISPLAYWRITEONOFF, &data);
+
+	close (file_vfd);
+	return;
+}
diff -Nur enigma2-nightly/lib/driver/vfd.h enigma2-nightly.spark/lib/driver/vfd.h
--- enigma2-nightly/lib/driver/vfd.h	1970-01-01 08:00:00.000000000 +0800
+++ enigma2-nightly.spark/lib/driver/vfd.h	2010-08-11 18:12:24.771638659 +0800
@@ -0,0 +1,40 @@
+#ifndef VFD_H_
+#define VFD_H_
+
+#define ICON_ON  1
+#define ICON_OFF 0
+
+typedef enum { USB = 0x10, HD, HDD, LOCK, BT, MP3, MUSIC, DD, MAIL, MUTE, PLAY, PAUSE, FF, FR, REC, CLOCK } tvfd_icon;
+
+class evfd
+{
+protected:
+	static evfd *instance;
+	int file_vfd;
+#ifdef SWIG
+	evfd();
+	~evfd();
+#endif
+public:
+#ifndef SWIG
+	evfd();
+	~evfd();
+#endif
+	void init();
+	static evfd* getInstance();
+
+	void vfd_set_icon(tvfd_icon id, bool onoff);
+	void vfd_set_icon(tvfd_icon id, bool onoff, bool force);
+	void vfd_clear_icons();
+
+	void vfd_write_string(char * string);
+	void vfd_write_string(char * str, bool force);
+	void vfd_write_string_scrollText(char* text);
+	void vfd_clear_string();
+	
+	void vfd_set_brightness(unsigned char setting);
+	void vfd_set_light(bool onoff);
+};
+
+
+#endif
diff -Nur enigma2-nightly/lib/dvb/decoder.cpp enigma2-nightly.spark/lib/dvb/decoder.cpp
--- enigma2-nightly/lib/dvb/decoder.cpp	2010-08-11 18:16:49.561763463 +0800
+++ enigma2-nightly.spark/lib/dvb/decoder.cpp	2010-08-11 18:12:24.774927944 +0800
@@ -166,7 +166,11 @@
 	pes.input    = DMX_IN_FRONTEND;
 	pes.output   = DMX_OUT_DECODER;
 	pes.pes_type = m_dev ? DMX_PES_AUDIO1 : DMX_PES_AUDIO0; /* FIXME */
+#ifdef __sh__
+        pes.flags    = DMX_IMMEDIATE_START;
+#else
 	pes.flags    = 0;
+#endif
 	eDebugNoNewLine("DMX_SET_PES_FILTER(0x%02x) - audio - ", pid);
 	if (::ioctl(m_fd_demux, DMX_SET_PES_FILTER, &pes) < 0)
 	{
@@ -174,6 +178,8 @@
 		return -errno;
 	}
 	eDebug("ok");
+
+#if !defined(__sh__)
 	eDebugNoNewLine("DEMUX_START - audio - ");
 	if (::ioctl(m_fd_demux, DMX_START) < 0)
 	{
@@ -181,6 +187,8 @@
 		return -errno;
 	}
 	eDebug("ok");
+#endif
+
 	int bypass = 0;
 
 	switch (type)
@@ -210,7 +218,10 @@
 		eDebug("failed (%m)");
 	else
 		eDebug("ok");
+
+#if !defined(__sh__)
 	freeze();  // why freeze here?!? this is a problem when only a pid change is requested... because of the unfreeze logic in Decoder::setState
+#endif
 	eDebugNoNewLine("AUDIO_PLAY - ");
 	if (::ioctl(m_fd, AUDIO_PLAY) < 0)
 		eDebug("failed (%m)");
@@ -436,7 +447,11 @@
 	pes.input    = DMX_IN_FRONTEND;
 	pes.output   = DMX_OUT_DECODER;
 	pes.pes_type = m_dev ? DMX_PES_VIDEO1 : DMX_PES_VIDEO0; /* FIXME */
+#ifdef __sh__
+	pes.flags    = DMX_IMMEDIATE_START;
+#else
 	pes.flags    = 0;
+#endif
 	eDebugNoNewLine("DMX_SET_PES_FILTER(0x%02x) - video - ", pid);
 	if (::ioctl(m_fd_demux, DMX_SET_PES_FILTER, &pes) < 0)
 	{
@@ -444,6 +459,7 @@
 		return -errno;
 	}
 	eDebug("ok");
+#if !defined(__sh__)
 	eDebugNoNewLine("DEMUX_START - video - ");
 	if (::ioctl(m_fd_demux, DMX_START) < 0)
 	{
@@ -452,6 +468,7 @@
 	}
 	eDebug("ok");
 	freeze();  // why freeze here?!? this is a problem when only a pid change is requested... because of the unfreeze logic in Decoder::setState
+#endif
 	eDebugNoNewLine("VIDEO_PLAY - ");
 	if (::ioctl(m_fd, VIDEO_PLAY) < 0)
 		eDebug("failed (%m)");
@@ -750,7 +767,11 @@
 	pes.input    = DMX_IN_FRONTEND;
 	pes.output   = DMX_OUT_DECODER;
 	pes.pes_type = m_dev ? DMX_PES_PCR1 : DMX_PES_PCR0; /* FIXME */
+#ifdef __sh__
+	pes.flags    = DMX_IMMEDIATE_START;
+#else
 	pes.flags    = 0;
+#endif
 	eDebugNoNewLine("DMX_SET_PES_FILTER(0x%02x) - pcr - ", pid);
 	if (::ioctl(m_fd_demux, DMX_SET_PES_FILTER, &pes) < 0)
 	{
@@ -758,6 +779,7 @@
 		return -errno;
 	}
 	eDebug("ok");
+#if !defined(__sh__)
 	eDebugNoNewLine("DEMUX_START - pcr - ");
 	if (::ioctl(m_fd_demux, DMX_START) < 0)
 	{
@@ -765,6 +787,7 @@
 		return -errno;
 	}
 	eDebug("ok");
+#endif
 	return 0;
 }
 #endif
@@ -810,7 +833,11 @@
 	pes.input    = DMX_IN_FRONTEND;
 	pes.output   = DMX_OUT_DECODER;
 	pes.pes_type = m_dev ? DMX_PES_TELETEXT1 : DMX_PES_TELETEXT0; // FIXME
+#ifdef __sh__
+	pes.flags    = DMX_IMMEDIATE_START;
+#else
 	pes.flags    = 0;
+#endif
 
 	eDebugNoNewLine("DMX_SET_PES_FILTER(0x%02x) - ttx - ", pid);
 	if (::ioctl(m_fd_demux, DMX_SET_PES_FILTER, &pes) < 0)
@@ -819,6 +846,7 @@
 		return -errno;
 	}
 	eDebug("ok");
+#if !defined(__sh__)
 	eDebugNoNewLine("DEMUX_START - ttx - ");
 	if (::ioctl(m_fd_demux, DMX_START) < 0)
 	{
@@ -826,6 +854,7 @@
 		return -errno;
 	}
 	eDebug("ok");
+#endif
 	return 0;
 }
 
@@ -1019,12 +1048,30 @@
 		int *s = state_table[m_state];
 		if (changed & (changeState|changeVideo) && m_video)
 		{
+#if not defined(__sh__) 
 			m_video->setSlowMotion(s[1]);
 			m_video->setFastForward(s[2]);
+#endif 
 			if (s[0])
 				m_video->unfreeze();
 			else
 				m_video->freeze();
+#if defined(__sh__) 
+/* 
+the VIDEO_CONTINUE would reset the FASTFORWARD  command so we 
+execute the FASTFORWARD after the VIDEO_CONTINUE
+*/ 
+			if(s[1])
+			{
+				m_video->setFastForward(s[2]);
+				m_video->setSlowMotion(s[1]);
+			}
+			else
+			{
+				m_video->setSlowMotion(s[1]);
+				m_video->setFastForward(s[2]);
+			}
+#endif 
 		}
 		if (changed & (changeState|changeAudio) && m_audio)
 		{
@@ -1101,9 +1148,11 @@
 eTSMPEGDecoder::~eTSMPEGDecoder()
 {
 	finishShowSinglePic();
+#if !defined(__sh__)
 	m_vpid = m_apid = m_pcrpid = m_textpid = pidNone;
 	m_changed = -1;
 	setState();
+#endif
 }
 
 RESULT eTSMPEGDecoder::setVideoPID(int vpid, int type)
@@ -1300,6 +1349,10 @@
 		{
 			struct stat s;
 			fstat(f, &s);
+#if defined(__sh__)  
+			if (m_video_clip_fd >= 0)  
+				finishShowSinglePic();  
+#endif  
 			if (m_video_clip_fd == -1)
 				m_video_clip_fd = open("/dev/dvb/adapter0/video0", O_WRONLY|O_NONBLOCK);
 			if (m_video_clip_fd >= 0)
@@ -1333,7 +1386,9 @@
 				if (!seq_end_avail)
 					write(m_video_clip_fd, seq_end, sizeof(seq_end));
 				write(m_video_clip_fd, stuffing, 8192);
+#if not defined(__sh__) 
 				m_showSinglePicTimer->start(150, true);
+#endif 
 			}
 			close(f);
 		}
diff -Nur enigma2-nightly/lib/dvb/demux.cpp enigma2-nightly.spark/lib/dvb/demux.cpp
--- enigma2-nightly/lib/dvb/demux.cpp	2010-08-11 18:16:49.562763492 +0800
+++ enigma2-nightly.spark/lib/dvb/demux.cpp	2010-08-11 18:12:24.898581838 +0800
@@ -526,6 +526,9 @@
 		eDebug("FAILED to open dvr (%s) in ts recoder (%m)", filename);
 		return -3;
 	}
+#if defined(__sh__) 
+	::ioctl(m_source_fd, DMX_SET_BUFFER_SIZE, 256*1024); 
+#endif
 #else
 	snprintf(filename, 128, "/dev/dvb/adapter%d/demux%d", m_demux->adapter, m_demux->demux);
 
@@ -566,7 +569,14 @@
 	if (m_target_filename != "")
 		m_thread->startSaveMetaInformation(m_target_filename);
 	
+#ifdef __sh__
+	if (m_target_filename != "")
+		m_thread->start(m_source_fd, m_target_fd, m_target_filename.c_str());
+	else
+		m_thread->start(m_source_fd, m_target_fd);
+#else
 	m_thread->start(m_source_fd, m_target_fd);
+#endif
 	m_running = 1;
 
 	while (i != m_pids.end()) {
diff -Nur enigma2-nightly/lib/dvb/dvb.cpp enigma2-nightly.spark/lib/dvb/dvb.cpp
--- enigma2-nightly/lib/dvb/dvb.cpp	2010-08-11 18:16:49.565794223 +0800
+++ enigma2-nightly.spark/lib/dvb/dvb.cpp	2010-08-11 18:13:17.452384000 +0800
@@ -96,6 +96,42 @@
 		m_boxtype = DM800;
 	else if (!strncmp(tmp, "dm500hd\n", rd))
 		m_boxtype = DM500HD;
+#if defined(__sh__)
+	else if (!strncmp(tmp, "ufs910\n", rd))
+		m_boxtype = UFS910;
+	else if (!strncmp(tmp, "ufs912\n", rd))
+		m_boxtype = UFS912;
+	else if (!strncmp(tmp, "ufs922\n", rd))
+		m_boxtype = UFS922;
+	else if (!strncmp(tmp, "tf7700hdpvr\n", rd))
+		m_boxtype = TF7700HDPVR;
+	else if (!strncmp(tmp, "hdbox\n", rd))
+		m_boxtype = HDBOX;
+	else if (!strncmp(tmp, "hl101\n", rd))
+		m_boxtype = HL101;
+	else if (!strncmp(tmp, "spark\n", rd))
+		m_boxtype = SPARK;
+	else if (!strncmp(tmp, "vip1-v2\n", rd))
+		m_boxtype = VIP1_V2;
+	else if (!strncmp(tmp, "vip2-v1\n", rd))
+		m_boxtype = VIP2_V1;
+	else if (!strncmp(tmp, "cuberevo\n", rd))
+		m_boxtype = CUBEREVO;
+	else if (!strncmp(tmp, "cuberevo-9500hd\n", rd))
+		m_boxtype = CUBEREVO_9500HD;
+	else if (!strncmp(tmp, "cuberevo-mini\n", rd))
+		m_boxtype = CUBEREVO_MINI;
+	else if (!strncmp(tmp, "cuberevo-mini2\n", rd))
+		m_boxtype = CUBEREVO_MINI2;
+	else if (!strncmp(tmp, "cuberevo-2000hd\n", rd))
+		m_boxtype = CUBEREVO_2000HD;
+	else if (!strncmp(tmp, "cuberevo-250hd\n", rd))
+		m_boxtype = CUBEREVO_250HD;
+	else if (!strncmp(tmp, "cuberevo-mini-fta\n", rd))
+		m_boxtype = CUBEREVO_MINI_FTA;
+	else if (!strncmp(tmp, "octagon1008\n", rd))
+		m_boxtype = OCTAGON1008;
+#endif
 	else {
 		eDebug("boxtype detection via /proc/stb/info not possible... use fallback via demux count!\n");
 		if (m_demux.size() == 3)
@@ -540,7 +576,58 @@
 			}
 		}
 	}
+#if defined(__sh__)
+	else if (m_boxtype == UFS910 || m_boxtype == UFS912 || m_boxtype == SPARK || m_boxtype == UFS922 || m_boxtype == TF7700HDPVR || m_boxtype == HDBOX || m_boxtype == HL101 ||
+		m_boxtype == CUBEREVO || m_boxtype == CUBEREVO_MINI || m_boxtype == CUBEREVO_MINI2 || m_boxtype == VIP1_V2 || m_boxtype == VIP2_V1 ||
+		m_boxtype == CUBEREVO_MINI_FTA || m_boxtype == CUBEREVO_250HD || m_boxtype == CUBEREVO_2000HD || m_boxtype == CUBEREVO_9500HD || m_boxtype == OCTAGON1008)
+	{
+		for (; i != m_demux.end(); ++i, ++n)
+		{
+			if(fe)
+			{
+				if (!i->m_inuse)
+				{
+					if (!unused)
+					{
+						// take the first unused
+						//eDebug("\nallocate demux b = %d\n",n);
+						unused = i;
+					}
+				}
+				else if (i->m_adapter == fe->m_adapter &&
+				    i->m_demux->getSource() == fe->m_frontend->getDVBID())
+				{
+					// take the demux allocated to the same
+					// frontend,  just create a new reference
+					demux = new eDVBAllocatedDemux(i);
+					//eDebug("\nallocate demux b = %d\n",n);
+					return 0;
+				}
+			}
+			else if(n == (m_demux.size() - 1))
+			{
+				// Always use the last demux for PVR
+				// it is assumed that the last demux is not
+				// attached to a frontend. That is, there
+				// should be one instance of dvr & demux
+				// devices more than of frontend devices.
+				// Otherwise, playback and timeshift might
+				// interfere recording.
+				if (i->m_inuse)
+				{
+					// just create a new reference
+					demux = new eDVBAllocatedDemux(i);
+					//eDebug("\nallocate demux c = %d\n",n);
+					return 0;
+				}
 
+				unused = i;
+				//eDebug("\nallocate demux d = %d\n", n);
+				break;
+			}
+		}
+	}
+#endif
 	if (unused)
 	{
 		demux = new eDVBAllocatedDemux(unused);
@@ -1750,8 +1837,15 @@
 #if HAVE_DVB_API_VERSION < 3
 		m_pvr_fd_dst = open("/dev/pvr", O_WRONLY);
 #else
+#if defined(__sh__)
+		char dvrDev[128];
+		int dvrIndex = m_mgr->m_adapter.begin()->getNumDemux() - 1;
+		sprintf(dvrDev, "/dev/dvb/adapter0/dvr%d", dvrIndex);
+		m_pvr_fd_dst = open(dvrDev, O_WRONLY);
+#else
 		m_pvr_fd_dst = open("/dev/misc/pvr", O_WRONLY);
 #endif
+#endif
 		if (m_pvr_fd_dst < 0)
 		{
 			eDebug("can't open /dev/misc/pvr - you need to buy the new(!) $$$ box! (%m)"); // or wait for the driver to be improved.
diff -Nur enigma2-nightly/lib/dvb/dvb.cpp.orig enigma2-nightly.spark/lib/dvb/dvb.cpp.orig
--- enigma2-nightly/lib/dvb/dvb.cpp.orig	1970-01-01 08:00:00.000000000 +0800
+++ enigma2-nightly.spark/lib/dvb/dvb.cpp.orig	2010-08-11 18:11:32.772524132 +0800
@@ -0,0 +1,1925 @@
+#include <lib/base/eerror.h>
+#include <lib/base/filepush.h>
+#include <lib/dvb/idvb.h>
+#include <lib/dvb/dvb.h>
+#include <lib/dvb/pmt.h>
+#include <lib/dvb/sec.h>
+#include <lib/dvb/specs.h>
+
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+
+DEFINE_REF(eDVBRegisteredFrontend);
+DEFINE_REF(eDVBRegisteredDemux);
+
+DEFINE_REF(eDVBAllocatedFrontend);
+
+eDVBAllocatedFrontend::eDVBAllocatedFrontend(eDVBRegisteredFrontend *fe): m_fe(fe)
+{
+	m_fe->inc_use();
+}
+
+eDVBAllocatedFrontend::~eDVBAllocatedFrontend()
+{
+	m_fe->dec_use();
+}
+
+DEFINE_REF(eDVBAllocatedDemux);
+
+eDVBAllocatedDemux::eDVBAllocatedDemux(eDVBRegisteredDemux *demux): m_demux(demux)
+{
+	m_demux->m_inuse++;
+}
+
+eDVBAllocatedDemux::~eDVBAllocatedDemux()
+{
+	--m_demux->m_inuse;
+}
+
+DEFINE_REF(eDVBResourceManager);
+
+eDVBResourceManager *eDVBResourceManager::instance;
+
+RESULT eDVBResourceManager::getInstance(ePtr<eDVBResourceManager> &ptr)
+{
+	if (instance)
+	{
+		ptr = instance;
+		return 0;
+	}
+	return -1;
+}
+
+ePtr<eDVBResourceManager> NewResourceManagerPtr(void)
+{
+	ePtr<eDVBResourceManager> ptr;
+	eDVBResourceManager::getInstance(ptr);
+	return ptr;
+}
+
+eDVBResourceManager::eDVBResourceManager()
+	:m_releaseCachedChannelTimer(eTimer::create(eApp))
+{
+	avail = 1;
+	busy = 0;
+	m_sec = new eDVBSatelliteEquipmentControl(m_frontend, m_simulate_frontend);
+
+	if (!instance)
+		instance = this;
+
+		/* search available adapters... */
+
+		// add linux devices
+
+	int num_adapter = 0;
+	while (eDVBAdapterLinux::exist(num_adapter))
+	{
+		addAdapter(new eDVBAdapterLinux(num_adapter));
+		num_adapter++;
+	}
+
+	int fd = open("/proc/stb/info/model", O_RDONLY);
+	char tmp[255];
+	int rd = fd >= 0 ? read(fd, tmp, 255) : 0;
+	if (fd >= 0)
+		close(fd);
+
+	if (!strncmp(tmp, "dm7025\n", rd))
+		m_boxtype = DM7025;
+	else if (!strncmp(tmp, "dm8000\n", rd))
+		m_boxtype = DM8000;
+	else if (!strncmp(tmp, "dm800\n", rd))
+		m_boxtype = DM800;
+	else if (!strncmp(tmp, "dm500hd\n", rd))
+		m_boxtype = DM500HD;
+	else {
+		eDebug("boxtype detection via /proc/stb/info not possible... use fallback via demux count!\n");
+		if (m_demux.size() == 3)
+			m_boxtype = DM800;
+		else if (m_demux.size() < 5)
+			m_boxtype = DM7025;
+		else
+			m_boxtype = DM8000;
+	}
+
+	eDebug("found %d adapter, %d frontends(%d sim) and %d demux, boxtype %d",
+		m_adapter.size(), m_frontend.size(), m_simulate_frontend.size(), m_demux.size(), m_boxtype);
+
+	eDVBCAService::registerChannelCallback(this);
+
+	CONNECT(m_releaseCachedChannelTimer->timeout, eDVBResourceManager::releaseCachedChannel);
+}
+
+void eDVBResourceManager::feStateChanged()
+{
+	int mask=0;
+	for (eSmartPtrList<eDVBRegisteredFrontend>::iterator i(m_frontend.begin()); i != m_frontend.end(); ++i)
+		if (i->m_inuse)
+			mask |= ( 1 << i->m_frontend->getSlotID() );
+	/* emit */ frontendUseMaskChanged(mask);
+}
+
+DEFINE_REF(eDVBAdapterLinux);
+eDVBAdapterLinux::eDVBAdapterLinux(int nr): m_nr(nr)
+{
+		// scan frontends
+	int num_fe = 0;
+
+	eDebug("scanning for frontends..");
+	while (1)
+	{
+		struct stat s;
+		char filename[128];
+#if HAVE_DVB_API_VERSION < 3
+		sprintf(filename, "/dev/dvb/card%d/frontend%d", m_nr, num_fe);
+#else
+		sprintf(filename, "/dev/dvb/adapter%d/frontend%d", m_nr, num_fe);
+#endif
+		if (stat(filename, &s))
+			break;
+		ePtr<eDVBFrontend> fe;
+
+		{
+			int ok = 0;
+			fe = new eDVBFrontend(m_nr, num_fe, ok);
+			if (ok)
+				m_frontend.push_back(fe);
+		}
+		{
+			int ok = 0;
+			fe = new eDVBFrontend(m_nr, num_fe, ok, true);
+			if (ok)
+				m_simulate_frontend.push_back(fe);
+		}
+		++num_fe;
+	}
+
+		// scan demux
+	int num_demux = 0;
+	while (1)
+	{
+		struct stat s;
+		char filename[128];
+#if HAVE_DVB_API_VERSION < 3
+		sprintf(filename, "/dev/dvb/card%d/demux%d", m_nr, num_demux);
+#else
+		sprintf(filename, "/dev/dvb/adapter%d/demux%d", m_nr, num_demux);
+#endif
+		if (stat(filename, &s))
+			break;
+		ePtr<eDVBDemux> demux;
+
+		demux = new eDVBDemux(m_nr, num_demux);
+		m_demux.push_back(demux);
+
+		++num_demux;
+	}
+}
+
+int eDVBAdapterLinux::getNumDemux()
+{
+	return m_demux.size();
+}
+
+RESULT eDVBAdapterLinux::getDemux(ePtr<eDVBDemux> &demux, int nr)
+{
+	eSmartPtrList<eDVBDemux>::iterator i(m_demux.begin());
+	while (nr && (i != m_demux.end()))
+	{
+		--nr;
+		++i;
+	}
+
+	if (i != m_demux.end())
+		demux = *i;
+	else
+		return -1;
+
+	return 0;
+}
+
+int eDVBAdapterLinux::getNumFrontends()
+{
+	return m_frontend.size();
+}
+
+RESULT eDVBAdapterLinux::getFrontend(ePtr<eDVBFrontend> &fe, int nr, bool simulate)
+{
+	eSmartPtrList<eDVBFrontend>::iterator i(simulate ? m_simulate_frontend.begin() : m_frontend.begin());
+	while (nr && (i != m_frontend.end()))
+	{
+		--nr;
+		++i;
+	}
+
+	if (i != m_frontend.end())
+		fe = *i;
+	else
+		return -1;
+
+	return 0;
+}
+
+int eDVBAdapterLinux::exist(int nr)
+{
+	struct stat s;
+	char filename[128];
+#if HAVE_DVB_API_VERSION < 3
+	sprintf(filename, "/dev/dvb/card%d", nr);
+#else
+	sprintf(filename, "/dev/dvb/adapter%d", nr);
+#endif
+	if (!stat(filename, &s))
+		return 1;
+	return 0;
+}
+
+eDVBResourceManager::~eDVBResourceManager()
+{
+	if (instance == this)
+		instance = 0;
+}
+
+void eDVBResourceManager::addAdapter(iDVBAdapter *adapter)
+{
+	int num_fe = adapter->getNumFrontends();
+	int num_demux = adapter->getNumDemux();
+
+	m_adapter.push_back(adapter);
+
+	int i;
+	for (i=0; i<num_demux; ++i)
+	{
+		ePtr<eDVBDemux> demux;
+		if (!adapter->getDemux(demux, i))
+			m_demux.push_back(new eDVBRegisteredDemux(demux, adapter));
+	}
+
+	ePtr<eDVBRegisteredFrontend> prev_dvbt_frontend;
+	for (i=0; i<num_fe; ++i)
+	{
+		ePtr<eDVBFrontend> frontend;
+		if (!adapter->getFrontend(frontend, i))
+		{
+			int frontendType=0;
+			frontend->getFrontendType(frontendType);
+			eDVBRegisteredFrontend *new_fe = new eDVBRegisteredFrontend(frontend, adapter);
+			CONNECT(new_fe->stateChanged, eDVBResourceManager::feStateChanged);
+			m_frontend.push_back(new_fe);
+			frontend->setSEC(m_sec);
+			// we must link all dvb-t frontends ( for active antenna voltage )
+			if (frontendType == iDVBFrontend::feTerrestrial)
+			{
+				if (prev_dvbt_frontend)
+				{
+					prev_dvbt_frontend->m_frontend->setData(eDVBFrontend::LINKED_NEXT_PTR, (long)new_fe);
+					frontend->setData(eDVBFrontend::LINKED_PREV_PTR, (long)&(*prev_dvbt_frontend));
+				}
+				prev_dvbt_frontend = new_fe;
+			}
+		}
+	}
+
+	prev_dvbt_frontend = 0;
+	for (i=0; i<num_fe; ++i)
+	{
+		ePtr<eDVBFrontend> frontend;
+		if (!adapter->getFrontend(frontend, i, true))
+		{
+			int frontendType=0;
+			frontend->getFrontendType(frontendType);
+			eDVBRegisteredFrontend *new_fe = new eDVBRegisteredFrontend(frontend, adapter);
+//			CONNECT(new_fe->stateChanged, eDVBResourceManager::feStateChanged);
+			m_simulate_frontend.push_back(new_fe);
+			frontend->setSEC(m_sec);
+			// we must link all dvb-t frontends ( for active antenna voltage )
+			if (frontendType == iDVBFrontend::feTerrestrial)
+			{
+				if (prev_dvbt_frontend)
+				{
+					prev_dvbt_frontend->m_frontend->setData(eDVBFrontend::LINKED_NEXT_PTR, (long)new_fe);
+					frontend->setData(eDVBFrontend::LINKED_PREV_PTR, (long)&(*prev_dvbt_frontend));
+				}
+				prev_dvbt_frontend = new_fe;
+			}
+		}
+	}
+
+}
+
+PyObject *eDVBResourceManager::setFrontendSlotInformations(ePyObject list)
+{
+	if (!PyList_Check(list))
+	{
+		PyErr_SetString(PyExc_StandardError, "eDVBResourceManager::setFrontendSlotInformations argument should be a python list");
+		return NULL;
+	}
+	if ((unsigned int)PyList_Size(list) != m_frontend.size())
+	{
+		char blasel[256];
+		sprintf(blasel, "eDVBResourceManager::setFrontendSlotInformations list size incorrect %d frontends avail, but %d entries in slotlist",
+			m_frontend.size(), PyList_Size(list));
+		PyErr_SetString(PyExc_StandardError, blasel);
+		return NULL;
+	}
+	int pos=0;
+	for (eSmartPtrList<eDVBRegisteredFrontend>::iterator i(m_frontend.begin()); i != m_frontend.end(); ++i)
+	{
+		ePyObject obj = PyList_GET_ITEM(list, pos++);
+		if (!i->m_frontend->setSlotInfo(obj))
+			return NULL;
+	}
+	pos=0;
+	for (eSmartPtrList<eDVBRegisteredFrontend>::iterator i(m_simulate_frontend.begin()); i != m_simulate_frontend.end(); ++i)
+	{
+		ePyObject obj = PyList_GET_ITEM(list, pos++);
+		if (!i->m_frontend->setSlotInfo(obj))
+			return NULL;
+	}
+	Py_RETURN_NONE;
+}
+
+RESULT eDVBResourceManager::allocateFrontend(ePtr<eDVBAllocatedFrontend> &fe, ePtr<iDVBFrontendParameters> &feparm, bool simulate)
+{
+	eSmartPtrList<eDVBRegisteredFrontend> &frontends = simulate ? m_simulate_frontend : m_frontend;
+	ePtr<eDVBRegisteredFrontend> best;
+	int bestval = 0;
+	int foundone = 0;
+
+	for (eSmartPtrList<eDVBRegisteredFrontend>::iterator i(frontends.begin()); i != frontends.end(); ++i)
+	{
+		int c = i->m_frontend->isCompatibleWith(feparm);
+
+		if (c)	/* if we have at least one frontend which is compatible with the source, flag this. */
+			foundone = 1;
+
+		if (!i->m_inuse)
+		{
+//			eDebug("Slot %d, score %d", i->m_frontend->getSlotID(), c);
+			if (c > bestval)
+			{
+				bestval = c;
+				best = i;
+			}
+		}
+//		else
+//			eDebug("Slot %d, score %d... but BUSY!!!!!!!!!!!", i->m_frontend->getSlotID(), c);
+	}
+
+	if (best)
+	{
+		fe = new eDVBAllocatedFrontend(best);
+		return 0;
+	}
+
+	fe = 0;
+
+	if (foundone)
+		return errAllSourcesBusy;
+	else
+		return errNoSourceFound;
+}
+
+RESULT eDVBResourceManager::allocateFrontendByIndex(ePtr<eDVBAllocatedFrontend> &fe, int slot_index)
+{
+	int err = errNoSourceFound;
+	for (eSmartPtrList<eDVBRegisteredFrontend>::iterator i(m_frontend.begin()); i != m_frontend.end(); ++i)
+		if (!i->m_inuse && i->m_frontend->getSlotID() == slot_index)
+		{
+			// check if another slot linked to this is in use
+			long tmp;
+			i->m_frontend->getData(eDVBFrontend::SATPOS_DEPENDS_PTR, tmp);
+			if ( tmp != -1 )
+			{
+				eDVBRegisteredFrontend *satpos_depends_to_fe = (eDVBRegisteredFrontend *)tmp;
+				if (satpos_depends_to_fe->m_inuse)
+				{
+					eDebug("another satpos depending frontend is in use.. so allocateFrontendByIndex not possible!");
+					err = errAllSourcesBusy;
+					goto alloc_fe_by_id_not_possible;
+				}
+			}
+			else // check linked tuners
+			{
+				i->m_frontend->getData(eDVBFrontend::LINKED_NEXT_PTR, tmp);
+				while ( tmp != -1 )
+				{
+					eDVBRegisteredFrontend *next = (eDVBRegisteredFrontend *) tmp;
+					if (next->m_inuse)
+					{
+						eDebug("another linked frontend is in use.. so allocateFrontendByIndex not possible!");
+						err = errAllSourcesBusy;
+						goto alloc_fe_by_id_not_possible;
+					}
+					next->m_frontend->getData(eDVBFrontend::LINKED_NEXT_PTR, tmp);
+				}
+				i->m_frontend->getData(eDVBFrontend::LINKED_PREV_PTR, tmp);
+				while ( tmp != -1 )
+				{
+					eDVBRegisteredFrontend *prev = (eDVBRegisteredFrontend *) tmp;
+					if (prev->m_inuse)
+					{
+						eDebug("another linked frontend is in use.. so allocateFrontendByIndex not possible!");
+						err = errAllSourcesBusy;
+						goto alloc_fe_by_id_not_possible;
+					}
+					prev->m_frontend->getData(eDVBFrontend::LINKED_PREV_PTR, tmp);
+				}
+			}
+			fe = new eDVBAllocatedFrontend(i);
+			return 0;
+		}
+alloc_fe_by_id_not_possible:
+	fe = 0;
+	return err;
+}
+
+#define capHoldDecodeReference 64
+
+RESULT eDVBResourceManager::allocateDemux(eDVBRegisteredFrontend *fe, ePtr<eDVBAllocatedDemux> &demux, int &cap)
+{
+		/* find first unused demux which is on same adapter as frontend (or any, if PVR)
+		   never use the first one unless we need a decoding demux. */
+
+	eDebug("allocate demux");
+	eSmartPtrList<eDVBRegisteredDemux>::iterator i(m_demux.begin());
+
+	int n=0;
+
+	if (i == m_demux.end())
+		return -1;
+
+	ePtr<eDVBRegisteredDemux> unused;
+
+	if (m_boxtype == DM800 || m_boxtype == DM500HD) // dm800 / 500hd
+	{
+		cap |= capHoldDecodeReference; // this is checked in eDVBChannel::getDemux
+		for (; i != m_demux.end(); ++i, ++n)
+		{
+			if (!i->m_inuse)
+			{
+				if (!unused)
+					unused = i;
+			}
+			else
+			{
+				if (fe)
+				{
+					if (i->m_adapter == fe->m_adapter && 
+					    i->m_demux->getSource() == fe->m_frontend->getDVBID())
+					{
+						demux = new eDVBAllocatedDemux(i);
+						return 0;
+					}
+				}
+				else if (i->m_demux->getSource() == -1) // PVR
+				{
+					demux = new eDVBAllocatedDemux(i);
+					return 0;
+				}
+			}
+		}
+	}
+	else if (m_boxtype == DM7025) // ATI
+	{
+		/* FIXME: hardware demux policy */
+		if (!(cap & iDVBChannel::capDecode))
+		{
+			if (m_demux.size() > 2)  /* assumed to be true, otherwise we have lost anyway */
+			{
+				++i, ++n;
+				++i, ++n;
+			}
+		}
+
+		for (; i != m_demux.end(); ++i, ++n)
+		{
+			int is_decode = n < 2;
+
+			int in_use = is_decode ? (i->m_demux->getRefCount() != 2) : i->m_inuse;
+
+			if ((!in_use) && ((!fe) || (i->m_adapter == fe->m_adapter)))
+			{
+				if ((cap & iDVBChannel::capDecode) && !is_decode)
+					continue;
+				unused = i;
+				break;
+			}
+		}
+	}
+	else if (m_boxtype == DM8000)
+	{
+		cap |= capHoldDecodeReference; // this is checked in eDVBChannel::getDemux
+		for (; i != m_demux.end(); ++i, ++n)
+		{
+			if (fe)
+			{
+				if (!i->m_inuse)
+				{
+					if (!unused)
+						unused = i;
+				}
+				else if (i->m_adapter == fe->m_adapter &&
+				    i->m_demux->getSource() == fe->m_frontend->getDVBID())
+				{
+					demux = new eDVBAllocatedDemux(i);
+					return 0;
+				}
+			}
+			else if (n == 4) // always use demux4 for PVR (demux 4 can not descramble...)
+			{
+				if (i->m_inuse) {
+					demux = new eDVBAllocatedDemux(i);
+					return 0;
+				}
+				unused = i;
+			}
+		}
+	}
+
+	if (unused)
+	{
+		demux = new eDVBAllocatedDemux(unused);
+		if (fe)
+			demux->get().setSourceFrontend(fe->m_frontend->getDVBID());
+		else
+			demux->get().setSourcePVR(0);
+		return 0;
+	}
+
+	eDebug("demux not found");
+	return -1;
+}
+
+RESULT eDVBResourceManager::setChannelList(iDVBChannelList *list)
+{
+	m_list = list;
+	return 0;
+}
+
+RESULT eDVBResourceManager::getChannelList(ePtr<iDVBChannelList> &list)
+{
+	list = m_list;
+	if (list)
+		return 0;
+	else
+		return -ENOENT;
+}
+
+#define eDebugNoSimulate(x...) \
+	do { \
+		if (!simulate) \
+			eDebug(x); \
+	} while(0)
+//		else \
+//		{ \
+//			eDebugNoNewLine("SIMULATE:"); \
+//			eDebug(x); \
+//		} \
+
+
+RESULT eDVBResourceManager::allocateChannel(const eDVBChannelID &channelid, eUsePtr<iDVBChannel> &channel, bool simulate)
+{
+		/* first, check if a channel is already existing. */
+	std::list<active_channel> &active_channels = simulate ? m_active_simulate_channels : m_active_channels;
+
+	if (!simulate && m_cached_channel)
+	{
+		eDVBChannel *cache_chan = (eDVBChannel*)&(*m_cached_channel);
+		if(channelid==cache_chan->getChannelID())
+		{
+			eDebug("use cached_channel");
+			channel = m_cached_channel;
+			return 0;
+		}
+		m_cached_channel_state_changed_conn.disconnect();
+		m_cached_channel=0;
+		m_releaseCachedChannelTimer->stop();
+	}
+
+	eDebugNoSimulate("allocate channel.. %04x:%04x", channelid.transport_stream_id.get(), channelid.original_network_id.get());
+	for (std::list<active_channel>::iterator i(active_channels.begin()); i != active_channels.end(); ++i)
+	{
+		eDebugNoSimulate("available channel.. %04x:%04x", i->m_channel_id.transport_stream_id.get(), i->m_channel_id.original_network_id.get());
+		if (i->m_channel_id == channelid)
+		{
+			eDebugNoSimulate("found shared channel..");
+			channel = i->m_channel;
+			return 0;
+		}
+	}
+
+	/* no currently available channel is tuned to this channelid. create a new one, if possible. */
+
+	if (!m_list)
+	{
+		eDebugNoSimulate("no channel list set!");
+		return errNoChannelList;
+	}
+
+	ePtr<iDVBFrontendParameters> feparm;
+	if (m_list->getChannelFrontendData(channelid, feparm))
+	{
+		eDebugNoSimulate("channel not found!");
+		return errChannelNotInList;
+	}
+
+	/* allocate a frontend. */
+
+	ePtr<eDVBAllocatedFrontend> fe;
+
+	int err = allocateFrontend(fe, feparm, simulate);
+	if (err)
+		return err;
+
+	RESULT res;
+	ePtr<eDVBChannel> ch = new eDVBChannel(this, fe);
+
+	res = ch->setChannel(channelid, feparm);
+	if (res)
+	{
+		channel = 0;
+		return errChidNotFound;
+	}
+
+	if (simulate)
+		channel = ch;
+	else
+	{
+		m_cached_channel = channel = ch;
+		m_cached_channel_state_changed_conn =
+			CONNECT(ch->m_stateChanged,eDVBResourceManager::DVBChannelStateChanged);
+	}
+
+	return 0;
+}
+
+void eDVBResourceManager::DVBChannelStateChanged(iDVBChannel *chan)
+{
+	int state=0;
+	chan->getState(state);
+	switch (state)
+	{
+		case iDVBChannel::state_release:
+		case iDVBChannel::state_ok:
+		{
+			eDebug("stop release channel timer");
+			m_releaseCachedChannelTimer->stop();
+			break;
+		}
+		case iDVBChannel::state_last_instance:
+		{
+			eDebug("start release channel timer");
+			m_releaseCachedChannelTimer->start(3000, true);
+			break;
+		}
+		default: // ignore all other events
+			break;
+	}
+}
+
+void eDVBResourceManager::releaseCachedChannel()
+{
+	eDebug("release cached channel (timer timeout)");
+	m_cached_channel=0;
+}
+
+RESULT eDVBResourceManager::allocateRawChannel(eUsePtr<iDVBChannel> &channel, int slot_index)
+{
+	ePtr<eDVBAllocatedFrontend> fe;
+
+	if (m_cached_channel)
+	{
+		m_cached_channel_state_changed_conn.disconnect();
+		m_cached_channel=0;
+		m_releaseCachedChannelTimer->stop();
+	}
+
+	int err = allocateFrontendByIndex(fe, slot_index);
+	if (err)
+		return err;
+
+	channel = new eDVBChannel(this, fe);
+	return 0;
+}
+
+
+RESULT eDVBResourceManager::allocatePVRChannel(eUsePtr<iDVBPVRChannel> &channel)
+{
+	ePtr<eDVBAllocatedDemux> demux;
+
+	if (m_cached_channel && m_releaseCachedChannelTimer->isActive())
+	{
+		m_cached_channel_state_changed_conn.disconnect();
+		m_cached_channel=0;
+		m_releaseCachedChannelTimer->stop();
+	}
+
+	channel = new eDVBChannel(this, 0);
+	return 0;
+}
+
+RESULT eDVBResourceManager::addChannel(const eDVBChannelID &chid, eDVBChannel *ch)
+{
+	ePtr<iDVBFrontend> fe;
+	if (!ch->getFrontend(fe))
+	{
+		eDVBFrontend *frontend = (eDVBFrontend*)&(*fe);
+		if (frontend->is_simulate())
+			m_active_simulate_channels.push_back(active_channel(chid, ch));
+		else
+		{
+			m_active_channels.push_back(active_channel(chid, ch));
+			/* emit */ m_channelAdded(ch);
+		}
+	}
+	return 0;
+}
+
+RESULT eDVBResourceManager::removeChannel(eDVBChannel *ch)
+{
+	ePtr<iDVBFrontend> fe;
+	if (!ch->getFrontend(fe))
+	{
+		eDVBFrontend *frontend = (eDVBFrontend*)&(*fe);
+		std::list<active_channel> &active_channels = frontend->is_simulate() ? m_active_simulate_channels : m_active_channels;
+		int cnt = 0;
+		for (std::list<active_channel>::iterator i(active_channels.begin()); i != active_channels.end();)
+		{
+			if (i->m_channel == ch)
+			{
+				i = active_channels.erase(i);
+				++cnt;
+			} else
+				++i;
+		}
+		ASSERT(cnt == 1);
+		if (cnt == 1)
+			return 0;
+	}
+	return -ENOENT;
+}
+
+RESULT eDVBResourceManager::connectChannelAdded(const Slot1<void,eDVBChannel*> &channelAdded, ePtr<eConnection> &connection)
+{
+	connection = new eConnection((eDVBResourceManager*)this, m_channelAdded.connect(channelAdded));
+	return 0;
+}
+
+int eDVBResourceManager::canAllocateFrontend(ePtr<iDVBFrontendParameters> &feparm, bool simulate)
+{
+	eSmartPtrList<eDVBRegisteredFrontend> &frontends = simulate ? m_simulate_frontend : m_frontend;
+	ePtr<eDVBRegisteredFrontend> best;
+	int bestval = 0;
+
+	for (eSmartPtrList<eDVBRegisteredFrontend>::iterator i(frontends.begin()); i != frontends.end(); ++i)
+		if (!i->m_inuse)
+		{
+			int c = i->m_frontend->isCompatibleWith(feparm);
+			if (c > bestval)
+				bestval = c;
+		}
+	return bestval;
+}
+
+int tuner_type_channel_default(ePtr<iDVBChannelList> &channellist, const eDVBChannelID &chid)
+{
+	if (channellist)
+	{
+		ePtr<iDVBFrontendParameters> feparm;
+		if (!channellist->getChannelFrontendData(chid, feparm))
+		{
+			int system;
+			if (!feparm->getSystem(system))
+			{
+				switch(system)
+				{
+					case iDVBFrontend::feSatellite:
+						return 50000;
+					case iDVBFrontend::feCable:
+						return 40000;
+					case iDVBFrontend::feTerrestrial:
+						return 30000;
+					default:
+						break;
+				}
+			}
+		}
+	}
+	return 0;
+}
+
+int eDVBResourceManager::canAllocateChannel(const eDVBChannelID &channelid, const eDVBChannelID& ignore, bool simulate)
+{
+	std::list<active_channel> &active_channels = simulate ? m_active_simulate_channels : m_active_channels;
+	int ret=0;
+	if (!simulate && m_cached_channel)
+	{
+		eDVBChannel *cache_chan = (eDVBChannel*)&(*m_cached_channel);
+		if(channelid==cache_chan->getChannelID())
+			return tuner_type_channel_default(m_list, channelid);
+	}
+
+		/* first, check if a channel is already existing. */
+//	eDebug("allocate channel.. %04x:%04x", channelid.transport_stream_id.get(), channelid.original_network_id.get());
+	for (std::list<active_channel>::iterator i(active_channels.begin()); i != active_channels.end(); ++i)
+	{
+//		eDebug("available channel.. %04x:%04x", i->m_channel_id.transport_stream_id.get(), i->m_channel_id.original_network_id.get());
+		if (i->m_channel_id == channelid)
+		{
+//			eDebug("found shared channel..");
+			return tuner_type_channel_default(m_list, channelid);
+		}
+	}
+
+	int *decremented_cached_channel_fe_usecount=NULL,
+		*decremented_fe_usecount=NULL;
+
+	for (std::list<active_channel>::iterator i(active_channels.begin()); i != active_channels.end(); ++i)
+	{
+		eSmartPtrList<eDVBRegisteredFrontend> &frontends = simulate ? m_simulate_frontend : m_frontend;
+//		eDebug("available channel.. %04x:%04x", i->m_channel_id.transport_stream_id.get(), i->m_channel_id.original_network_id.get());
+		if (i->m_channel_id == ignore)
+		{
+			eDVBChannel *channel = (eDVBChannel*) &(*i->m_channel);
+			// one eUsePtr<iDVBChannel> is used in eDVBServicePMTHandler
+			// another on eUsePtr<iDVBChannel> is used in the eDVBScan instance used in eDVBServicePMTHandler (for SDT scan)
+			// so we must check here if usecount is 3 (when the channel is equal to the cached channel)
+			// or 2 when the cached channel is not equal to the compared channel
+			if (channel == &(*m_cached_channel) ? channel->getUseCount() == 3 : channel->getUseCount() == 2)  // channel only used once..
+			{
+				ePtr<iDVBFrontend> fe;
+				if (!i->m_channel->getFrontend(fe))
+				{
+					for (eSmartPtrList<eDVBRegisteredFrontend>::iterator ii(frontends.begin()); ii != frontends.end(); ++ii)
+					{
+						if ( &(*fe) == &(*ii->m_frontend) )
+						{
+							--ii->m_inuse;
+							decremented_fe_usecount = &ii->m_inuse;
+							if (channel == &(*m_cached_channel))
+								decremented_cached_channel_fe_usecount = decremented_fe_usecount;
+							break;
+						}
+					}
+				}
+			}
+			break;
+		}
+	}
+
+	if (!decremented_cached_channel_fe_usecount)
+	{
+		if (m_cached_channel)
+		{
+			eDVBChannel *channel = (eDVBChannel*) &(*m_cached_channel);
+			if (channel->getUseCount() == 1)
+			{
+				ePtr<iDVBFrontend> fe;
+				if (!channel->getFrontend(fe))
+				{
+					eSmartPtrList<eDVBRegisteredFrontend> &frontends = simulate ? m_simulate_frontend : m_frontend;
+					for (eSmartPtrList<eDVBRegisteredFrontend>::iterator ii(frontends.begin()); ii != frontends.end(); ++ii)
+					{
+						if ( &(*fe) == &(*ii->m_frontend) )
+						{
+							--ii->m_inuse;
+							decremented_cached_channel_fe_usecount = &ii->m_inuse;
+							break;
+						}
+					}
+				}
+			}
+		}
+	}
+	else
+		decremented_cached_channel_fe_usecount=NULL;
+
+	ePtr<iDVBFrontendParameters> feparm;
+
+	if (!m_list)
+	{
+		eDebug("no channel list set!");
+		goto error;
+	}
+
+	if (m_list->getChannelFrontendData(channelid, feparm))
+	{
+		eDebug("channel not found!");
+		goto error;
+	}
+
+	ret = canAllocateFrontend(feparm, simulate);
+
+error:
+	if (decremented_fe_usecount)
+		++(*decremented_fe_usecount);
+	if (decremented_cached_channel_fe_usecount)
+		++(*decremented_cached_channel_fe_usecount);
+
+	return ret;
+}
+
+bool eDVBResourceManager::canMeasureFrontendInputPower()
+{
+	for (eSmartPtrList<eDVBRegisteredFrontend>::iterator i(m_frontend.begin()); i != m_frontend.end(); ++i)
+	{
+		return i->m_frontend->readInputpower() >= 0;
+	}
+	return false;
+}
+
+class eDVBChannelFilePush: public eFilePushThread
+{
+public:
+	eDVBChannelFilePush() { setIFrameSearch(0); setTimebaseChange(0); }
+	void setIFrameSearch(int enabled) { m_iframe_search = enabled; m_iframe_state = 0; }
+
+			/* "timebase change" is for doing trickmode playback at an exact speed, even when pictures are skipped. */
+			/* you need to set it to 1/16 if you want 16x playback, for example. you need video master sync. */
+	void setTimebaseChange(int ratio) { m_timebase_change = ratio; } /* 16bit fixpoint, 0 for disable */
+protected:
+	int m_iframe_search, m_iframe_state, m_pid;
+	int m_timebase_change;
+	int filterRecordData(const unsigned char *data, int len, size_t &current_span_remaining);
+};
+
+int eDVBChannelFilePush::filterRecordData(const unsigned char *_data, int len, size_t &current_span_remaining)
+{
+#if 0
+	if (m_timebase_change)
+	{
+		eDebug("timebase change: %d", m_timebase_change);
+		int offset;
+		for (offset = 0; offset < len; offset += 188)
+		{
+			unsigned char *pkt = (unsigned char*)_data + offset;
+			if (pkt[1] & 0x40) /* pusi */
+			{
+				if (pkt[3] & 0x20) // adaption field present?
+					pkt += pkt[4] + 4 + 1;  /* skip adaption field and header */
+				else
+					pkt += 4; /* skip header */
+				if (pkt[0] || pkt[1] || (pkt[2] != 1))
+				{
+					eWarning("broken startcode");
+					continue;
+				}
+
+				pts_t pts = 0;
+
+				if (pkt[7] & 0x80) // PTS present?
+				{
+					pts  = ((unsigned long long)(pkt[ 9]&0xE))  << 29;
+					pts |= ((unsigned long long)(pkt[10]&0xFF)) << 22;
+					pts |= ((unsigned long long)(pkt[11]&0xFE)) << 14;
+					pts |= ((unsigned long long)(pkt[12]&0xFF)) << 7;
+					pts |= ((unsigned long long)(pkt[13]&0xFE)) >> 1;
+
+#if 0
+					off_t off = 0;
+					RESULT r = m_tstools.fixupPTS(off, pts);
+					if (r)
+						eWarning("fixup PTS while trickmode playback failed.\n");
+#endif
+
+					int sec = pts / 90000;
+					int frm = pts % 90000;
+					int min = sec / 60;
+					sec %= 60;
+					int hr = min / 60;
+					min %= 60;
+					int d = hr / 24;
+					hr %= 24;
+
+//					eDebug("original, fixed pts: %016llx %d:%02d:%02d:%02d:%05d", pts, d, hr, min, sec, frm);
+
+					pts += 0x80000000LL;
+					pts *= m_timebase_change;
+					pts >>= 16;
+
+					sec = pts / 90000;
+					frm = pts % 90000;
+					min = sec / 60;
+					sec %= 60;
+					hr = min / 60;
+					min %= 60;
+					d = hr / 24;
+					hr %= 24;
+
+//					eDebug("new pts (after timebase change): %016llx %d:%02d:%02d:%02d:%05d", pts, d, hr, min, sec, frm);
+
+					pkt[9] &= ~0xE;
+					pkt[10] = 0;
+					pkt[11] &= ~1;
+					pkt[12] = 0;
+					pkt[13] &= ~1;
+
+					pkt[9]  |= (pts >> 29) & 0xE;
+					pkt[10] |= (pts >> 22) & 0xFF;
+					pkt[11] |= (pts >> 14) & 0xFE;
+					pkt[12] |= (pts >> 7) & 0xFF;
+					pkt[13] |= (pts << 1) & 0xFE;
+				}
+			}
+		}
+	}
+#endif
+
+#if 0
+	if (!m_iframe_search)
+		return len;
+
+	unsigned char *data = (unsigned char*)_data; /* remove that const. we know what we are doing. */
+
+//	eDebug("filterRecordData, size=%d (mod 188=%d), first byte is %02x", len, len %188, data[0]);
+
+	unsigned char *d = data;
+	while ((d + 3 < data + len) && (d = (unsigned char*)memmem(d, data + len - d, "\x00\x00\x01", 3)))
+	{
+		int offset = d - data;
+		int ts_offset = offset - offset % 188; /* offset to the start of TS packet */
+		unsigned char *ts = data + ts_offset;
+		int pid = ((ts[1] << 8) | ts[2]) & 0x1FFF;
+
+		if ((d[3] == 0 || d[3] == 0x09 && d[-1] == 0 && (ts[1] & 0x40)) && (m_pid == pid))  /* picture start */
+		{
+			int picture_type = (d[3]==0 ? (d[5] >> 3) & 7 : (d[4] >> 5) + 1);
+			d += 4;
+
+//			eDebug("%d-frame at %d, offset in TS packet: %d, pid=%04x", picture_type, offset, offset % 188, pid);
+
+			if (m_iframe_state == 1)
+			{
+					/* we are allowing data, and stop allowing data on the next frame.
+					   we now found a frame. so stop here. */
+				memset(data + offset, 0, 188 - (offset%188)); /* zero out rest of TS packet */
+				current_span_remaining = 0;
+				m_iframe_state = 0;
+				unsigned char *fts = ts + 188;
+				while (fts < (data + len))
+				{
+					fts[1] |= 0x1f;
+					fts[2] |= 0xff; /* drop packet */
+					fts += 188;
+				}
+
+				return len; // ts_offset + 188; /* deliver this packet, but not more. */
+			} else
+			{
+				if (picture_type != 1) /* we are only interested in I frames */
+					continue;
+
+				unsigned char *fts = data;
+				while (fts < ts)
+				{
+					fts[1] |= 0x1f;
+					fts[2] |= 0xff; /* drop packet */
+
+					fts += 188;
+				}
+
+				m_iframe_state = 1;
+			}
+		} else if ((d[3] & 0xF0) == 0xE0) /* video stream */
+		{
+				/* verify that this is actually a PES header, not just some ES data */
+			if (ts[1] & 0x40) /* PUSI set */
+			{
+				int payload_start = 4;
+				if (ts[3] & 0x20) /* adaptation field present */
+					payload_start += ts[4] + 1; /* skip AF */
+				if (payload_start == (offset%188)) /* the 00 00 01 should be directly at the payload start, otherwise it's not a PES header */
+				{
+					if (m_pid != pid)
+					{
+						eDebug("now locked to pid %04x (%02x %02x %02x %02x)", pid, ts[0], ts[1], ts[2], ts[3]);
+						m_pid = pid;
+					}
+				}
+			}
+//			m_pid = 0x6e;
+			d += 4;
+		} else
+			d += 4; /* ignore */
+	}
+
+	if (m_iframe_state == 1)
+		return len;
+	else
+		return 0; /* we need find an iframe first */
+#else
+	return len;
+#endif
+}
+
+DEFINE_REF(eDVBChannel);
+
+eDVBChannel::eDVBChannel(eDVBResourceManager *mgr, eDVBAllocatedFrontend *frontend): m_state(state_idle), m_mgr(mgr)
+{
+	m_frontend = frontend;
+
+	m_pvr_thread = 0;
+	m_pvr_fd_dst = -1;
+
+	m_skipmode_n = m_skipmode_m = m_skipmode_frames = 0;
+
+	if (m_frontend)
+		m_frontend->get().connectStateChange(slot(*this, &eDVBChannel::frontendStateChanged), m_conn_frontendStateChanged);
+}
+
+eDVBChannel::~eDVBChannel()
+{
+	if (m_channel_id)
+		m_mgr->removeChannel(this);
+
+	stopFile();
+}
+
+void eDVBChannel::frontendStateChanged(iDVBFrontend*fe)
+{
+	int state, ourstate = 0;
+
+		/* if we are already in shutdown, don't change state. */
+	if (m_state == state_release)
+		return;
+
+	if (fe->getState(state))
+		return;
+
+	if (state == iDVBFrontend::stateLock)
+	{
+		eDebug("OURSTATE: ok");
+		ourstate = state_ok;
+	} else if (state == iDVBFrontend::stateTuning)
+	{
+		eDebug("OURSTATE: tuning");
+		ourstate = state_tuning;
+	} else if (state == iDVBFrontend::stateLostLock)
+	{
+			/* on managed channels, we try to retune in order to re-acquire lock. */
+		if (m_current_frontend_parameters)
+		{
+			eDebug("OURSTATE: lost lock, trying to retune");
+			ourstate = state_tuning;
+			m_frontend->get().tune(*m_current_frontend_parameters);
+		} else
+			/* on unmanaged channels, we don't do this. the client will do this. */
+		{
+			eDebug("OURSTATE: lost lock, unavailable now.");
+			ourstate = state_unavailable;
+		}
+	} else if (state == iDVBFrontend::stateFailed)
+	{
+		eDebug("OURSTATE: failed");
+		ourstate = state_failed;
+	} else
+		eFatal("state unknown");
+
+	if (ourstate != m_state)
+	{
+		m_state = ourstate;
+		m_stateChanged(this);
+	}
+}
+
+void eDVBChannel::pvrEvent(int event)
+{
+	switch (event)
+	{
+	case eFilePushThread::evtEOF:
+		eDebug("eDVBChannel: End of file!");
+		m_event(this, evtEOF);
+		break;
+	case eFilePushThread::evtUser: /* start */
+		eDebug("SOF");
+		m_event(this, evtSOF);
+		break;
+	}
+}
+
+void eDVBChannel::cueSheetEvent(int event)
+{
+		/* we might end up here if playing failed or stopped, but the client hasn't (yet) noted. */
+	if (!m_pvr_thread)
+		return;
+	switch (event)
+	{
+	case eCueSheet::evtSeek:
+		eDebug("seek.");
+		flushPVR(m_cue->m_decoding_demux);
+		break;
+	case eCueSheet::evtSkipmode:
+	{
+		{
+			m_cue->m_lock.WrLock();
+			m_cue->m_seek_requests.push_back(std::pair<int, pts_t>(1, 0)); /* resync */
+			m_cue->m_lock.Unlock();
+			eRdLocker l(m_cue->m_lock);
+			if (m_cue->m_skipmode_ratio)
+			{
+				int bitrate = m_tstools.calcBitrate(); /* in bits/s */
+				eDebug("skipmode ratio is %lld:90000, bitrate is %d bit/s", m_cue->m_skipmode_ratio, bitrate);
+						/* i agree that this might look a bit like black magic. */
+				m_skipmode_n = 512*1024; /* must be 1 iframe at least. */
+				m_skipmode_m = bitrate / 8 / 90000 * m_cue->m_skipmode_ratio / 8;
+				m_skipmode_frames = m_cue->m_skipmode_ratio / 90000;
+				m_skipmode_frames_remainder = 0;
+
+				if (m_cue->m_skipmode_ratio < 0)
+					m_skipmode_m -= m_skipmode_n;
+
+				eDebug("resolved to: %d %d", m_skipmode_m, m_skipmode_n);
+
+				if (abs(m_skipmode_m) < abs(m_skipmode_n))
+				{
+					eWarning("something is wrong with this calculation");
+					m_skipmode_frames = m_skipmode_n = m_skipmode_m = 0;
+				}
+			} else
+			{
+				eDebug("skipmode ratio is 0, normal play");
+				m_skipmode_frames = m_skipmode_n = m_skipmode_m = 0;
+			}
+		}
+		m_pvr_thread->setIFrameSearch(m_skipmode_n != 0);
+		if (m_cue->m_skipmode_ratio != 0)
+			m_pvr_thread->setTimebaseChange(0x10000 * 9000 / (m_cue->m_skipmode_ratio / 10)); /* negative values are also ok */
+		else
+			m_pvr_thread->setTimebaseChange(0); /* normal playback */
+		eDebug("flush pvr");
+		flushPVR(m_cue->m_decoding_demux);
+		eDebug("done");
+		break;
+	}
+	case eCueSheet::evtSpanChanged:
+	{
+		m_source_span.clear();
+		for (std::list<std::pair<pts_t, pts_t> >::const_iterator i(m_cue->m_spans.begin()); i != m_cue->m_spans.end(); ++i)
+		{
+			off_t offset_in, offset_out;
+			pts_t pts_in = i->first, pts_out = i->second;
+			if (m_tstools.getOffset(offset_in, pts_in, -1) || m_tstools.getOffset(offset_out, pts_out, 1))
+			{
+				eDebug("span translation failed.\n");
+				continue;
+			}
+			eDebug("source span: %llx .. %llx, translated to %llx..%llx", pts_in, pts_out, offset_in, offset_out);
+			m_source_span.push_back(std::pair<off_t, off_t>(offset_in, offset_out));
+		}
+		break;
+	}
+	}
+}
+
+	/* align toward zero */
+static inline long long align(long long x, int align)
+{
+	int sign = x < 0;
+
+	if (sign)
+		x = -x;
+
+	x -= x % align;
+
+	if (sign)
+		x = -x;
+
+	return x;
+}
+
+	/* align toward zero */
+static inline long long align_with_len(long long x, int align, size_t &len)
+{
+	int sign = x < 0;
+
+	if (sign)
+		x = -x;
+
+	x -= x % align;
+	len += x % align;
+
+	if (sign)
+		x = -x;
+
+	return x;
+}
+
+	/* remember, this gets called from another thread. */
+void eDVBChannel::getNextSourceSpan(off_t current_offset, size_t bytes_read, off_t &start, size_t &size)
+{
+	const int blocksize = 188;
+	unsigned int max = align(10*1024*1024, blocksize);
+	current_offset = align(current_offset, blocksize);
+
+	if (!m_cue)
+	{
+		eDebug("no cue sheet. forcing normal play");
+		start = current_offset;
+		size = max;
+		return;
+	}
+
+	if (m_skipmode_n)
+	{
+		eDebug("skipmode %d:%d (x%d)", m_skipmode_m, m_skipmode_n, m_skipmode_frames);
+		max = align(m_skipmode_n, blocksize);
+	}
+
+	eDebug("getNextSourceSpan, current offset is %08llx, m_skipmode_m = %d!", current_offset, m_skipmode_m);
+	int frame_skip_success = 0;
+
+	if (m_skipmode_m)
+	{
+		int frames_to_skip = m_skipmode_frames + m_skipmode_frames_remainder;
+		eDebug("we are at %llx, and we try to skip %d+%d frames from here", current_offset, m_skipmode_frames, m_skipmode_frames_remainder);
+		size_t iframe_len;
+		off_t iframe_start = current_offset;
+		int frames_skipped = frames_to_skip;
+		if (!m_tstools.findNextPicture(iframe_start, iframe_len, frames_skipped))
+		{
+			m_skipmode_frames_remainder = frames_to_skip - frames_skipped;
+			eDebug("successfully skipped %d (out of %d, rem now %d) frames.", frames_skipped, frames_to_skip, m_skipmode_frames_remainder);
+			current_offset = align_with_len(iframe_start, blocksize, iframe_len);
+			max = align(iframe_len + 187, blocksize);
+			frame_skip_success = 1;
+		} else
+		{
+			m_skipmode_frames_remainder = 0;
+			eDebug("frame skipping failed, reverting to byte-skipping");
+		}
+	}
+	
+	if (!frame_skip_success)
+	{
+		current_offset += align(m_skipmode_m, blocksize);
+		
+		if (m_skipmode_m)
+		{
+			eDebug("we are at %llx, and we try to find the iframe here:", current_offset);
+			size_t iframe_len;
+			off_t iframe_start = current_offset;
+			
+			int direction = (m_skipmode_m < 0) ? -1 : +1;
+			if (m_tstools.findFrame(iframe_start, iframe_len, direction))
+				eDebug("failed");
+			else
+			{
+				current_offset = align_with_len(iframe_start, blocksize, iframe_len);
+				max = align(iframe_len, blocksize);
+			}
+		}
+	}
+
+	m_cue->m_lock.RdLock();
+
+	while (!m_cue->m_seek_requests.empty())
+	{
+		std::pair<int, pts_t> seek = m_cue->m_seek_requests.front();
+		m_cue->m_lock.Unlock();
+		m_cue->m_lock.WrLock();
+		m_cue->m_seek_requests.pop_front();
+		m_cue->m_lock.Unlock();
+		m_cue->m_lock.RdLock();
+		int relative = seek.first;
+		pts_t pts = seek.second;
+
+		pts_t now = 0;
+		if (relative)
+		{
+			if (!m_cue->m_decoder)
+			{
+				eDebug("no decoder - can't seek relative");
+				continue;
+			}
+			if (m_cue->m_decoder->getPTS(0, now))
+			{
+				eDebug("decoder getPTS failed, can't seek relative");
+				continue;
+			}
+			if (!m_cue->m_decoding_demux)
+			{
+				eDebug("getNextSourceSpan, no decoding demux. couldn't seek to %llx... ignore request!", pts);
+				start = current_offset;
+				size = max;
+				continue;
+			}
+			if (getCurrentPosition(m_cue->m_decoding_demux, now, 1))
+			{
+				eDebug("seekTo: getCurrentPosition failed!");
+				continue;
+			}
+		} else if (pts < 0) /* seek relative to end */
+		{
+			pts_t len;
+			if (!getLength(len))
+			{
+				eDebug("seeking relative to end. len=%lld, seek = %lld", len, pts);
+				pts += len;
+			} else
+			{
+				eWarning("getLength failed - can't seek relative to end!");
+				continue;
+			}
+		}
+
+		if (relative == 1) /* pts relative */
+		{
+			pts += now;
+			if (pts < 0)
+				pts = 0;
+		}
+
+		if (relative != 2)
+			if (pts < 0)
+				pts = 0;
+
+		if (relative == 2) /* AP relative */
+		{
+			eDebug("AP relative seeking: %lld, at %lld", pts, now);
+			pts_t nextap;
+			if (m_tstools.getNextAccessPoint(nextap, now, pts))
+			{
+				pts = now - 90000; /* approx. 1s */
+				eDebug("AP relative seeking failed!");
+			} else
+			{
+				pts = nextap;
+				eDebug("next ap is %llx\n", pts);
+			}
+		}
+
+		off_t offset = 0;
+		if (m_tstools.getOffset(offset, pts, -1))
+		{
+			eDebug("get offset for pts=%lld failed!", pts);
+			continue;
+		}
+		
+		eDebug("ok, resolved skip (rel: %d, diff %lld), now at %08llx", relative, pts, offset);
+		current_offset = align(offset, blocksize); /* in case tstools return non-aligned offset */
+	}
+
+	m_cue->m_lock.Unlock();
+
+	for (std::list<std::pair<off_t, off_t> >::const_iterator i(m_source_span.begin()); i != m_source_span.end(); ++i)
+	{
+		long long aligned_start = align(i->first, blocksize);
+		long long aligned_end = align(i->second, blocksize);
+
+		if ((current_offset >= aligned_start) && (current_offset < aligned_end))
+		{
+			start = current_offset;
+				/* max can not exceed max(size_t). aligned_end - current_offset, however, can. */
+			if ((aligned_end - current_offset) > max)
+				size = max;
+			else
+				size = aligned_end - current_offset;
+			eDebug("HIT, %lld < %lld < %lld, size: %d", i->first, current_offset, i->second, size);
+			return;
+		}
+		if (current_offset < aligned_start)
+		{
+				/* ok, our current offset is in an 'out' zone. */
+			if ((m_skipmode_m >= 0) || (i == m_source_span.begin()))
+			{
+					/* in normal playback, just start at the next zone. */
+				start = i->first;
+
+					/* size is not 64bit! */
+				if ((i->second - i->first) > max)
+					size = max;
+				else
+					size = aligned_end - aligned_start;
+
+				eDebug("skip");
+				if (m_skipmode_m < 0)
+				{
+					eDebug("reached SOF");
+						/* reached SOF */
+					m_skipmode_m = 0;
+					m_pvr_thread->sendEvent(eFilePushThread::evtUser);
+				}
+			} else
+			{
+					/* when skipping reverse, however, choose the zone before. */
+				--i;
+				eDebug("skip to previous block, which is %llx..%llx", i->first, i->second);
+				size_t len;
+
+				aligned_start = align(i->first, blocksize);
+				aligned_end = align(i->second, blocksize);
+
+				if ((aligned_end - aligned_start) > max)
+					len = max;
+				else
+					len = aligned_end - aligned_start;
+
+				start = aligned_end - len;
+				eDebug("skipping to %llx, %d", start, len);
+			}
+
+			eDebug("result: %llx, %x (%llx %llx)", start, size, aligned_start, aligned_end);
+			return;
+		}
+	}
+
+	if ((current_offset < -m_skipmode_m) && (m_skipmode_m < 0))
+	{
+		eDebug("reached SOF");
+		m_skipmode_m = 0;
+		m_pvr_thread->sendEvent(eFilePushThread::evtUser);
+	}
+
+	if (m_source_span.empty())
+	{
+		start = current_offset;
+		size = max;
+		eDebug("NO CUESHEET. (%08llx, %d)", start, size);
+	} else
+	{
+		start = current_offset;
+		size = 0;
+	}
+	return;
+}
+
+void eDVBChannel::AddUse()
+{
+	if (++m_use_count > 1 && m_state == state_last_instance)
+	{
+		m_state = state_ok;
+		m_stateChanged(this);
+	}
+}
+
+void eDVBChannel::ReleaseUse()
+{
+	if (!--m_use_count)
+	{
+		m_state = state_release;
+		m_stateChanged(this);
+	}
+	else if (m_use_count == 1)
+	{
+		m_state = state_last_instance;
+		m_stateChanged(this);
+	}
+}
+
+RESULT eDVBChannel::setChannel(const eDVBChannelID &channelid, ePtr<iDVBFrontendParameters> &feparm)
+{
+	if (m_channel_id)
+		m_mgr->removeChannel(this);
+
+	if (!channelid)
+		return 0;
+
+	if (!m_frontend)
+	{
+		eDebug("no frontend to tune!");
+		return -ENODEV;
+	}
+
+	m_channel_id = channelid;
+	m_mgr->addChannel(channelid, this);
+	m_state = state_tuning;
+			/* if tuning fails, shutdown the channel immediately. */
+	int res;
+	res = m_frontend->get().tune(*feparm);
+	m_current_frontend_parameters = feparm;
+
+	if (res)
+	{
+		m_state = state_release;
+		m_stateChanged(this);
+		return res;
+	}
+
+	return 0;
+}
+
+RESULT eDVBChannel::connectStateChange(const Slot1<void,iDVBChannel*> &stateChange, ePtr<eConnection> &connection)
+{
+	connection = new eConnection((iDVBChannel*)this, m_stateChanged.connect(stateChange));
+	return 0;
+}
+
+RESULT eDVBChannel::connectEvent(const Slot2<void,iDVBChannel*,int> &event, ePtr<eConnection> &connection)
+{
+	connection = new eConnection((iDVBChannel*)this, m_event.connect(event));
+	return 0;
+}
+
+RESULT eDVBChannel::getState(int &state)
+{
+	state = m_state;
+	return 0;
+}
+
+RESULT eDVBChannel::setCIRouting(const eDVBCIRouting &routing)
+{
+	return -1;
+}
+
+void eDVBChannel::SDTready(int result)
+{
+	ePyObject args = PyTuple_New(2), ret;
+	bool ok=false;
+	if (!result)
+	{
+		for (std::vector<ServiceDescriptionSection*>::const_iterator i = m_SDT->getSections().begin(); i != m_SDT->getSections().end(); ++i)
+		{
+			ok = true;
+			PyTuple_SET_ITEM(args, 0, PyInt_FromLong((*i)->getTransportStreamId()));
+			PyTuple_SET_ITEM(args, 1, PyInt_FromLong((*i)->getOriginalNetworkId()));
+			break;
+		}
+	}
+	if (!ok)
+	{
+		PyTuple_SET_ITEM(args, 0, Py_None);
+		PyTuple_SET_ITEM(args, 1, Py_None);
+		Py_INCREF(Py_None);
+		Py_INCREF(Py_None);
+	}
+	ret = PyObject_CallObject(m_tsid_onid_callback, args);
+	if (ret)
+		Py_DECREF(ret);
+	Py_DECREF(args);
+	Py_DECREF(m_tsid_onid_callback);
+	m_tsid_onid_callback = ePyObject();
+	m_tsid_onid_demux = 0;
+	m_SDT = 0;
+}
+
+RESULT eDVBChannel::requestTsidOnid(ePyObject callback)
+{
+	if (PyCallable_Check(callback))
+	{
+		if (!getDemux(m_tsid_onid_demux, 0))
+		{
+			m_SDT = new eTable<ServiceDescriptionSection>;
+			CONNECT(m_SDT->tableReady, eDVBChannel::SDTready);
+			if (m_SDT->start(m_tsid_onid_demux, eDVBSDTSpec()))
+			{
+				m_tsid_onid_demux = 0;
+				m_SDT = 0;
+			}
+			else
+			{
+				Py_INCREF(callback);
+				m_tsid_onid_callback = callback;
+				return 0;
+			}
+		}
+	}
+	return -1;
+}
+
+RESULT eDVBChannel::getDemux(ePtr<iDVBDemux> &demux, int cap)
+{
+	ePtr<eDVBAllocatedDemux> &our_demux = (cap & capDecode) ? m_decoder_demux : m_demux;
+
+	if (!our_demux)
+	{
+		demux = 0;
+
+		if (m_mgr->allocateDemux(m_frontend ? (eDVBRegisteredFrontend*)*m_frontend : (eDVBRegisteredFrontend*)0, our_demux, cap))
+			return -1;
+
+		demux = *our_demux;
+
+		/* don't hold a reference to the decoding demux, we don't need it. */
+
+		/* FIXME: by dropping the 'allocated demux' in favour of the 'iDVBDemux',
+		   the refcount is lost. thus, decoding demuxes are never allocated.
+
+		   this poses a big problem for PiP. */
+
+		if (cap & capHoldDecodeReference) // this is set in eDVBResourceManager::allocateDemux for Dm500HD/DM800 and DM8000
+			;
+		else if (cap & capDecode)
+			our_demux = 0;
+	}
+	else
+		demux = *our_demux;
+
+	return 0;
+}
+
+RESULT eDVBChannel::getFrontend(ePtr<iDVBFrontend> &frontend)
+{
+	frontend = 0;
+	if (!m_frontend)
+		return -ENODEV;
+	frontend = &m_frontend->get();
+	if (frontend)
+		return 0;
+	return -ENODEV;
+}
+
+RESULT eDVBChannel::getCurrentFrontendParameters(ePtr<iDVBFrontendParameters> &param)
+{
+	param = m_current_frontend_parameters;
+	return 0;
+}
+
+RESULT eDVBChannel::playFile(const char *file)
+{
+	ASSERT(!m_frontend);
+	if (m_pvr_thread)
+	{
+		m_pvr_thread->stop();
+		delete m_pvr_thread;
+		m_pvr_thread = 0;
+	}
+
+	m_tstools.openFile(file);
+
+		/* DON'T EVEN THINK ABOUT FIXING THIS. FIX THE ATI SOURCES FIRST,
+		   THEN DO A REAL FIX HERE! */
+
+	if (m_pvr_fd_dst < 0)
+	{
+		/* (this codepath needs to be improved anyway.) */
+#if HAVE_DVB_API_VERSION < 3
+		m_pvr_fd_dst = open("/dev/pvr", O_WRONLY);
+#else
+		m_pvr_fd_dst = open("/dev/misc/pvr", O_WRONLY);
+#endif
+		if (m_pvr_fd_dst < 0)
+		{
+			eDebug("can't open /dev/misc/pvr - you need to buy the new(!) $$$ box! (%m)"); // or wait for the driver to be improved.
+			return -ENODEV;
+		}
+	}
+
+	m_pvr_thread = new eDVBChannelFilePush();
+	m_pvr_thread->enablePVRCommit(1);
+	m_pvr_thread->setStreamMode(1);
+	m_pvr_thread->setScatterGather(this);
+
+	m_event(this, evtPreStart);
+
+	if (m_pvr_thread->start(file, m_pvr_fd_dst))
+	{
+		delete m_pvr_thread;
+		m_pvr_thread = 0;
+		::close(m_pvr_fd_dst);
+		m_pvr_fd_dst = -1;
+		eDebug("can't open PVR file %s (%m)", file);
+		return -ENOENT;
+	}
+	CONNECT(m_pvr_thread->m_event, eDVBChannel::pvrEvent);
+
+	m_state = state_ok;
+	m_stateChanged(this);
+
+	return 0;
+}
+
+void eDVBChannel::stopFile()
+{
+	if (m_pvr_thread)
+	{
+		m_pvr_thread->stop();
+		delete m_pvr_thread;
+		m_pvr_thread = 0;
+	}
+	if (m_pvr_fd_dst >= 0)
+		::close(m_pvr_fd_dst);
+}
+
+void eDVBChannel::setCueSheet(eCueSheet *cuesheet)
+{
+	m_conn_cueSheetEvent = 0;
+	m_cue = cuesheet;
+	if (m_cue)
+		m_cue->connectEvent(slot(*this, &eDVBChannel::cueSheetEvent), m_conn_cueSheetEvent);
+}
+
+RESULT eDVBChannel::getLength(pts_t &len)
+{
+	return m_tstools.calcLen(len);
+}
+
+RESULT eDVBChannel::getCurrentPosition(iDVBDemux *decoding_demux, pts_t &pos, int mode)
+{
+	if (!decoding_demux)
+		return -1;
+
+	pts_t now;
+
+	int r;
+
+	if (mode == 0) /* demux */
+	{
+		r = decoding_demux->getSTC(now, 0);
+		if (r)
+		{
+			eDebug("demux getSTC failed");
+			return -1;
+		}
+	} else
+		now = pos; /* fixup supplied */
+
+	off_t off = 0; /* TODO: fixme */
+	r = m_tstools.fixupPTS(off, now);
+	if (r)
+	{
+		eDebug("fixup PTS failed");
+		return -1;
+	}
+
+	pos = now;
+
+	return 0;
+}
+
+void eDVBChannel::flushPVR(iDVBDemux *decoding_demux)
+{
+			/* when seeking, we have to ensure that all buffers are flushed.
+			   there are basically 3 buffers:
+			   a.) the filepush's internal buffer
+			   b.) the PVR buffer (before demux)
+			   c.) the ratebuffer (after demux)
+
+			   it's important to clear them in the correct order, otherwise
+			   the ratebuffer (for example) would immediately refill from
+			   the not-yet-flushed PVR buffer.
+			*/
+
+	m_pvr_thread->pause();
+		/* flush internal filepush buffer */
+	m_pvr_thread->flush();
+		/* HACK: flush PVR buffer */
+	::ioctl(m_pvr_fd_dst, 0);
+
+		/* flush ratebuffers (video, audio) */
+	if (decoding_demux)
+		decoding_demux->flush();
+
+		/* demux will also flush all decoder.. */
+		/* resume will re-query the SG */
+	m_pvr_thread->resume();
+}
+
+DEFINE_REF(eCueSheet);
+
+eCueSheet::eCueSheet()
+{
+	m_skipmode_ratio = 0;
+}
+
+void eCueSheet::seekTo(int relative, const pts_t &pts)
+{
+	m_lock.WrLock();
+	m_seek_requests.push_back(std::pair<int, pts_t>(relative, pts));
+	m_lock.Unlock();
+	m_event(evtSeek);
+}
+
+void eCueSheet::clear()
+{
+	m_lock.WrLock();
+	m_spans.clear();
+	m_lock.Unlock();
+}
+
+void eCueSheet::addSourceSpan(const pts_t &begin, const pts_t &end)
+{
+	ASSERT(begin < end);
+	m_lock.WrLock();
+	m_spans.push_back(std::pair<pts_t, pts_t>(begin, end));
+	m_lock.Unlock();
+}
+
+void eCueSheet::commitSpans()
+{
+	m_event(evtSpanChanged);
+}
+
+void eCueSheet::setSkipmode(const pts_t &ratio)
+{
+	m_lock.WrLock();
+	m_skipmode_ratio = ratio;
+	m_lock.Unlock();
+	m_event(evtSkipmode);
+}
+
+void eCueSheet::setDecodingDemux(iDVBDemux *demux, iTSMPEGDecoder *decoder)
+{
+	m_decoding_demux = demux;
+	m_decoder = decoder;
+}
+
+RESULT eCueSheet::connectEvent(const Slot1<void,int> &event, ePtr<eConnection> &connection)
+{
+	connection = new eConnection(this, m_event.connect(event));
+	return 0;
+}
diff -Nur enigma2-nightly/lib/dvb/dvb.h enigma2-nightly.spark/lib/dvb/dvb.h
--- enigma2-nightly/lib/dvb/dvb.h	2010-08-11 18:16:49.566796293 +0800
+++ enigma2-nightly.spark/lib/dvb/dvb.h	2010-08-11 18:13:23.996876000 +0800
@@ -135,7 +135,11 @@
 	DECLARE_REF(eDVBResourceManager);
 	int avail, busy;
 
+#if defined(__sh__)
+	enum { DM7025, DM800, DM500HD, DM8000, UFS910, UFS912, UFS922, TF7700HDPVR, HDBOX, HL101, CUBEREVO, CUBEREVO_MINI, CUBEREVO_MINI2, CUBEREVO_MINI_FTA, CUBEREVO_250HD, CUBEREVO_9500HD, CUBEREVO_2000HD, OCTAGON1008, VIP1_V2, VIP2_V1, SPARK};
+#else
 	enum { DM7025, DM800, DM500HD, DM8000 };
+#endif
 
 	int m_boxtype;
 
@@ -245,6 +249,10 @@
 		/* cannot be used for PVR channels. */
 	RESULT setChannel(const eDVBChannelID &id, ePtr<iDVBFrontendParameters> &feparam);
 	eDVBChannelID getChannelID() { return m_channel_id; }
+#if defined(__sh__)
+//see filepush.h
+	int getSkipMode() { return m_skipmode_m; }
+#endif
 
 	RESULT connectStateChange(const Slot1<void,iDVBChannel*> &stateChange, ePtr<eConnection> &connection);
 	RESULT connectEvent(const Slot2<void,iDVBChannel*,int> &eventChange, ePtr<eConnection> &connection);
diff -Nur enigma2-nightly/lib/dvb/epgcache.cpp enigma2-nightly.spark/lib/dvb/epgcache.cpp
--- enigma2-nightly/lib/dvb/epgcache.cpp	2010-08-11 18:16:49.571757875 +0800
+++ enigma2-nightly.spark/lib/dvb/epgcache.cpp	2010-08-11 18:12:24.893805921 +0800
@@ -18,11 +18,23 @@
 #include <lib/python/python.h>
 #include <dvbsi++/descriptor_tag.h>
 
+#ifdef __sh__
+#include "include/shmE2.h"
+
+char epg_file[256] = "";
+static int m_epg_days = 14;
+extern char *shm;
+#endif
+
 int eventData::CacheSize=0;
 descriptorMap eventData::descriptors;
 __u8 eventData::data[4108];
 extern const uint32_t crc32_table[256];
 
+#if ENABLE_FREESAT
+static int enable_freesat = 1;
+#endif
+
 const eServiceReference &handleGroup(const eServiceReference &ref)
 {
 	if (ref.flags & eServiceReference::isGroup)
@@ -115,11 +127,25 @@
 	int tmp = ByteSize-10;
 	memcpy(data, EITdata, 10);
 	int descriptors_length=0;
+#ifndef __sh__
 	__u32 *p = (__u32*)(EITdata+10);
+#else
+/* Dagobert: fix not aligned access */
+		__u8 *p = (__u8*)(EITdata+10);
+#endif
 	while(tmp>3)
 	{
+#ifndef __sh__
 		descriptorMap::iterator it =
 			descriptors.find(*p++);
+#else
+		__u32 index = p[3] << 24 | p[2] << 16 | p[1] << 8 | p[0];
+/* eDebug("index %d %x, %x %x %x %x\n", index, index, p[0], p[1], p[2], p[3]);			*/
+		descriptorMap::iterator it =
+			descriptors.find(index);
+
+		p += 4;
+#endif
 		if ( it != descriptors.end() )
 		{
 			int b = it->second.second[1]+2;
@@ -128,7 +154,11 @@
 			descriptors_length += b;
 		}
 		else
+#ifndef __sh__
 			eFatal("LINE %d descriptor not found in descriptor cache %08x!!!!!!", __LINE__, *(p-1));
+#else
+			eDebug("LINE %d descriptor not found in descriptor cache %08x!!!!!!", __LINE__, *(p-4));
+#endif
 		tmp-=4;
 	}
 	ASSERT(pos <= 4108);
@@ -142,12 +172,28 @@
 	if ( ByteSize )
 	{
 		CacheSize -= ByteSize;
+
+#ifndef __sh__
 		__u32 *d = (__u32*)(EITdata+10);
+#else
+/* Dagobert: fix not aligned access */
+		__u8 *d = (__u8*)(EITdata+10);
+#endif
 		ByteSize -= 10;
 		while(ByteSize>3)
 		{
+#ifndef __sh__
 			descriptorMap::iterator it =
 				descriptors.find(*d++);
+#else
+			__u32 index = d[3] << 24 | d[2] << 16 | d[1] << 8 | d[0];
+/* eDebug("index %d %x, %x %x %x %x\n", index, index, d[0], d[1], d[2], d[3]);			*/
+			descriptorMap::iterator it =
+				descriptors.find(index);
+				
+			d += 4;
+#endif
+
 			if ( it != descriptors.end() )
 			{
 				descriptorPair &p = it->second;
@@ -159,7 +205,15 @@
 				}
 			}
 			else
+			{
+#ifndef __sh__
 				eFatal("LINE %d descriptor not found in descriptor cache %08x!!!!!!", __LINE__, *(d-1));
+#else
+//Dagobert: currently this happens sporadicly on ufs922 (with new skin). Not sure why
+//we must observe this!
+				eDebug("LINE %d descriptor not found in descriptor cache %08x!!!!!!", __LINE__, *(d-4));
+#endif
+			}
 			ByteSize -= 4;
 		}
 		delete [] EITdata;
@@ -231,6 +285,25 @@
 		if (eDVBLocalTimeHandler::getInstance()->ready())
 			timeUpdated();
 	}
+#if ENABLE_FREESAT
+	FILE *ffd;
+	ffd = fopen("/var/usr/local/share/enigma2/freesat.t1", "r");
+	if(ffd)
+	{
+		enable_freesat = 1;
+		fclose(ffd);
+	}
+	else
+	{
+		ffd = fopen("/usr/local/share/enigma2/freesat.t1", "r");
+		if(ffd)
+		{
+			enable_freesat = 1; fclose(ffd);
+		}
+		else
+			enable_freesat = 0;
+	}
+#endif
 	instance=this;
 }
 
@@ -337,6 +410,23 @@
 					return;
 				}
 #endif
+#if ENABLE_FREESAT
+				if(enable_freesat)
+				{
+					res = demux->createSectionReader( this, data.m_FreeSatScheduleOtherReader );
+					if ( res )
+					{
+						eDebug("[eEPGCache] couldnt initialize FreeSat reader!!");
+						return;
+					}
+					res = demux->createSectionReader( this, data.m_FreeSatScheduleOtherReader2 );
+					if ( res )
+					{
+						eDebug("[eEPGCache] couldnt initialize FreeSat reader 2!!");
+						return;
+					}
+				}
+#endif
 				messages.send(Message(Message::startChannel, chan));
 				// -> gotMessage -> changedService
 			}
@@ -519,7 +609,11 @@
 		if ( TM == 3599 )
 			goto next;
 
+#ifdef __sh__
+		if ( TM != 3599 && (TM+duration < now || TM > now+m_epg_days*24*60*60) )
+#else
 		if ( TM != 3599 && (TM+duration < now || TM > now+14*24*60*60) )
+#endif
 			goto next;
 
 		if ( now <= (TM+duration) || TM == 3599 /*NVOD Service*/ )  // old events should not be cached
@@ -954,6 +1048,9 @@
 {
 	hasStarted();
 	nice(4);
+#ifdef __sh__ 
+	InitEPGBlock (); 
+#endif 
 	load();
 	cleanLoop();
 	runLoop();
@@ -962,10 +1059,27 @@
 
 void eEPGCache::load()
 {
+#ifdef __sh__
+	m_epg_days = 14;
+	char epg_days[3] = "";
+	if(getshmentry(shm, "epg_days=", epg_days, 3) == 1)
+		m_epg_days = atoi(epg_days);
+
+	if(getshmentry(shm, "epg_file=", epg_file, 256) != 1)
+		strcpy(epg_file, "/hdd/epg.dat");
+
+	FILE *f = fopen(epg_file, "r");
+#else
 	FILE *f = fopen("/hdd/epg.dat", "r");
+#endif
 	if (f)
 	{
+#ifdef __sh__
+		if(checkshmentry(shm, "not_del_epg") != 1)
+			unlink(epg_file);
+#else
 		unlink("/hdd/epg.dat");
+#endif
 		int size=0;
 		int cnt=0;
 #if 0
@@ -1027,7 +1141,11 @@
 					eventDB[key]=std::pair<eventMap,timeMap>(evMap,tmMap);
 				}
 				eventData::load(f);
+#ifdef __sh__
+				eDebug("[EPGC] %d events read from %s", cnt, epg_file);
+#else
 				eDebug("[EPGC] %d events read from /hdd/epg.dat", cnt);
+#endif
 #ifdef ENABLE_PRIVATE_EPG
 				char text2[11];
 				fread( text2, 11, 1, f);
@@ -1077,7 +1195,20 @@
 {
 	struct statfs s;
 	off64_t tmp;
+#ifdef __sh__
+	char epg_path[256]="";
+	strcpy(epg_path, epg_file);
+
+	char *lpos=strrchr(epg_path, '/');
+	if(lpos != '\0')
+		*++lpos='\0';
+	else
+		strcpy(epg_path, ".");
+
+	if (statfs(epg_path, &s)<0)
+#else
 	if (statfs("/hdd", &s)<0)
+#endif
 		tmp=0;
 	else
 	{
@@ -1086,7 +1217,7 @@
 	}
 
 	// prevent writes to builtin flash
-	if ( tmp < 1024*1024*50 ) // storage size < 50MB
+	if ( tmp < 1024*1024*25 ) // storage size < 50MB // for Duckboxes changed to < 25MB even to use UFS912 Flash for EPG
 		return;
 
 	// check for enough free space on storage
@@ -1095,7 +1226,11 @@
 	if ( tmp < (eventData::CacheSize*12)/10 ) // 20% overhead
 		return;
 
+#ifdef __sh__
+	FILE *f = fopen(epg_file, "w");
+#else
 	FILE *f = fopen("/hdd/epg.dat", "w");
+#endif
 	int cnt=0;
 	if ( f )
 	{
@@ -1120,7 +1255,11 @@
 				++cnt;
 			}
 		}
+#ifdef __sh__
+		eDebug("[EPGC] %d events written to %s", cnt, epg_file);
+#else
 		eDebug("[EPGC] %d events written to /hdd/epg.dat", cnt);
+#endif
 		eventData::save(f);
 #ifdef ENABLE_PRIVATE_EPG
 		const char* text3 = "PRIVATE_EPG";
@@ -1203,11 +1342,23 @@
 			seenSections[i].clear();
 			calcedSections[i].clear();
 		}
+#ifdef ENABLE_FREESAT
+		if(enable_freesat)
+		{
+			cleanupFreeSat();
+		}
+#endif
 		singleLock l(cache->cache_lock);
 		cache->channelLastUpdated[channel->getChannelID()] = ::time(0);
 #ifdef ENABLE_MHW_EPG
 		cleanup();
 #endif
+#ifdef ENABLE_FREESAT
+		if(enable_freesat)
+		{
+			cleanupFreeSat();
+		}
+#endif
 		return true;
 	}
 	return false;
@@ -1223,6 +1374,12 @@
 		seenSections[i].clear();
 		calcedSections[i].clear();
 	}
+#ifdef ENABLE_FREESAT
+		if(enable_freesat)
+		{
+			cleanupFreeSat();
+		}
+#endif
 
 	eDVBSectionFilterMask mask;
 	memset(&mask, 0, sizeof(mask));
@@ -1249,6 +1406,27 @@
 	mask.mask[1] = 0;
 	m_MHWTimeoutet=false;
 #endif
+#ifdef ENABLE_FREESAT
+	if(enable_freesat)
+	{
+		mask.pid = 3842;
+		mask.flags = eDVBSectionFilterMask::rfCRC;
+		mask.data[0] = 0x60;
+		mask.mask[0] = 0xFE;
+		m_FreeSatScheduleOtherReader->connectRead(slot(*this, &eEPGCache::channel_data::readFreeSatScheduleOtherData), m_FreeSatScheduleOtherConn);
+		m_FreeSatScheduleOtherReader->start(mask);
+		/*
+	 	* faster pid, available on ITV HD transponder.
+	 	* We rely on the fact that we have either of the two,
+	 	* never both. (both readers share the same data callback
+	 	* and status maps)
+	 	*/
+		mask.pid = 3003;
+		m_FreeSatScheduleOtherReader2->connectRead(slot(*this, &eEPGCache::channel_data::readFreeSatScheduleOtherData), m_FreeSatScheduleOtherConn2);
+		m_FreeSatScheduleOtherReader2->start(mask);
+		isRunning |= FREESAT_SCHEDULE_OTHER;
+	}
+#endif
 
 	mask.pid = 0x12;
 	mask.flags = eDVBSectionFilterMask::rfCRC;
@@ -1306,6 +1484,21 @@
 			m_ScheduleOtherReader->stop();
 			m_ScheduleOtherConn=0;
 		}
+#ifdef ENABLE_FREESAT
+		if(enable_freesat)
+		{
+			if ( !(haveData&FREESAT_SCHEDULE_OTHER) && (isRunning&FREESAT_SCHEDULE_OTHER) )
+			{
+				eDebug("[EPGC] abort non avail FreeSat schedule_other reading");
+				isRunning &= ~FREESAT_SCHEDULE_OTHER;
+				m_FreeSatScheduleOtherReader->stop();
+				m_FreeSatScheduleOtherReader2->stop();
+				m_FreeSatScheduleOtherConn=0;
+				m_FreeSatScheduleOtherConn2=0;
+				cleanupFreeSat();
+			}
+		}
+#endif
 		if ( !(haveData&VIASAT) && (isRunning&VIASAT) )
 		{
 			eDebug("[EPGC] abort non avail viasat reading");
@@ -1336,6 +1529,12 @@
 				seenSections[i].clear();
 				calcedSections[i].clear();
 			}
+#ifdef ENABLE_FREESAT
+			if(enable_freesat)
+			{
+				cleanupFreeSat();
+			}
+#endif
 		}
 	}
 	++state;
@@ -1365,6 +1564,12 @@
 		seenSections[i].clear();
 		calcedSections[i].clear();
 	}
+#ifdef ENABLE_FREESAT
+	if(enable_freesat)
+	{
+		cleanupFreeSat();
+	}
+#endif
 	abortTimer->stop();
 	zapTimer->stop();
 	if (isRunning)
@@ -1388,6 +1593,19 @@
 			m_ScheduleOtherReader->stop();
 			m_ScheduleOtherConn=0;
 		}
+#ifdef ENABLE_FREESAT
+		if(enable_freesat)
+		{
+			if (isRunning & FREESAT_SCHEDULE_OTHER)
+			{
+				isRunning &= ~FREESAT_SCHEDULE_OTHER;
+				m_FreeSatScheduleOtherReader->stop();
+				m_FreeSatScheduleOtherReader2->stop();
+				m_FreeSatScheduleOtherConn=0;
+				m_FreeSatScheduleOtherConn2=0;
+			}
+		}
+#endif
 		if (isRunning & VIASAT)
 		{
 			isRunning &= ~VIASAT;
@@ -1414,7 +1632,51 @@
 	pthread_mutex_unlock(&channel_active);
 }
 
+#ifdef __sh__
+void eEPGCache::InitEPGBlock ()
+{
+	FILE *fd = NULL;
+	fd = fopen ("/etc/enigma2/epg.blacklist", "r");
+	if (fd)
+	{
+		char line[256];
+		while (fgets (line, sizeof(line), fd))
+		{
+			char* tmp;
+			epg_block_list_t block_item;
+			if (!(tmp = strtok (line, ","))) continue;
+			block_item.service_id = atoi (tmp);
+			if (!(tmp = strtok (NULL, ","))) continue;
+			block_item.transport_stream_id = atoi (tmp);
+			if (!(tmp = strtok (NULL, ","))) continue;
+			block_item.original_network_id = atoi (tmp);
+			if (!(tmp = strtok (NULL, ","))) continue;
+			block_item.source = atoi (tmp);
+			block_list.push_back (block_item);
+		}
+		fclose (fd);
+		eDebug ("[EPGC] Blacklist loaded");
+	}
+	else eDebug ("[EPGC] No blacklist found");
+}
 
+bool eEPGCache::CheckEPGBlock (int32_t service_id, uint16_t transport_stream_id, uint16_t original_network_id, int source)
+{
+	std::list<epg_block_list_t>::iterator i;
+	
+	for (i=block_list.begin(); i != block_list.end(); ++i)
+		if ((i->service_id == service_id || service_id == -1) &&
+			i->transport_stream_id == transport_stream_id &&
+			i->original_network_id == original_network_id &&
+			i->source == source)
+	{
+		eDebug ("[EPGC] Blacklist active!");
+		return true;
+	}
+	
+	return false;
+}
+#endif
 void eEPGCache::channel_data::readDataViasat( const __u8 *data)
 {
 	__u8 *d=0;
@@ -1428,6 +1690,47 @@
 	int source;
 	int map;
 	iDVBSectionReader *reader=NULL;
+#ifdef __sh__
+/* Dagobert: this is still very hacky, but currently I cant find
+ * the origin of the readData call. I think the caller is 
+ * responsible for the unaligned data pointer in this call.
+ * So we malloc our own memory here which _should_ be aligned.
+ *
+ * TODO: We should search for the origin of this call. As I
+ * said before I need an UML Diagram or must try to import
+ * e2 and all libs into an IDE for better overview ;)
+ *
+ */ 
+	const __u8 *aligned_data;
+	bool isNotAligned = false;
+	
+	if ((unsigned int) data % 4 != 0)
+		isNotAligned = true;
+		
+	if (isNotAligned)
+	{
+	
+	   /* see HILO macro and eit.h */
+	   int len = ((data[1] & 0x0F) << 8 | data[2]) -1;
+
+           /*eDebug("len %d %x, %x %x\n", len, len, data[1], data[2]);*/
+
+	   if ( EIT_SIZE >= len )
+		   return;
+
+	   aligned_data = (const __u8 *) malloc(len);
+
+	   if ((unsigned int)aligned_data % 4 != 0)
+	   {
+		   eDebug("eEPGCache::channel_data::readData: ERRORERRORERROR: unaligned data pointer %p\n", aligned_data);
+	   }
+
+           /*eDebug("%p %p\n", aligned_data, data); */
+	   memcpy((void *) aligned_data, (const __u8 *) data, len);
+	   data = aligned_data;	
+	}	
+#endif
+
 	switch(data[0])
 	{
 		case 0x4E ... 0x4F:
@@ -1490,6 +1793,17 @@
 	else
 	{
 		eit_t *eit = (eit_t*) data;
+#ifdef __sh__
+		if (eEPGCache::getInstance()->CheckEPGBlock (eit->service_id_hi << 8 | eit->service_id_lo,
+							eit->transport_stream_id_hi << 8 | eit->transport_stream_id_lo,
+							eit->original_network_id_hi << 8 | eit->original_network_id_lo,
+							source))
+		{
+			if (isNotAligned)
+			   free((void *) aligned_data);
+			return;
+		}
+#endif
 		__u32 sectionNo = data[0] << 24;
 		sectionNo |= data[3] << 16;
 		sectionNo |= data[4] << 8;
@@ -1517,8 +1831,151 @@
 			cache->sectionRead(data, source, this);
 		}
 	}
+#ifdef __sh__
+	if (isNotAligned)
+	   free((void *)aligned_data);
+#endif	
+}
+#if ENABLE_FREESAT
+freesatEITSubtableStatus::freesatEITSubtableStatus(u_char version, __u8 maxSection) : version(version)
+{
+	if(enable_freesat)
+		initMap(maxSection);
+}
+
+void freesatEITSubtableStatus::initMap(__u8 maxSection)
+{
+	if(enable_freesat)
+	{
+		int i, maxSectionIdx = maxSection / 8;
+		for (i = 0; i < 32; i++)
+		{
+			sectionMap[i] = (i <= maxSectionIdx ? 0x0100 : 0x0000 );
+		}
+	}
+ }
+ 
+bool freesatEITSubtableStatus::isSectionPresent(__u8 sectionNo)
+{
+	if(enable_freesat)
+	{
+		__u8 sectionIdx = sectionNo / 8;
+		__u8 bitOffset = sectionNo % 8;
+	
+		return ((sectionMap[sectionIdx] & (1 << bitOffset)) != 0);
+	}
+}
+
+bool freesatEITSubtableStatus::isCompleted()
+{
+	if(enable_freesat)
+	{
+		__u32 i = 0;
+		__u8 calc;
+
+		while ( i < 32 )
+		{
+			calc = sectionMap[i] >> 8;
+			if (! calc) return true; // Last segment passed
+			if (calc ^ ( sectionMap[i] & 0xFF ) ) // Segment not fully found
+				return false;
+			i++;
+		}
+		return true; // All segments ok
+	}
+}
+
+void freesatEITSubtableStatus::seen(__u8 sectionNo, __u8 maxSegmentSection)
+{
+	if(enable_freesat)
+	{
+		__u8 sectionIdx = sectionNo / 8;
+		__u8 bitOffset = sectionNo % 8;
+		__u8 maxBitOffset = maxSegmentSection % 8;
+
+		sectionMap[sectionIdx] &= 0x00FF; // Clear calc map
+		sectionMap[sectionIdx] |= ((0x01FF << maxBitOffset) & 0xFF00); // Set calc map
+		sectionMap[sectionIdx] |= (1 << bitOffset); // Set seen map
+	}
+}
+
+bool freesatEITSubtableStatus::isVersionChanged(u_char testVersion)
+{
+	if(enable_freesat)
+		return version != testVersion;
 }
 
+void freesatEITSubtableStatus::updateVersion(u_char newVersion, __u8 maxSection)
+{
+	if(enable_freesat)
+	{
+		version = newVersion;
+		initMap(maxSection);
+	}
+}
+
+void eEPGCache::channel_data::cleanupFreeSat()
+{
+	if(enable_freesat)
+	{
+		m_FreeSatSubTableStatus.clear();
+		m_FreesatTablesToComplete = 0;
+	}
+}
+
+void eEPGCache::channel_data::readFreeSatScheduleOtherData( const __u8 *data)
+{
+	if(enable_freesat)
+	{
+		eit_t *eit = (eit_t*) data;
+		__u32 subtableNo = data[0] << 24; // Table ID
+		subtableNo |= data[3] << 16; // Service ID Hi
+		subtableNo |= data[4] << 8; // Service ID Lo
+
+		// Check for sub-table version in map
+		std::map<__u32, freesatEITSubtableStatus> &freeSatSubTableStatus = this->m_FreeSatSubTableStatus;
+		std::map<__u32, freesatEITSubtableStatus>::iterator itmap = freeSatSubTableStatus.find(subtableNo);
+
+		freesatEITSubtableStatus *fsstatus;
+		if ( itmap == freeSatSubTableStatus.end() )
+		{
+			// New sub table. Store version.
+			eDebug("[EPGC] New subtable (%x) version (%d) now/next (%d) tsid (%x/%x) onid (%x/%x)", subtableNo, eit->version_number, eit->current_next_indicator, eit->transport_stream_id_hi, eit->transport_stream_id_lo, eit->original_network_id_hi, eit->original_network_id_lo);
+			fsstatus = new freesatEITSubtableStatus(eit->version_number, eit->last_section_number);
+			m_FreesatTablesToComplete++;
+			freeSatSubTableStatus.insert(std::pair<__u32,freesatEITSubtableStatus>(subtableNo, *fsstatus));
+		}
+		else
+		{
+			fsstatus = &itmap->second;
+			// Existing subtable. Check version. Should check current / next as well? Seems to always be current for Freesat
+			if ( fsstatus->isVersionChanged(eit->version_number) )
+			{
+				eDebug("[EPGC] FS subtable (%x) version changed (%d) now/next (%d)", subtableNo, eit->version_number, eit->current_next_indicator);
+				m_FreesatTablesToComplete++;
+				fsstatus->updateVersion(eit->version_number, eit->last_section_number);
+			}
+			else
+			{
+				if ( fsstatus->isSectionPresent(eit->section_number) )
+				{
+//					eDebug("[EPGC] DUP FS sub/sec/ver (%x/%d/%d)", subtableNo, eit->section_number, eit->version_number);
+					return;
+				}
+			}
+		}
+
+//	eDebug("[EPGC] New FS sub/sec/ls/lss/ver (%x/%d/%d/%d/%d)", subtableNo, eit->section_number, eit->last_section_number, eit->segment_last_section_number, eit->version_number);
+		fsstatus->seen(eit->section_number, eit->segment_last_section_number);
+		if (fsstatus->isCompleted())
+		{
+			m_FreesatTablesToComplete--;
+			eDebug("[EPGC] Subtable %x complete %d left", subtableNo, m_FreesatTablesToComplete); 
+		}
+		cache->sectionRead(data, FREESAT_SCHEDULE_OTHER, this);
+	}
+}
+#endif
 RESULT eEPGCache::lookupEventTime(const eServiceReference &service, time_t t, const eventData *&result, int direction)
 // if t == -1 we search the current event...
 {
@@ -2243,11 +2700,22 @@
 						{
 							__u8 *data = evData->EITdata;
 							int tmp = evData->ByteSize-10;
+#ifndef __sh__
 							__u32 *p = (__u32*)(data+10);
+#else
+/* Dagobert: Alignment fix */
+							__u8 *p = (__u8*)(data+10);
+#endif
 								// search short and extended event descriptors
 							while(tmp>3)
 							{
+#ifndef __sh__
 								__u32 crc = *p++;
+#else
+/* Dagobert: Alignment fix */
+								__u32 crc = p[3] << 24 | p[2] << 16 | p[1] << 8 | p[0];
+								p += 4;
+#endif
 								descriptorMap::iterator it =
 									eventData::descriptors.find(crc);
 								if (it != eventData::descriptors.end())
@@ -2425,12 +2893,23 @@
 					continue;
 				__u8 *data = evit->second->EITdata;
 				int tmp = evit->second->ByteSize-10;
+#ifndef __sh__
 				__u32 *p = (__u32*)(data+10);
+#else
+/* Dagobert: Alignment fix */
+				__u8 *p = (__u8*)(data+10);
+#endif
 				// check if any of our descriptor used by this event
 				int cnt=-1;
 				while(tmp>3)
 				{
+#ifndef __sh__
 					__u32 crc32 = *p++;
+#else
+/* Dagobert: Alignment fix */
+					__u32 crc32 = p[3] << 24 | p[2] << 16 | p[1] << 8 | p[0];
+					p += 4;
+#endif
 					for ( int i=0; i <= descridx; ++i)
 					{
 						if (descr[i] == crc32)  // found...
diff -Nur enigma2-nightly/lib/dvb/epgcache.h enigma2-nightly.spark/lib/dvb/epgcache.h
--- enigma2-nightly/lib/dvb/epgcache.h	2010-08-11 18:16:49.573738513 +0800
+++ enigma2-nightly.spark/lib/dvb/epgcache.h	2010-08-11 18:12:24.896885530 +0800
@@ -2,7 +2,12 @@
 #define __epgcache_h_
 
 #define ENABLE_PRIVATE_EPG 1
+#if defined(__sh__) 
+#define ENABLE_MHW_EPG 1
+#define ENABLE_FREESAT 1 
+#else
 //#define ENABLE_MHW_EPG 1
+#endif
 
 #ifndef SWIG
 
@@ -165,6 +170,24 @@
 	}
 };
 #endif
+#ifdef ENABLE_FREESAT
+#include <bitset>
+class freesatEITSubtableStatus
+{
+private:
+	u_char version;
+	__u16 sectionMap[32];
+	void initMap(__u8 maxSection);
+
+public:
+	freesatEITSubtableStatus(u_char version, __u8 maxSection);
+	bool isSectionPresent(__u8 sectionNo);
+	void seen(__u8 sectionNo, __u8 maxSegmentSection);
+	bool isVersionChanged(u_char testVersion);
+	void updateVersion(u_char newVersion, __u8 maxSection);
+	bool isCompleted();
+};
+#endif
 
 class eEPGCache: public eMainloop, private eThread, public Object
 {
@@ -182,6 +205,14 @@
 		ePtr<eConnection> m_stateChangedConn, m_NowNextConn, m_ScheduleConn, m_ScheduleOtherConn, m_ViasatConn;
 		ePtr<iDVBSectionReader> m_NowNextReader, m_ScheduleReader, m_ScheduleOtherReader, m_ViasatReader;
 		tidMap seenSections[4], calcedSections[4];
+#ifdef ENABLE_FREESAT
+		ePtr<eConnection> m_FreeSatScheduleOtherConn, m_FreeSatScheduleOtherConn2;
+		ePtr<iDVBSectionReader> m_FreeSatScheduleOtherReader, m_FreeSatScheduleOtherReader2;
+		std::map<__u32, freesatEITSubtableStatus> m_FreeSatSubTableStatus;
+		__u32 m_FreesatTablesToComplete;
+		void readFreeSatScheduleOtherData(const __u8 *data);
+		void cleanupFreeSat();
+#endif
 #ifdef ENABLE_PRIVATE_EPG
 		ePtr<eTimer> startPrivateTimer;
 		int m_PrevVersion;
@@ -232,6 +263,11 @@
 #ifdef ENABLE_MHW_EPG
 	,MHW=8
 #endif
+#ifdef ENABLE_FREESAT
+	,FREESAT_NOWNEXT=16
+	,FREESAT_SCHEDULE=32
+	,FREESAT_SCHEDULE_OTHER=64
+#endif
 	,VIASAT=16
 	};
 	struct Message
@@ -291,7 +327,9 @@
 
 // called from epgcache thread
 	void save();
+#ifndef __sh__
 	void load();
+#endif
 #ifdef ENABLE_PRIVATE_EPG
 	void privateSectionRead(const uniqueEPGKey &, const __u8 *);
 #endif
@@ -312,8 +350,24 @@
 	eEPGCache();
 	~eEPGCache();
 #endif // SWIG
+#ifdef __sh__
+	typedef struct epg_block_list_s
+	{
+		uint16_t	service_id;
+		uint16_t	transport_stream_id;
+		uint16_t	original_network_id;
+		int 		source;
+	} epg_block_list_t;
+	std::list<epg_block_list_t> block_list;
+#endif
 public:
 	static eEPGCache *getInstance() { return instance; }
+#ifdef __sh__
+	void load();
+	void InitEPGBlock ();
+	bool CheckEPGBlock (int32_t service_id, uint16_t transport_stream_id, uint16_t original_network_id, int source);
+#endif
+
 #ifndef SWIG
 	eEPGCache();
 	~eEPGCache();
diff -Nur enigma2-nightly/lib/dvb/frontend.cpp enigma2-nightly.spark/lib/dvb/frontend.cpp
--- enigma2-nightly/lib/dvb/frontend.cpp	2010-08-11 18:16:49.573738513 +0800
+++ enigma2-nightly.spark/lib/dvb/frontend.cpp	2010-08-11 18:12:24.791697383 +0800
@@ -2061,8 +2061,22 @@
 					return -EINVAL;
 			}
 #if HAVE_DVB_API_VERSION < 5
+#if not defined(__sh__)  
 			parm_inversion |= (feparm.rolloff << 2); // Hack.. we use bit 2..3 of inversion param for rolloff
 			parm_inversion |= (feparm.pilot << 4); // Hack.. we use bit 4..5 of inversion param for pilot
+#else 
+//Dagobert: Interesting: I must have misted the fact that someone has removed this since a long time. 
+//So it is needed by the driver (cxNNNNN.c) but it seems not be very important ;) 
+			int hack; 
+
+			hack = (int) parm_inversion; 
+
+			hack |= (int) (feparm.rolloff << 2); // Hack.. we use bit 2..3 of inversion param for rolloff 
+			hack |= (int) (feparm.pilot << 4); // Hack.. we use bit 4..5 of inversion param for pilot 
+
+			parm_inversion = (fe_spectral_inversion_t) hack; 
+#endif 
+
 			if (feparm.modulation == eDVBFrontendParametersSatellite::Modulation_8PSK) 
 			{
 				parm_u_qpsk_fec_inner = (fe_code_rate_t)((int)parm_u_qpsk_fec_inner+9);
diff -Nur enigma2-nightly/lib/dvb/frontend.cpp.orig enigma2-nightly.spark/lib/dvb/frontend.cpp.orig
--- enigma2-nightly/lib/dvb/frontend.cpp.orig	1970-01-01 08:00:00.000000000 +0800
+++ enigma2-nightly.spark/lib/dvb/frontend.cpp.orig	2010-08-11 18:11:32.778531504 +0800
@@ -0,0 +1,2714 @@
+#include <lib/dvb/dvb.h>
+#include <lib/dvb/frontendparms.h>
+#include <lib/base/eerror.h>
+#include <lib/base/nconfig.h> // access to python config
+#include <errno.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+
+#ifndef I2C_SLAVE_FORCE
+#define I2C_SLAVE_FORCE	0x0706
+#endif
+
+#if HAVE_DVB_API_VERSION < 3
+#include <ost/frontend.h>
+#include <ost/sec.h>
+#define QAM_AUTO				(Modulation)6
+#define TRANSMISSION_MODE_AUTO	(TransmitMode)2
+#define BANDWIDTH_AUTO			(BandWidth)3
+#define GUARD_INTERVAL_AUTO		(GuardInterval)4
+#define HIERARCHY_AUTO			(Hierarchy)4
+#define parm_frequency parm.Frequency
+#define parm_inversion parm.Inversion
+#define parm_u_qpsk_symbol_rate parm.u.qpsk.SymbolRate
+#define parm_u_qpsk_fec_inner parm.u.qpsk.FEC_inner
+#define parm_u_qam_symbol_rate parm.u.qam.SymbolRate
+#define parm_u_qam_fec_inner parm.u.qam.FEC_inner
+#define parm_u_qam_modulation parm.u.qam.QAM
+#define parm_u_ofdm_bandwidth parm.u.ofdm.bandWidth
+#define parm_u_ofdm_code_rate_LP parm.u.ofdm.LP_CodeRate
+#define parm_u_ofdm_code_rate_HP parm.u.ofdm.HP_CodeRate
+#define parm_u_ofdm_constellation parm.u.ofdm.Constellation
+#define parm_u_ofdm_transmission_mode parm.u.ofdm.TransmissionMode
+#define parm_u_ofdm_guard_interval parm.u.ofdm.guardInterval
+#define parm_u_ofdm_hierarchy_information parm.u.ofdm.HierarchyInformation
+#else
+#include <linux/dvb/frontend.h>
+#define parm_frequency parm.frequency
+#define parm_inversion parm.inversion
+#define parm_u_qpsk_symbol_rate parm.u.qpsk.symbol_rate
+#define parm_u_qpsk_fec_inner parm.u.qpsk.fec_inner
+#define parm_u_qam_symbol_rate parm.u.qam.symbol_rate
+#define parm_u_qam_fec_inner parm.u.qam.fec_inner
+#define parm_u_qam_modulation parm.u.qam.modulation
+#define parm_u_ofdm_bandwidth parm.u.ofdm.bandwidth
+#define parm_u_ofdm_code_rate_LP parm.u.ofdm.code_rate_LP
+#define parm_u_ofdm_code_rate_HP parm.u.ofdm.code_rate_HP
+#define parm_u_ofdm_constellation parm.u.ofdm.constellation
+#define parm_u_ofdm_transmission_mode parm.u.ofdm.transmission_mode
+#define parm_u_ofdm_guard_interval parm.u.ofdm.guard_interval
+#define parm_u_ofdm_hierarchy_information parm.u.ofdm.hierarchy_information
+#if HAVE_DVB_API_VERSION < 5
+	#define FEC_S2_QPSK_1_2 (fe_code_rate_t)(FEC_AUTO+1)
+	#define FEC_S2_QPSK_2_3 (fe_code_rate_t)(FEC_S2_QPSK_1_2+1)
+	#define FEC_S2_QPSK_3_4 (fe_code_rate_t)(FEC_S2_QPSK_2_3+1)
+	#define FEC_S2_QPSK_5_6 (fe_code_rate_t)(FEC_S2_QPSK_3_4+1)
+	#define FEC_S2_QPSK_7_8 (fe_code_rate_t)(FEC_S2_QPSK_5_6+1)
+	#define FEC_S2_QPSK_8_9 (fe_code_rate_t)(FEC_S2_QPSK_7_8+1)
+	#define FEC_S2_QPSK_3_5 (fe_code_rate_t)(FEC_S2_QPSK_8_9+1)
+	#define FEC_S2_QPSK_4_5 (fe_code_rate_t)(FEC_S2_QPSK_3_5+1)
+	#define FEC_S2_QPSK_9_10 (fe_code_rate_t)(FEC_S2_QPSK_4_5+1)
+	#define FEC_S2_8PSK_1_2 (fe_code_rate_t)(FEC_S2_QPSK_9_10+1)
+	#define FEC_S2_8PSK_2_3 (fe_code_rate_t)(FEC_S2_8PSK_1_2+1)
+	#define FEC_S2_8PSK_3_4 (fe_code_rate_t)(FEC_S2_8PSK_2_3+1)
+	#define FEC_S2_8PSK_5_6 (fe_code_rate_t)(FEC_S2_8PSK_3_4+1)
+	#define FEC_S2_8PSK_7_8 (fe_code_rate_t)(FEC_S2_8PSK_5_6+1)
+	#define FEC_S2_8PSK_8_9 (fe_code_rate_t)(FEC_S2_8PSK_7_8+1)
+	#define FEC_S2_8PSK_3_5 (fe_code_rate_t)(FEC_S2_8PSK_8_9+1)
+	#define FEC_S2_8PSK_4_5 (fe_code_rate_t)(FEC_S2_8PSK_3_5+1)
+	#define FEC_S2_8PSK_9_10 (fe_code_rate_t)(FEC_S2_8PSK_4_5+1)
+#else
+	#define FEC_S2_QPSK_1_2 (fe_code_rate_t)(FEC_1_2)
+	#define FEC_S2_QPSK_2_3 (fe_code_rate_t)(FEC_2_3)
+	#define FEC_S2_QPSK_3_4 (fe_code_rate_t)(FEC_3_4)
+	#define FEC_S2_QPSK_5_6 (fe_code_rate_t)(FEC_5_6)
+	#define FEC_S2_QPSK_7_8 (fe_code_rate_t)(FEC_7_8)
+	#define FEC_S2_QPSK_8_9 (fe_code_rate_t)(FEC_8_9)
+	#define FEC_S2_QPSK_3_5 (fe_code_rate_t)(FEC_3_5)
+	#define FEC_S2_QPSK_4_5 (fe_code_rate_t)(FEC_4_5)
+	#define FEC_S2_QPSK_9_10 (fe_code_rate_t)(FEC_9_10)
+#endif
+#endif
+
+#include <dvbsi++/satellite_delivery_system_descriptor.h>
+#include <dvbsi++/cable_delivery_system_descriptor.h>
+#include <dvbsi++/terrestrial_delivery_system_descriptor.h>
+
+#define eDebugNoSimulate(x...) \
+	do { \
+		if (!m_simulate) \
+			eDebug(x); \
+	} while(0)
+#if 0
+		else \
+		{ \
+			eDebugNoNewLine("SIMULATE:"); \
+			eDebug(x); \
+		}
+#endif
+
+#define eDebugNoSimulateNoNewLine(x...) \
+	do { \
+		if (!m_simulate) \
+			eDebugNoNewLine(x); \
+	} while(0)
+#if 0
+		else \
+		{ \
+			eDebugNoNewLine("SIMULATE:"); \
+			eDebugNoNewLine(x); \
+		}
+#endif
+
+void eDVBDiseqcCommand::setCommandString(const char *str)
+{
+	if (!str)
+		return;
+	len=0;
+	int slen = strlen(str);
+	if (slen % 2)
+	{
+		eDebug("invalid diseqc command string length (not 2 byte aligned)");
+		return;
+	}
+	if (slen > MAX_DISEQC_LENGTH*2)
+	{
+		eDebug("invalid diseqc command string length (string is to long)");
+		return;
+	}
+	unsigned char val=0;
+	for (int i=0; i < slen; ++i)
+	{
+		unsigned char c = str[i];
+		switch(c)
+		{
+			case '0' ... '9': c-=48; break;
+			case 'a' ... 'f': c-=87; break;
+			case 'A' ... 'F': c-=55; break;
+			default:
+				eDebug("invalid character in hex string..ignore complete diseqc command !");
+				return;
+		}
+		if ( i % 2 )
+		{
+			val |= c;
+			data[i/2] = val;
+		}
+		else
+			val = c << 4;
+	}
+	len = slen/2;
+}
+
+void eDVBFrontendParametersSatellite::set(const SatelliteDeliverySystemDescriptor &descriptor)
+{
+	frequency    = descriptor.getFrequency() * 10;
+	symbol_rate  = descriptor.getSymbolRate() * 100;
+	polarisation = descriptor.getPolarization();
+	fec = descriptor.getFecInner();
+	if ( fec != eDVBFrontendParametersSatellite::FEC_None && fec > eDVBFrontendParametersSatellite::FEC_9_10 )
+		fec = eDVBFrontendParametersSatellite::FEC_Auto;
+	inversion = eDVBFrontendParametersSatellite::Inversion_Unknown;
+	pilot = eDVBFrontendParametersSatellite::Pilot_Unknown;
+	orbital_position  = ((descriptor.getOrbitalPosition() >> 12) & 0xF) * 1000;
+	orbital_position += ((descriptor.getOrbitalPosition() >> 8) & 0xF) * 100;
+	orbital_position += ((descriptor.getOrbitalPosition() >> 4) & 0xF) * 10;
+	orbital_position += ((descriptor.getOrbitalPosition()) & 0xF);
+	if (orbital_position && (!descriptor.getWestEastFlag()))
+		orbital_position = 3600 - orbital_position;
+	system = descriptor.getModulationSystem();
+	modulation = descriptor.getModulation();
+	if (system == eDVBFrontendParametersSatellite::System_DVB_S && modulation == eDVBFrontendParametersSatellite::Modulation_8PSK)
+	{
+		eDebug("satellite_delivery_descriptor non valid modulation type.. force QPSK");
+		modulation=eDVBFrontendParametersSatellite::Modulation_QPSK;
+	}
+	rolloff = descriptor.getRollOff();
+	if (system == eDVBFrontendParametersSatellite::System_DVB_S2)
+	{
+		eDebug("SAT DVB-S2 freq %d, %s, pos %d, sr %d, fec %d, modulation %d, rolloff %d",
+			frequency,
+			polarisation ? "hor" : "vert",
+			orbital_position,
+			symbol_rate, fec,
+			modulation,
+			rolloff);
+	}
+	else
+	{
+		eDebug("SAT DVB-S freq %d, %s, pos %d, sr %d, fec %d",
+			frequency,
+			polarisation ? "hor" : "vert",
+			orbital_position,
+			symbol_rate, fec);
+	}
+}
+
+void eDVBFrontendParametersCable::set(const CableDeliverySystemDescriptor &descriptor)
+{
+	frequency = descriptor.getFrequency() / 10;
+	symbol_rate = descriptor.getSymbolRate() * 100;
+	fec_inner = descriptor.getFecInner();
+	if ( fec_inner != eDVBFrontendParametersCable::FEC_None && fec_inner > eDVBFrontendParametersCable::FEC_8_9 )
+		fec_inner = eDVBFrontendParametersCable::FEC_Auto;
+	modulation = descriptor.getModulation();
+	if ( modulation > 0x5 )
+		modulation = eDVBFrontendParametersCable::Modulation_Auto;
+	inversion = eDVBFrontendParametersCable::Inversion_Unknown;
+	eDebug("Cable freq %d, mod %d, sr %d, fec %d",
+		frequency,
+		modulation, symbol_rate, fec_inner);
+}
+
+void eDVBFrontendParametersTerrestrial::set(const TerrestrialDeliverySystemDescriptor &descriptor)
+{
+	frequency = descriptor.getCentreFrequency() * 10;
+	bandwidth = descriptor.getBandwidth();
+	if ( bandwidth > 2 ) // 5Mhz forced to auto
+		bandwidth = eDVBFrontendParametersTerrestrial::Bandwidth_Auto;
+	code_rate_HP = descriptor.getCodeRateHpStream();
+	if (code_rate_HP > 4)
+		code_rate_HP = eDVBFrontendParametersTerrestrial::FEC_Auto;
+	code_rate_LP = descriptor.getCodeRateLpStream();
+	if (code_rate_LP > 4)
+		code_rate_LP = eDVBFrontendParametersTerrestrial::FEC_Auto;
+	transmission_mode = descriptor.getTransmissionMode();
+	if (transmission_mode > 1) // TM4k forced to auto
+		transmission_mode = eDVBFrontendParametersTerrestrial::TransmissionMode_Auto;
+	guard_interval = descriptor.getGuardInterval();
+	if (guard_interval > 3)
+		guard_interval = eDVBFrontendParametersTerrestrial::GuardInterval_Auto;
+	hierarchy = descriptor.getHierarchyInformation()&3;
+	modulation = descriptor.getConstellation();
+	if (modulation > 2)
+		modulation = eDVBFrontendParametersTerrestrial::Modulation_Auto;
+	inversion = eDVBFrontendParametersTerrestrial::Inversion_Unknown;
+	eDebug("Terr freq %d, bw %d, cr_hp %d, cr_lp %d, tm_mode %d, guard %d, hierarchy %d, const %d",
+		frequency, bandwidth, code_rate_HP, code_rate_LP, transmission_mode,
+		guard_interval, hierarchy, modulation);
+}
+
+eDVBFrontendParameters::eDVBFrontendParameters()
+	:m_type(-1), m_flags(0)
+{
+}
+
+DEFINE_REF(eDVBFrontendParameters);
+
+RESULT eDVBFrontendParameters::getSystem(int &t) const
+{
+	if (m_type == -1)
+		return -1;
+	t = m_type;
+	return 0;
+}
+
+RESULT eDVBFrontendParameters::getDVBS(eDVBFrontendParametersSatellite &p) const
+{
+	if (m_type != iDVBFrontend::feSatellite)
+		return -1;
+	p = sat;
+	return 0;
+}
+
+RESULT eDVBFrontendParameters::getDVBC(eDVBFrontendParametersCable &p) const
+{
+	if (m_type != iDVBFrontend::feCable)
+		return -1;
+	p = cable;
+	return 0;
+}
+
+RESULT eDVBFrontendParameters::getDVBT(eDVBFrontendParametersTerrestrial &p) const
+{
+	if (m_type != iDVBFrontend::feTerrestrial)
+		return -1;
+	p = terrestrial;
+	return 0;
+}
+
+RESULT eDVBFrontendParameters::setDVBS(const eDVBFrontendParametersSatellite &p, bool no_rotor_command_on_tune)
+{
+	sat = p;
+	sat.no_rotor_command_on_tune = no_rotor_command_on_tune;
+	m_type = iDVBFrontend::feSatellite;
+	return 0;
+}
+
+RESULT eDVBFrontendParameters::setDVBC(const eDVBFrontendParametersCable &p)
+{
+	cable = p;
+	m_type = iDVBFrontend::feCable;
+	return 0;
+}
+
+RESULT eDVBFrontendParameters::setDVBT(const eDVBFrontendParametersTerrestrial &p)
+{
+	terrestrial = p;
+	m_type = iDVBFrontend::feTerrestrial;
+	return 0;
+}
+
+RESULT eDVBFrontendParameters::calculateDifference(const iDVBFrontendParameters *parm, int &diff, bool exact) const
+{
+	if (!parm)
+		return -1;
+	int type;
+	if (parm->getSystem(type))
+		return -1;
+	if (type != m_type)
+	{
+		diff = 1<<30; // big difference
+		return 0;
+	}
+
+	switch (type)
+	{
+	case iDVBFrontend::feSatellite:
+	{
+		eDVBFrontendParametersSatellite osat;
+		if (parm->getDVBS(osat))
+			return -2;
+
+		if (sat.orbital_position != osat.orbital_position)
+			diff = 1<<29;
+		else if (sat.polarisation != osat.polarisation)
+			diff = 1<<28;
+		else if (exact && sat.fec != osat.fec && sat.fec != eDVBFrontendParametersSatellite::FEC_Auto && osat.fec != eDVBFrontendParametersSatellite::FEC_Auto)
+			diff = 1<<27;
+		else if (exact && sat.modulation != osat.modulation && sat.modulation != eDVBFrontendParametersSatellite::Modulation_Auto && osat.modulation != eDVBFrontendParametersSatellite::Modulation_Auto)
+			diff = 1<<27;
+		else
+		{
+			diff = abs(sat.frequency - osat.frequency);
+			diff += abs(sat.symbol_rate - osat.symbol_rate);
+		}
+		return 0;
+	}
+	case iDVBFrontend::feCable:
+		eDVBFrontendParametersCable ocable;
+		if (parm->getDVBC(ocable))
+			return -2;
+
+		if (exact && cable.modulation != ocable.modulation
+			&& cable.modulation != eDVBFrontendParametersCable::Modulation_Auto
+			&& ocable.modulation != eDVBFrontendParametersCable::Modulation_Auto)
+			diff = 1 << 29;
+		else if (exact && cable.fec_inner != ocable.fec_inner && cable.fec_inner != eDVBFrontendParametersCable::FEC_Auto && ocable.fec_inner != eDVBFrontendParametersCable::FEC_Auto)
+			diff = 1 << 27;
+		else
+		{
+			diff = abs(cable.frequency - ocable.frequency);
+			diff += abs(cable.symbol_rate - ocable.symbol_rate);
+		}
+		return 0;
+	case iDVBFrontend::feTerrestrial:
+		eDVBFrontendParametersTerrestrial oterrestrial;
+		if (parm->getDVBT(oterrestrial))
+			return -2;
+
+		if (exact && oterrestrial.bandwidth != terrestrial.bandwidth &&
+			oterrestrial.bandwidth != eDVBFrontendParametersTerrestrial::Bandwidth_Auto &&
+			terrestrial.bandwidth != eDVBFrontendParametersTerrestrial::Bandwidth_Auto)
+			diff = 1 << 30;
+		else if (exact && oterrestrial.modulation != terrestrial.modulation &&
+			oterrestrial.modulation != eDVBFrontendParametersTerrestrial::Modulation_Auto &&
+			terrestrial.modulation != eDVBFrontendParametersTerrestrial::Modulation_Auto)
+			diff = 1 << 30;
+		else if (exact && oterrestrial.transmission_mode != terrestrial.transmission_mode &&
+			oterrestrial.transmission_mode != eDVBFrontendParametersTerrestrial::TransmissionMode_Auto &&
+			terrestrial.transmission_mode != eDVBFrontendParametersTerrestrial::TransmissionMode_Auto)
+			diff = 1 << 30;
+		else if (exact && oterrestrial.guard_interval != terrestrial.guard_interval &&
+			oterrestrial.guard_interval != eDVBFrontendParametersTerrestrial::GuardInterval_Auto &&
+			terrestrial.guard_interval != eDVBFrontendParametersTerrestrial::GuardInterval_Auto)
+			diff = 1 << 30;
+		else if (exact && oterrestrial.hierarchy != terrestrial.hierarchy &&
+			oterrestrial.hierarchy != eDVBFrontendParametersTerrestrial::Hierarchy_Auto &&
+			terrestrial.hierarchy != eDVBFrontendParametersTerrestrial::Hierarchy_Auto)
+			diff = 1 << 30;
+		else if (exact && oterrestrial.code_rate_LP != terrestrial.code_rate_LP &&
+			oterrestrial.code_rate_LP != eDVBFrontendParametersTerrestrial::FEC_Auto &&
+			terrestrial.code_rate_LP != eDVBFrontendParametersTerrestrial::FEC_Auto)
+			diff = 1 << 30;
+		else if (exact && oterrestrial.code_rate_HP != terrestrial.code_rate_HP &&
+			oterrestrial.code_rate_HP != eDVBFrontendParametersTerrestrial::FEC_Auto &&
+			terrestrial.code_rate_HP != eDVBFrontendParametersTerrestrial::FEC_Auto)
+			diff = 1 << 30;
+		else
+			diff = abs(terrestrial.frequency - oterrestrial.frequency) / 1000;
+		return 0;
+	default:
+		return -1;
+	}
+	return 0;
+}
+
+RESULT eDVBFrontendParameters::getHash(unsigned long &hash) const
+{
+	switch (m_type)
+	{
+	case iDVBFrontend::feSatellite:
+	{
+		hash = (sat.orbital_position << 16);
+		hash |= ((sat.frequency/1000)&0xFFFF)|((sat.polarisation&1) << 15);
+		return 0;
+	}
+	case iDVBFrontend::feCable:
+		hash = 0xFFFF0000;
+		hash |= (cable.frequency/1000)&0xFFFF;
+		return 0;
+	case iDVBFrontend::feTerrestrial:
+		hash = 0xEEEE0000;
+		hash |= (terrestrial.frequency/1000000)&0xFFFF;
+		return 0;
+	default:
+		return -1;
+	}
+}
+
+RESULT eDVBFrontendParameters::calcLockTimeout(unsigned int &timeout) const
+{
+	switch (m_type)
+	{
+	case iDVBFrontend::feSatellite:
+	{
+			/* high symbol rate transponders tune faster, due to 
+				requiring less zigzag and giving more symbols faster. 
+
+				5s are definitely not enough on really low SR when
+				zigzag has to find the exact frequency first.
+			*/
+		if (sat.symbol_rate > 20000000)
+			timeout = 5000;
+		else if (sat.symbol_rate > 10000000)
+			timeout = 10000;
+		else
+			timeout = 20000;
+		return 0;
+	}
+	case iDVBFrontend::feCable:
+		timeout = 5000;
+		return 0;
+	case iDVBFrontend::feTerrestrial:
+		timeout = 5000;
+		return 0;
+	default:
+		return -1;
+	}
+}
+
+DEFINE_REF(eDVBFrontend);
+
+int eDVBFrontend::PriorityOrder=0;
+
+eDVBFrontend::eDVBFrontend(int adap, int fe, int &ok, bool simulate)
+	:m_simulate(simulate), m_enabled(false), m_type(-1), m_dvbid(fe), m_slotid(fe)
+	,m_fd(-1), m_rotor_mode(false), m_need_rotor_workaround(false), m_can_handle_dvbs2(false)
+	,m_state(stateClosed), m_timeout(0), m_tuneTimer(0)
+#if HAVE_DVB_API_VERSION < 3
+	,m_secfd(-1)
+#endif
+{
+#if HAVE_DVB_API_VERSION < 3
+	sprintf(m_filename, "/dev/dvb/card%d/frontend%d", adap, fe);
+	sprintf(m_sec_filename, "/dev/dvb/card%d/sec%d", adap, fe);
+#else
+	sprintf(m_filename, "/dev/dvb/adapter%d/frontend%d", adap, fe);
+#endif
+
+	m_timeout = eTimer::create(eApp);
+	CONNECT(m_timeout->timeout, eDVBFrontend::timeout);
+
+	m_tuneTimer = eTimer::create(eApp);
+	CONNECT(m_tuneTimer->timeout, eDVBFrontend::tuneLoop);
+
+	for (int i=0; i<eDVBFrontend::NUM_DATA_ENTRIES; ++i)
+		m_data[i] = -1;
+
+	m_idleInputpower[0]=m_idleInputpower[1]=0;
+
+	ok = !openFrontend();
+	closeFrontend();
+}
+
+void eDVBFrontend::reopenFrontend()
+{
+	sleep(1);
+	m_type = -1;
+	openFrontend();
+}
+
+int eDVBFrontend::openFrontend()
+{
+	if (m_state != stateClosed)
+		return -1;  // already opened
+
+	m_state=stateIdle;
+	m_tuning=0;
+
+#if HAVE_DVB_API_VERSION < 3
+	FrontendInfo fe_info;
+#else
+	dvb_frontend_info fe_info;
+#endif
+	eDebugNoSimulate("opening frontend %d", m_dvbid);
+	if (m_fd < 0)
+	{
+		if (!m_simulate || m_type == -1)
+		{
+			m_fd = ::open(m_filename, O_RDWR|O_NONBLOCK);
+			if (m_fd < 0)
+			{
+				eWarning("failed! (%s) %m", m_filename);
+				return -1;
+			}
+		}
+	}
+	else
+		eWarning("frontend %d already opened", m_dvbid);
+	if (m_type == -1)
+	{
+		if (::ioctl(m_fd, FE_GET_INFO, &fe_info) < 0)
+		{
+			eWarning("ioctl FE_GET_INFO failed");
+			::close(m_fd);
+			m_fd = -1;
+			return -1;
+		}
+
+		switch (fe_info.type)
+		{
+		case FE_QPSK:
+			m_type = iDVBFrontend::feSatellite;
+			break;
+		case FE_QAM:
+			m_type = iDVBFrontend::feCable;
+			break;
+		case FE_OFDM:
+			m_type = iDVBFrontend::feTerrestrial;
+			break;
+		default:
+			eWarning("unknown frontend type.");
+			::close(m_fd);
+			m_fd = -1;
+			return -1;
+		}
+		eDebugNoSimulate("detected %s frontend", "satellite\0cable\0    terrestrial"+fe_info.type*10);
+	}
+
+#if HAVE_DVB_API_VERSION < 3
+	if (m_type == iDVBFrontend::feSatellite)
+	{
+			if (m_secfd < 0)
+			{
+				if (!m_simulate)
+				{
+					m_secfd = ::open(m_sec_filename, O_RDWR);
+					if (m_secfd < 0)
+					{
+						eWarning("failed! (%s) %m", m_sec_filename);
+						::close(m_fd);
+						m_fd=-1;
+						return -1;
+					}
+				}
+			}
+			else
+				eWarning("sec %d already opened", m_dvbid);
+	}
+#endif
+
+	setTone(iDVBFrontend::toneOff);
+	setVoltage(iDVBFrontend::voltageOff);
+
+	if (!m_simulate)
+	{
+		m_sn = eSocketNotifier::create(eApp, m_fd, eSocketNotifier::Read, false);
+		CONNECT(m_sn->activated, eDVBFrontend::feEvent);
+	}
+
+	return 0;
+}
+
+int eDVBFrontend::closeFrontend(bool force)
+{
+	if (!force && m_data[CUR_VOLTAGE] != -1 && m_data[CUR_VOLTAGE] != iDVBFrontend::voltageOff)
+	{
+		long tmp = m_data[LINKED_NEXT_PTR];
+		while (tmp != -1)
+		{
+			eDVBRegisteredFrontend *linked_fe = (eDVBRegisteredFrontend*)tmp;
+			if (linked_fe->m_inuse)
+			{
+				eDebugNoSimulate("dont close frontend %d until the linked frontend %d in slot %d is still in use",
+					m_dvbid, linked_fe->m_frontend->getDVBID(), linked_fe->m_frontend->getSlotID());
+				return -1;
+			}
+			linked_fe->m_frontend->getData(LINKED_NEXT_PTR, tmp);
+		}
+	}
+
+	if (m_fd >= 0)
+	{
+		eDebugNoSimulate("close frontend %d", m_dvbid);
+		if (m_data[SATCR] != -1)
+		{
+			turnOffSatCR(m_data[SATCR]);
+		}
+		setTone(iDVBFrontend::toneOff);
+		setVoltage(iDVBFrontend::voltageOff);
+		m_tuneTimer->stop();
+		if (m_sec && !m_simulate)
+			m_sec->setRotorMoving(m_slotid, false);
+		if (!::close(m_fd))
+			m_fd=-1;
+		else
+			eWarning("couldnt close frontend %d", m_dvbid);
+	}
+	else if (m_simulate)
+	{
+		setTone(iDVBFrontend::toneOff);
+		setVoltage(iDVBFrontend::voltageOff);
+	}
+#if HAVE_DVB_API_VERSION < 3
+	if (m_secfd >= 0)
+	{
+		if (!::close(m_secfd))
+			m_secfd=-1;
+		else
+			eWarning("couldnt close sec %d", m_dvbid);
+	}
+#endif
+	m_sn=0;
+	m_state = stateClosed;
+
+	return 0;
+}
+
+eDVBFrontend::~eDVBFrontend()
+{
+	m_data[LINKED_PREV_PTR] = m_data[LINKED_NEXT_PTR] = -1;
+	closeFrontend();
+}
+
+void eDVBFrontend::feEvent(int w)
+{
+	eDVBFrontend *sec_fe = this;
+	long tmp = m_data[LINKED_PREV_PTR];
+	while (tmp != -1)
+	{
+		eDVBRegisteredFrontend *linked_fe = (eDVBRegisteredFrontend*)tmp;
+		sec_fe = linked_fe->m_frontend;
+		sec_fe->getData(LINKED_NEXT_PTR, tmp);
+	}
+	while (1)
+	{
+#if HAVE_DVB_API_VERSION < 3
+		FrontendEvent event;
+#else
+		dvb_frontend_event event;
+#endif
+		int res;
+		int state;
+		res = ::ioctl(m_fd, FE_GET_EVENT, &event);
+
+		if (res && (errno == EAGAIN))
+			break;
+
+		if (w < 0)
+			continue;
+
+#if HAVE_DVB_API_VERSION < 3
+		if (event.type == FE_COMPLETION_EV)
+#else
+		eDebug("(%d)fe event: status %x, inversion %s, m_tuning %d", m_dvbid, event.status, (event.parameters.inversion == INVERSION_ON) ? "on" : "off", m_tuning);
+		if (event.status & FE_HAS_LOCK)
+#endif
+		{
+			state = stateLock;
+		} else
+		{
+			if (m_tuning) {
+				state = stateTuning;
+#if HAVE_DVB_API_VERSION >= 3
+				if (event.status & FE_TIMEDOUT) {
+					eDebug("FE_TIMEDOUT! ..abort");
+					m_tuneTimer->stop();
+					timeout();
+					return;
+				}
+				++m_tuning;
+#else
+				m_tuneTimer->stop();
+				timeout();
+#endif
+			}
+			else
+			{
+				eDebug("stateLostLock");
+				state = stateLostLock;
+				if (!m_rotor_mode)
+					sec_fe->m_data[CSW] = sec_fe->m_data[UCSW] = sec_fe->m_data[TONEBURST] = -1; // reset diseqc
+			}
+		}
+		if (m_state != state)
+		{
+			m_state = state;
+			m_stateChanged(this);
+		}
+	}
+}
+
+void eDVBFrontend::timeout()
+{
+	m_tuning = 0;
+	if (m_state == stateTuning)
+	{
+		m_state = stateFailed;
+		m_stateChanged(this);
+	}
+}
+
+#define INRANGE(X,Y,Z) (((X<=Y) && (Y<=Z))||((Z<=Y) && (Y<=X)) ? 1 : 0)
+
+/* unsigned 32 bit division */
+static inline uint32_t fe_udiv(uint32_t a, uint32_t b)
+{
+	return (a + b / 2) / b;
+}
+
+int eDVBFrontend::readFrontendData(int type)
+{
+	switch(type)
+	{
+		case bitErrorRate:
+		{
+			uint32_t ber=0;
+			if (!m_simulate)
+			{
+				if (ioctl(m_fd, FE_READ_BER, &ber) < 0 && errno != ERANGE)
+					eDebug("FE_READ_BER failed (%m)");
+			}
+			return ber;
+		}
+		case signalQuality:
+		case signalQualitydB: /* this will move into the driver */
+		{
+			int sat_max = 1600; // for stv0288 / bsbe2
+			int ret = 0x12345678;
+			uint16_t snr=0;
+			if (m_simulate)
+				return 0;
+			if (ioctl(m_fd, FE_READ_SNR, &snr) < 0 && errno != ERANGE)
+				eDebug("FE_READ_SNR failed (%m)");
+			else if (!strcmp(m_description, "BCM4501 (internal)"))
+			{
+				float SDS_SNRE = snr << 16;
+				float snr_in_db;
+
+				if (oparm.sat.system == eDVBFrontendParametersSatellite::System_DVB_S) // DVB-S1 / QPSK
+				{
+					static float SNR_COEFF[6] = {
+						100.0 / 4194304.0,
+						-7136.0 / 4194304.0,
+						197418.0 / 4194304.0,
+						-2602183.0 / 4194304.0,
+						20377212.0 / 4194304.0,
+						-37791203.0 / 4194304.0,
+					};
+					float fval1 = 12.44714 - (2.0 * log10(SDS_SNRE / 256.0)),
+	    				  fval2 = pow(10.0, fval1)-1;
+					fval1 = 10.0 * log10(fval2);
+
+					if (fval1 < 10.0)
+					{
+						fval2 = SNR_COEFF[0];
+						for (int i=1; i<6; ++i)
+						{
+							fval2 *= fval1;
+							fval2 += SNR_COEFF[i];
+						}
+						fval1 = fval2;
+					}
+					snr_in_db = fval1;
+				}
+#if HAVE_DVB_API_VERSION >= 3
+				else
+				{
+					float fval1 = SDS_SNRE / 268435456.0,
+						  fval2, fval3, fval4;
+
+					if (parm_u_qpsk_fec_inner <= FEC_S2_QPSK_9_10) // DVB-S2 QPSK
+					{
+						fval2 = 6.76;
+						fval3 = 4.35;
+					}
+					else // 8PSK
+					{
+						fval1 *= 0.5;
+						fval2 = 8.06;
+						fval3 = 6.18;
+					}
+					fval4 = -10.0 * log10(fval1);
+					fval1 = fval4;
+					for (int i=0; i < 5; ++i)
+						fval1 = fval4 - fval2 * log10(1.0+pow(10.0, (fval3-fval1)/fval2));
+					snr_in_db = fval1;
+				}
+#endif
+				sat_max = 1750;
+				ret = (int)(snr_in_db * 100);
+			}
+			else if (strstr(m_description, "Alps BSBE1 C01A") ||
+				strstr(m_description, "Alps -S(STV0288)"))
+			{
+				if (snr == 0)
+					ret = 0;
+				else if (snr == 0xFFFF) // i think this should not happen
+					ret = 100*100;
+				else
+				{
+					enum { REALVAL, REGVAL };
+					const long CN_lookup[31][2] = {
+						{20,8900}, {25,8680}, {30,8420}, {35,8217}, {40,7897},
+						{50,7333}, {60,6747}, {70,6162}, {80,5580}, {90,5029},
+						{100,4529}, {110,4080}, {120,3685}, {130,3316}, {140,2982},
+						{150,2688}, {160,2418}, {170,2188}, {180,1982}, {190,1802},
+						{200,1663}, {210,1520}, {220,1400}, {230,1295}, {240,1201},
+						{250,1123}, {260,1058}, {270,1004}, {280,957}, {290,920},
+						{300,890}
+					};
+					int add=strchr(m_description, '.') ? 0xA250 : 0xA100;
+					long regval = 0xFFFF - ((snr / 3) + add), // revert some dvb api calulations to get the real register value
+						Imin=0,
+						Imax=30,
+						i;
+					if(INRANGE(CN_lookup[Imin][REGVAL],regval,CN_lookup[Imax][REGVAL]))
+					{
+						while((Imax-Imin)>1)
+						{
+							i=(Imax+Imin)/2;
+							if(INRANGE(CN_lookup[Imin][REGVAL],regval,CN_lookup[i][REGVAL]))
+								Imax = i;
+							else
+								Imin = i;
+						}
+						ret = (((regval - CN_lookup[Imin][REGVAL])
+								* (CN_lookup[Imax][REALVAL] - CN_lookup[Imin][REALVAL])
+								/ (CN_lookup[Imax][REGVAL] - CN_lookup[Imin][REGVAL]))
+								+ CN_lookup[Imin][REALVAL]) * 10;
+					}
+					else
+						ret = 100;
+				}
+			}
+			else if (!strcmp(m_description, "Alps BSBE1 702A") ||  // some frontends with STV0299
+				!strcmp(m_description, "Alps -S") ||
+				!strcmp(m_description, "Philips -S") ||
+				!strcmp(m_description, "LG -S") )
+			{
+				sat_max = 1500;
+				ret = (int)((snr-39075)/17.647);
+			} else if (!strcmp(m_description, "Alps BSBE2"))
+			{
+				ret = (int)((snr >> 7) * 10);
+			} else if (!strcmp(m_description, "Philips CU1216Mk3"))
+			{
+				int mse = (~snr) & 0xFF;
+				switch (parm_u_qam_modulation) {
+				case QAM_16: ret = fe_udiv(1950000, (32 * mse) + 138) + 1000; break;
+				case QAM_32: ret = fe_udiv(2150000, (40 * mse) + 500) + 1350; break;
+				case QAM_64: ret = fe_udiv(2100000, (40 * mse) + 500) + 1250; break;
+				case QAM_128: ret = fe_udiv(1850000, (38 * mse) + 400) + 1380; break;
+				case QAM_256: ret = fe_udiv(1800000, (100 * mse) + 40) + 2030; break;
+				default: break;
+				}
+			} else if (!strcmp(m_description, "Philips TU1216"))
+			{
+				snr = 0xFF - (snr & 0xFF);
+				if (snr != 0)
+					ret = 10 * (int)(-100 * (log10(snr) - log10(255)));
+			}
+			else if (strstr(m_description, "BCM4506") || strstr(m_description, "BCM4505"))
+				ret = (snr * 100) >> 8;
+
+			if (type == signalQuality)
+			{
+				if (ret == 0x12345678) // no snr db calculation avail.. return untouched snr value..
+					return snr;
+				switch(m_type)
+				{
+					case feSatellite:
+						return ret >= sat_max ? 65536 : ret * 65536 / sat_max;
+					case feCable: // we assume a max of 42db here
+						return ret >= 4200 ? 65536 : ret * 65536 / 4200;
+					case feTerrestrial: // we assume a max of 24db here
+						return ret >= 2400 ? 65536 : ret * 65536 / 2400;
+				}
+			}
+/* else
+				eDebug("no SNR dB calculation for frontendtype %s yet", m_description); */
+			return ret;
+		}
+		case signalPower:
+		{
+			uint16_t strength=0;
+			if (!m_simulate)
+			{
+				if (ioctl(m_fd, FE_READ_SIGNAL_STRENGTH, &strength) < 0 && errno != ERANGE)
+					eDebug("FE_READ_SIGNAL_STRENGTH failed (%m)");
+			}
+			return strength;
+		}
+		case locked:
+		{
+#if HAVE_DVB_API_VERSION < 3
+			FrontendStatus status=0;
+#else
+			fe_status_t status;
+#endif
+			if (!m_simulate)
+			{
+				if ( ioctl(m_fd, FE_READ_STATUS, &status) < 0 && errno != ERANGE )
+					eDebug("FE_READ_STATUS failed (%m)");
+				return !!(status&FE_HAS_LOCK);
+			}
+			return 1;
+		}
+		case synced:
+		{
+#if HAVE_DVB_API_VERSION < 3
+			FrontendStatus status=0;
+#else
+			fe_status_t status;
+#endif
+			if (!m_simulate)
+			{
+				if ( ioctl(m_fd, FE_READ_STATUS, &status) < 0 && errno != ERANGE )
+					eDebug("FE_READ_STATUS failed (%m)");
+				return !!(status&FE_HAS_SYNC);
+			}
+			return 1;
+		}
+		case frontendNumber:
+			return m_slotid;
+	}
+	return 0;
+}
+
+void PutToDict(ePyObject &dict, const char*key, long value)
+{
+	ePyObject item = PyInt_FromLong(value);
+	if (item)
+	{
+		if (PyDict_SetItemString(dict, key, item))
+			eDebug("put %s to dict failed", key);
+		Py_DECREF(item);
+	}
+	else
+		eDebug("could not create PyObject for %s", key);
+}
+
+void PutToDict(ePyObject &dict, const char*key, ePyObject item)
+{
+	if (item)
+	{
+		if (PyDict_SetItemString(dict, key, item))
+			eDebug("put %s to dict failed", key);
+		Py_DECREF(item);
+	}
+	else
+		eDebug("invalid PyObject for %s", key);
+}
+
+void PutToDict(ePyObject &dict, const char*key, const char *value)
+{
+	ePyObject item = PyString_FromString(value);
+	if (item)
+	{
+		if (PyDict_SetItemString(dict, key, item))
+			eDebug("put %s to dict failed", key);
+		Py_DECREF(item);
+	}
+	else
+		eDebug("could not create PyObject for %s", key);
+}
+
+void PutSatelliteDataToDict(ePyObject &dict, eDVBFrontendParametersSatellite &feparm)
+{
+	PutToDict(dict, "tuner_type", "DVB-S");
+	PutToDict(dict, "frequency", feparm.frequency);
+	PutToDict(dict, "symbol_rate", feparm.symbol_rate);
+	PutToDict(dict, "orbital_position", feparm.orbital_position);
+	PutToDict(dict, "inversion", feparm.inversion);
+	PutToDict(dict, "fec_inner", feparm.fec);
+	PutToDict(dict, "modulation", feparm.modulation);
+	PutToDict(dict, "polarization", feparm.polarisation);
+	if (feparm.system == eDVBFrontendParametersSatellite::System_DVB_S2)
+	{
+		PutToDict(dict, "rolloff", feparm.rolloff);
+		PutToDict(dict, "pilot", feparm.pilot);
+	}
+	PutToDict(dict, "system", feparm.system);
+}
+
+void PutTerrestrialDataToDict(ePyObject &dict, eDVBFrontendParametersTerrestrial &feparm)
+{
+	PutToDict(dict, "tuner_type", "DVB-T");
+	PutToDict(dict, "frequency", feparm.frequency);
+	PutToDict(dict, "bandwidth", feparm.bandwidth);
+	PutToDict(dict, "code_rate_lp", feparm.code_rate_LP);
+	PutToDict(dict, "code_rate_hp", feparm.code_rate_HP);
+	PutToDict(dict, "constellation", feparm.modulation);
+	PutToDict(dict, "transmission_mode", feparm.transmission_mode);
+	PutToDict(dict, "guard_interval", feparm.guard_interval);
+	PutToDict(dict, "hierarchy_information", feparm.hierarchy);
+	PutToDict(dict, "inversion", feparm.inversion);
+}
+
+void PutCableDataToDict(ePyObject &dict, eDVBFrontendParametersCable &feparm)
+{
+	PutToDict(dict, "tuner_type", "DVB-C");
+	PutToDict(dict, "frequency", feparm.frequency);
+	PutToDict(dict, "symbol_rate", feparm.symbol_rate);
+	PutToDict(dict, "modulation", feparm.modulation);
+	PutToDict(dict, "inversion", feparm.inversion);
+	PutToDict(dict, "fec_inner", feparm.fec_inner);
+}
+
+#if HAVE_DVB_API_VERSION >= 5
+static void fillDictWithSatelliteData(ePyObject dict, const FRONTENDPARAMETERS &parm, struct dtv_property *p, long freq_offset, int orb_pos, int polarization)
+{
+	long tmp=0;
+	int frequency = parm_frequency + freq_offset;
+	PutToDict(dict, "frequency", frequency);
+	PutToDict(dict, "symbol_rate", parm_u_qpsk_symbol_rate);
+	PutToDict(dict, "orbital_position", orb_pos);
+	PutToDict(dict, "polarization", polarization);
+
+	switch(parm_u_qpsk_fec_inner)
+	{
+	case FEC_1_2: tmp = eDVBFrontendParametersSatellite::FEC_1_2; break;
+	case FEC_2_3: tmp = eDVBFrontendParametersSatellite::FEC_2_3; break;
+	case FEC_3_4: tmp = eDVBFrontendParametersSatellite::FEC_3_4; break;
+	case FEC_3_5: tmp = eDVBFrontendParametersSatellite::FEC_3_5; break;
+	case FEC_4_5: tmp = eDVBFrontendParametersSatellite::FEC_4_5; break;
+	case FEC_5_6: tmp = eDVBFrontendParametersSatellite::FEC_5_6; break;
+	case FEC_7_8: tmp = eDVBFrontendParametersSatellite::FEC_7_8; break;
+	case FEC_8_9: tmp = eDVBFrontendParametersSatellite::FEC_8_9; break;
+	case FEC_9_10: tmp = eDVBFrontendParametersSatellite::FEC_9_10; break;
+	case FEC_NONE: tmp = eDVBFrontendParametersSatellite::FEC_None; break;
+	case FEC_AUTO: tmp = eDVBFrontendParametersSatellite::FEC_Auto; break;
+	default: eDebug("got unsupported FEC from frontend! report as FEC_AUTO!\n");
+	}
+	PutToDict(dict, "fec_inner", tmp);
+
+	switch (p[0].u.data)
+	{
+	default: eDebug("got unsupported system from frontend! report as DVBS!");
+	case SYS_DVBS: tmp = eDVBFrontendParametersSatellite::System_DVB_S; break;
+	case SYS_DVBS2:
+	{
+		switch (p[2].u.data)
+		{
+		default: eDebug("got unsupported rolloff from frontend! report as 0_20!");
+		case ROLLOFF_20: tmp = eDVBFrontendParametersSatellite::RollOff_alpha_0_20; break;
+		case ROLLOFF_25: tmp = eDVBFrontendParametersSatellite::RollOff_alpha_0_25; break;
+		case ROLLOFF_35: tmp = eDVBFrontendParametersSatellite::RollOff_alpha_0_35; break;
+		}
+		PutToDict(dict, "rolloff", tmp);
+
+		switch (p[3].u.data)
+		{
+		case PILOT_OFF: tmp = eDVBFrontendParametersSatellite::Pilot_Off; break;
+		case PILOT_ON: tmp = eDVBFrontendParametersSatellite::Pilot_On; break;
+		case PILOT_AUTO: tmp = eDVBFrontendParametersSatellite::Pilot_Unknown; break;
+		}
+		PutToDict(dict, "pilot", tmp);
+
+		tmp = eDVBFrontendParametersSatellite::System_DVB_S2; break;
+	}
+	}
+	PutToDict(dict, "system", tmp);
+
+	switch (p[1].u.data)
+	{
+	default: eDebug("got unsupported modulation from frontend! report as QPSK!");
+	case QPSK: tmp = eDVBFrontendParametersSatellite::Modulation_QPSK; break;
+	case PSK_8: tmp = eDVBFrontendParametersSatellite::Modulation_8PSK; break;
+	}
+	PutToDict(dict, "modulation", tmp);
+}
+
+#else
+static void fillDictWithSatelliteData(ePyObject dict, const FRONTENDPARAMETERS &parm, long freq_offset, int orb_pos, int polarization)
+{
+	long tmp=0;
+	int frequency = parm_frequency + freq_offset;
+	PutToDict(dict, "frequency", frequency);
+	PutToDict(dict, "symbol_rate", parm_u_qpsk_symbol_rate);
+	PutToDict(dict, "orbital_position", orb_pos);
+	PutToDict(dict, "polarization", polarization);
+
+	switch((int)parm_u_qpsk_fec_inner)
+	{
+	case FEC_1_2: tmp = eDVBFrontendParametersSatellite::FEC_1_2; break;
+	case FEC_2_3: tmp = eDVBFrontendParametersSatellite::FEC_2_3; break;
+	case FEC_3_4: tmp = eDVBFrontendParametersSatellite::FEC_3_4; break;
+	case FEC_5_6: tmp = eDVBFrontendParametersSatellite::FEC_5_6; break;
+	case FEC_7_8: tmp = eDVBFrontendParametersSatellite::FEC_7_8; break;
+	case FEC_NONE: tmp = eDVBFrontendParametersSatellite::FEC_None; break;
+	default:
+	case FEC_AUTO: tmp = eDVBFrontendParametersSatellite::FEC_Auto; break;
+#if HAVE_DVB_API_VERSION >=3
+	case FEC_S2_8PSK_1_2:
+	case FEC_S2_QPSK_1_2: tmp = eDVBFrontendParametersSatellite::FEC_1_2; break;
+	case FEC_S2_8PSK_2_3:
+	case FEC_S2_QPSK_2_3: tmp = eDVBFrontendParametersSatellite::FEC_2_3; break;
+	case FEC_S2_8PSK_3_4:
+	case FEC_S2_QPSK_3_4: tmp = eDVBFrontendParametersSatellite::FEC_3_4; break;
+	case FEC_S2_8PSK_5_6:
+	case FEC_S2_QPSK_5_6: tmp = eDVBFrontendParametersSatellite::FEC_5_6; break;
+	case FEC_S2_8PSK_7_8:
+	case FEC_S2_QPSK_7_8: tmp = eDVBFrontendParametersSatellite::FEC_7_8; break;
+	case FEC_S2_8PSK_8_9:
+	case FEC_S2_QPSK_8_9: tmp = eDVBFrontendParametersSatellite::FEC_8_9; break;
+	case FEC_S2_8PSK_3_5:
+	case FEC_S2_QPSK_3_5: tmp = eDVBFrontendParametersSatellite::FEC_3_5; break;
+	case FEC_S2_8PSK_4_5:
+	case FEC_S2_QPSK_4_5: tmp = eDVBFrontendParametersSatellite::FEC_4_5; break;
+	case FEC_S2_8PSK_9_10:
+	case FEC_S2_QPSK_9_10: tmp = eDVBFrontendParametersSatellite::FEC_9_10; break;
+#endif
+	}
+	PutToDict(dict, "fec_inner", tmp);
+#if HAVE_DVB_API_VERSION >=3
+	PutToDict(dict, "modulation",
+		parm_u_qpsk_fec_inner > FEC_S2_QPSK_9_10 ?
+			eDVBFrontendParametersSatellite::Modulation_8PSK :
+			eDVBFrontendParametersSatellite::Modulation_QPSK );
+	if (parm_u_qpsk_fec_inner > FEC_AUTO)
+	{
+		switch(parm_inversion & 0xc)
+		{
+		default: // unknown rolloff
+		case 0: tmp = eDVBFrontendParametersSatellite::RollOff_alpha_0_35; break;
+		case 4: tmp = eDVBFrontendParametersSatellite::RollOff_alpha_0_25; break;
+		case 8: tmp = eDVBFrontendParametersSatellite::RollOff_alpha_0_20; break;
+		}
+		PutToDict(dict, "rolloff", tmp);
+		switch(parm_inversion & 0x30)
+		{
+		case 0: tmp = eDVBFrontendParametersSatellite::Pilot_Off; break;
+		case 0x10: tmp = eDVBFrontendParametersSatellite::Pilot_On; break;
+		case 0x20: tmp = eDVBFrontendParametersSatellite::Pilot_Unknown; break;
+		}
+		PutToDict(dict, "pilot", tmp);
+		tmp = eDVBFrontendParametersSatellite::System_DVB_S2;
+	}
+	else
+		tmp = eDVBFrontendParametersSatellite::System_DVB_S;
+#else
+	PutToDict(dict, "modulation", eDVBFrontendParametersSatellite::Modulation_QPSK );
+	tmp = eDVBFrontendParametersSatellite::System_DVB_S;
+#endif
+	PutToDict(dict, "system", tmp);
+}
+#endif
+
+static void fillDictWithCableData(ePyObject dict, const FRONTENDPARAMETERS &parm)
+{
+	long tmp=0;
+#if HAVE_DVB_API_VERSION < 3
+	PutToDict(dict, "frequency", parm_frequency);
+#else
+	PutToDict(dict, "frequency", parm_frequency/1000);
+#endif
+	PutToDict(dict, "symbol_rate", parm_u_qam_symbol_rate);
+	switch(parm_u_qam_fec_inner)
+	{
+	case FEC_NONE: tmp = eDVBFrontendParametersCable::FEC_None; break;
+	case FEC_1_2: tmp = eDVBFrontendParametersCable::FEC_1_2; break;
+	case FEC_2_3: tmp = eDVBFrontendParametersCable::FEC_2_3; break;
+	case FEC_3_4: tmp = eDVBFrontendParametersCable::FEC_3_4; break;
+	case FEC_5_6: tmp = eDVBFrontendParametersCable::FEC_5_6; break;
+	case FEC_7_8: tmp = eDVBFrontendParametersCable::FEC_7_8; break;
+#if HAVE_DVB_API_VERSION >= 3
+	case FEC_8_9: tmp = eDVBFrontendParametersCable::FEC_7_8; break;
+#endif
+	default:
+	case FEC_AUTO: tmp = eDVBFrontendParametersCable::FEC_Auto; break;
+	}
+	PutToDict(dict, "fec_inner", tmp);
+	switch(parm_u_qam_modulation)
+	{
+	case QAM_16: tmp = eDVBFrontendParametersCable::Modulation_QAM16; break;
+	case QAM_32: tmp = eDVBFrontendParametersCable::Modulation_QAM32; break;
+	case QAM_64: tmp = eDVBFrontendParametersCable::Modulation_QAM64; break;
+	case QAM_128: tmp = eDVBFrontendParametersCable::Modulation_QAM128; break;
+	case QAM_256: tmp = eDVBFrontendParametersCable::Modulation_QAM256; break;
+	default:
+	case QAM_AUTO:   tmp = eDVBFrontendParametersCable::Modulation_Auto; break;
+	}
+	PutToDict(dict, "modulation", tmp);
+}
+
+static void fillDictWithTerrestrialData(ePyObject dict, const FRONTENDPARAMETERS &parm)
+{
+	long tmp=0;
+	PutToDict(dict, "frequency", parm_frequency);
+	switch (parm_u_ofdm_bandwidth)
+	{
+	case BANDWIDTH_8_MHZ: tmp = eDVBFrontendParametersTerrestrial::Bandwidth_8MHz; break;
+	case BANDWIDTH_7_MHZ: tmp = eDVBFrontendParametersTerrestrial::Bandwidth_7MHz; break;
+	case BANDWIDTH_6_MHZ: tmp = eDVBFrontendParametersTerrestrial::Bandwidth_6MHz; break;
+	default:
+	case BANDWIDTH_AUTO: tmp = eDVBFrontendParametersTerrestrial::Bandwidth_Auto; break;
+	}
+	PutToDict(dict, "bandwidth", tmp);
+	switch (parm_u_ofdm_code_rate_LP)
+	{
+	case FEC_1_2: tmp = eDVBFrontendParametersTerrestrial::FEC_1_2; break;
+	case FEC_2_3: tmp = eDVBFrontendParametersTerrestrial::FEC_2_3; break;
+	case FEC_3_4: tmp = eDVBFrontendParametersTerrestrial::FEC_3_4; break;
+	case FEC_5_6: tmp = eDVBFrontendParametersTerrestrial::FEC_5_6; break;
+	case FEC_7_8: tmp = eDVBFrontendParametersTerrestrial::FEC_7_8; break;
+	default:
+	case FEC_AUTO: tmp = eDVBFrontendParametersTerrestrial::FEC_Auto; break;
+	}
+	PutToDict(dict, "code_rate_lp", tmp);
+	switch (parm_u_ofdm_code_rate_HP)
+	{
+	case FEC_1_2: tmp = eDVBFrontendParametersTerrestrial::FEC_1_2; break;
+	case FEC_2_3: tmp = eDVBFrontendParametersTerrestrial::FEC_2_3; break;
+	case FEC_3_4: tmp = eDVBFrontendParametersTerrestrial::FEC_3_4; break;
+	case FEC_5_6: tmp = eDVBFrontendParametersTerrestrial::FEC_5_6; break;
+	case FEC_7_8: tmp = eDVBFrontendParametersTerrestrial::FEC_7_8; break;
+	default:
+	case FEC_AUTO: tmp = eDVBFrontendParametersTerrestrial::FEC_Auto; break;
+	}
+	PutToDict(dict, "code_rate_hp", tmp);
+	switch (parm_u_ofdm_constellation)
+	{
+	case QPSK: tmp = eDVBFrontendParametersTerrestrial::Modulation_QPSK; break;
+	case QAM_16: tmp = eDVBFrontendParametersTerrestrial::Modulation_QAM16; break;
+	case QAM_64: tmp = eDVBFrontendParametersTerrestrial::Modulation_QAM64; break;
+	default:
+	case QAM_AUTO: tmp = eDVBFrontendParametersTerrestrial::Modulation_Auto; break;
+	}
+	PutToDict(dict, "constellation", tmp);
+	switch (parm_u_ofdm_transmission_mode)
+	{
+	case TRANSMISSION_MODE_2K: tmp = eDVBFrontendParametersTerrestrial::TransmissionMode_2k; break;
+	case TRANSMISSION_MODE_8K: tmp = eDVBFrontendParametersTerrestrial::TransmissionMode_8k; break;
+	default:
+	case TRANSMISSION_MODE_AUTO: tmp = eDVBFrontendParametersTerrestrial::TransmissionMode_Auto; break;
+	}
+	PutToDict(dict, "transmission_mode", tmp);
+	switch (parm_u_ofdm_guard_interval)
+	{
+		case GUARD_INTERVAL_1_32: tmp = eDVBFrontendParametersTerrestrial::GuardInterval_1_32; break;
+		case GUARD_INTERVAL_1_16: tmp = eDVBFrontendParametersTerrestrial::GuardInterval_1_16; break;
+		case GUARD_INTERVAL_1_8: tmp = eDVBFrontendParametersTerrestrial::GuardInterval_1_8; break;
+		case GUARD_INTERVAL_1_4: tmp = eDVBFrontendParametersTerrestrial::GuardInterval_1_4; break;
+		default:
+		case GUARD_INTERVAL_AUTO: tmp = eDVBFrontendParametersTerrestrial::GuardInterval_Auto; break;
+	}
+	PutToDict(dict, "guard_interval", tmp);
+	switch (parm_u_ofdm_hierarchy_information)
+	{
+		case HIERARCHY_NONE: tmp = eDVBFrontendParametersTerrestrial::Hierarchy_None; break;
+		case HIERARCHY_1: tmp = eDVBFrontendParametersTerrestrial::Hierarchy_1; break;
+		case HIERARCHY_2: tmp = eDVBFrontendParametersTerrestrial::Hierarchy_2; break;
+		case HIERARCHY_4: tmp = eDVBFrontendParametersTerrestrial::Hierarchy_4; break;
+		default:
+		case HIERARCHY_AUTO: tmp = eDVBFrontendParametersTerrestrial::Hierarchy_Auto; break;
+	}
+	PutToDict(dict, "hierarchy_information", tmp);
+}
+
+void eDVBFrontend::getFrontendStatus(ePyObject dest)
+{
+	if (dest && PyDict_Check(dest))
+	{
+		const char *tmp = "UNKNOWN";
+		switch(m_state)
+		{
+			case stateIdle:
+				tmp="IDLE";
+				break;
+			case stateTuning:
+				tmp="TUNING";
+				break;
+			case stateFailed:
+				tmp="FAILED";
+				break;
+			case stateLock:
+				tmp="LOCKED";
+				break;
+			case stateLostLock:
+				tmp="LOSTLOCK";
+				break;
+			default:
+				break;
+		}
+		PutToDict(dest, "tuner_state", tmp);
+		PutToDict(dest, "tuner_locked", readFrontendData(locked));
+		PutToDict(dest, "tuner_synced", readFrontendData(synced));
+		PutToDict(dest, "tuner_bit_error_rate", readFrontendData(bitErrorRate));
+		PutToDict(dest, "tuner_signal_quality", readFrontendData(signalQuality));
+		int sigQualitydB = readFrontendData(signalQualitydB);
+		if (sigQualitydB == 0x12345678) // not support yet
+		{
+			ePyObject obj=Py_None;
+			Py_INCREF(obj);
+			PutToDict(dest, "tuner_signal_quality_db", obj);
+		}
+		else
+			PutToDict(dest, "tuner_signal_quality_db", sigQualitydB);
+		PutToDict(dest, "tuner_signal_power", readFrontendData(signalPower));
+	}
+}
+
+void eDVBFrontend::getTransponderData(ePyObject dest, bool original)
+{
+	if (dest && PyDict_Check(dest))
+	{
+		FRONTENDPARAMETERS front;
+#if HAVE_DVB_API_VERSION >= 5
+		struct dtv_property p[4];
+		struct dtv_properties cmdseq;
+		cmdseq.props = p;
+		cmdseq.num = 4;
+		p[0].cmd = DTV_DELIVERY_SYSTEM;
+		p[1].cmd = DTV_MODULATION;
+		p[2].cmd = DTV_ROLLOFF;
+		p[3].cmd = DTV_PILOT;
+#endif
+		if (m_simulate || m_fd == -1 || original)
+			original = true;
+#if HAVE_DVB_API_VERSION >= 5
+		else if (m_type == feSatellite && // yet just use new api for DVB-S(2) only
+			ioctl(m_fd, FE_GET_PROPERTY, &cmdseq)<0)
+		{
+			eDebug("FE_GET_PROPERTY failed (%m)");
+			original = true;
+		}
+#endif
+		else if (ioctl(m_fd, FE_GET_FRONTEND, &front)<0)
+		{
+			eDebug("FE_GET_FRONTEND failed (%m)");
+			original = true;
+		}
+		if (original)
+		{
+			switch(m_type)
+			{
+				case feSatellite:
+					PutSatelliteDataToDict(dest, oparm.sat);
+					break;
+				case feCable:
+					PutCableDataToDict(dest, oparm.cab);
+					break;
+				case feTerrestrial:
+					PutTerrestrialDataToDict(dest, oparm.ter);
+					break;
+			}
+		}
+		else
+		{
+			FRONTENDPARAMETERS &parm = front;
+			long tmp = eDVBFrontendParametersSatellite::Inversion_Unknown;
+			switch(parm_inversion & 3)
+			{
+				case INVERSION_ON:
+					tmp = eDVBFrontendParametersSatellite::Inversion_On;
+					break;
+				case INVERSION_OFF:
+					tmp = eDVBFrontendParametersSatellite::Inversion_Off;
+				default:
+					break;
+			}
+			PutToDict(dest, "inversion", tmp);
+			switch(m_type)
+			{
+				case feSatellite:
+#if HAVE_DVB_API_VERSION >= 5
+					fillDictWithSatelliteData(dest, parm, p, m_data[FREQ_OFFSET], oparm.sat.orbital_position, oparm.sat.polarisation);
+#else
+					fillDictWithSatelliteData(dest, parm, m_data[FREQ_OFFSET], oparm.sat.orbital_position, oparm.sat.polarisation);
+#endif
+					break;
+				case feCable:
+					fillDictWithCableData(dest, parm);
+					break;
+				case feTerrestrial:
+					fillDictWithTerrestrialData(dest, parm);
+					break;
+			}
+		}
+	}
+}
+
+void eDVBFrontend::getFrontendData(ePyObject dest)
+{
+	if (dest && PyDict_Check(dest))
+	{
+		const char *tmp=0;
+		PutToDict(dest, "tuner_number", m_slotid);
+		switch(m_type)
+		{
+			case feSatellite:
+				tmp = "DVB-S";
+				break;
+			case feCable:
+				tmp = "DVB-C";
+				break;
+			case feTerrestrial:
+				tmp = "DVB-T";
+				break;
+			default:
+				tmp = "UNKNOWN";
+				break;
+		}
+		PutToDict(dest, "tuner_type", tmp);
+	}
+}
+
+#ifndef FP_IOCTL_GET_ID
+#define FP_IOCTL_GET_ID 0
+#endif
+int eDVBFrontend::readInputpower()
+{
+	if (m_simulate)
+		return 0;
+	int power=m_slotid;  // this is needed for read inputpower from the correct tuner !
+	char proc_name[64];
+	char proc_name2[64];
+	sprintf(proc_name, "/proc/stb/frontend/%d/lnb_sense", m_slotid);
+	sprintf(proc_name2, "/proc/stb/fp/lnb_sense%d", m_slotid);
+	FILE *f;
+	if ((f=fopen(proc_name, "r")) || (f=fopen(proc_name2, "r")))
+	{
+		if (fscanf(f, "%d", &power) != 1)
+			eDebug("read %s failed!! (%m)", proc_name);
+		else
+			eDebug("%s is %d\n", proc_name, power);
+		fclose(f);
+	}
+	else
+	{
+		// open front prozessor
+		int fp=::open("/dev/dbox/fp0", O_RDWR);
+		if (fp < 0)
+		{
+			eDebug("couldn't open fp");
+			return -1;
+		}
+		static bool old_fp = (::ioctl(fp, FP_IOCTL_GET_ID) < 0);
+		if ( ioctl( fp, old_fp ? 9 : 0x100, &power ) < 0 )
+		{
+			eDebug("FP_IOCTL_GET_LNB_CURRENT failed (%m)");
+			return -1;
+		}
+		::close(fp);
+	}
+
+	return power;
+}
+
+bool eDVBFrontend::setSecSequencePos(int steps)
+{
+	eDebugNoSimulate("set sequence pos %d", steps);
+	if (!steps)
+		return false;
+	while( steps > 0 )
+	{
+		if (m_sec_sequence.current() != m_sec_sequence.end())
+			++m_sec_sequence.current();
+		--steps;
+	}
+	while( steps < 0 )
+	{
+		if (m_sec_sequence.current() != m_sec_sequence.begin() && m_sec_sequence.current() != m_sec_sequence.end())
+			--m_sec_sequence.current();
+		++steps;
+	}
+	return true;
+}
+
+void eDVBFrontend::tuneLoop()  // called by m_tuneTimer
+{
+	int delay=0;
+	eDVBFrontend *sec_fe = this;
+	eDVBRegisteredFrontend *regFE = 0;
+	long tmp = m_data[LINKED_PREV_PTR];
+	while ( tmp != -1 )
+	{
+		eDVBRegisteredFrontend *prev = (eDVBRegisteredFrontend *)tmp;
+		sec_fe = prev->m_frontend;
+		tmp = prev->m_frontend->m_data[LINKED_PREV_PTR];
+		if (tmp == -1 && sec_fe != this && !prev->m_inuse) {
+			int state = sec_fe->m_state;
+			// workaround to put the kernel frontend thread into idle state!
+			if (state != eDVBFrontend::stateIdle && state != stateClosed)
+			{
+				sec_fe->closeFrontend(true);
+				state = sec_fe->m_state;
+			}
+			// sec_fe is closed... we must reopen it here..
+			if (state == stateClosed)
+			{
+				regFE = prev;
+				prev->inc_use();
+			}
+		}
+	}
+
+	if ( m_sec_sequence && m_sec_sequence.current() != m_sec_sequence.end() )
+	{
+		long *sec_fe_data = sec_fe->m_data;
+//		eDebugNoSimulate("tuneLoop %d\n", m_sec_sequence.current()->cmd);
+		switch (m_sec_sequence.current()->cmd)
+		{
+			case eSecCommand::SLEEP:
+				delay = m_sec_sequence.current()++->msec;
+				eDebugNoSimulate("[SEC] sleep %dms", delay);
+				break;
+			case eSecCommand::GOTO:
+				if ( !setSecSequencePos(m_sec_sequence.current()->steps) )
+					++m_sec_sequence.current();
+				break;
+			case eSecCommand::SET_VOLTAGE:
+			{
+				int voltage = m_sec_sequence.current()++->voltage;
+				eDebugNoSimulate("[SEC] setVoltage %d", voltage);
+				sec_fe->setVoltage(voltage);
+				break;
+			}
+			case eSecCommand::IF_VOLTAGE_GOTO:
+			{
+				eSecCommand::pair &compare = m_sec_sequence.current()->compare;
+				if ( compare.voltage == sec_fe_data[CUR_VOLTAGE] && setSecSequencePos(compare.steps) )
+					break;
+				++m_sec_sequence.current();
+				break;
+			}
+			case eSecCommand::IF_NOT_VOLTAGE_GOTO:
+			{
+				eSecCommand::pair &compare = m_sec_sequence.current()->compare;
+				if ( compare.voltage != sec_fe_data[CUR_VOLTAGE] && setSecSequencePos(compare.steps) )
+					break;
+				++m_sec_sequence.current();
+				break;
+			}
+			case eSecCommand::IF_TONE_GOTO:
+			{
+				eSecCommand::pair &compare = m_sec_sequence.current()->compare;
+				if ( compare.tone == sec_fe_data[CUR_TONE] && setSecSequencePos(compare.steps) )
+					break;
+				++m_sec_sequence.current();
+				break;
+			}
+			case eSecCommand::IF_NOT_TONE_GOTO:
+			{
+				eSecCommand::pair &compare = m_sec_sequence.current()->compare;
+				if ( compare.tone != sec_fe_data[CUR_TONE] && setSecSequencePos(compare.steps) )
+					break;
+				++m_sec_sequence.current();
+				break;
+			}
+			case eSecCommand::SET_TONE:
+				eDebugNoSimulate("[SEC] setTone %d", m_sec_sequence.current()->tone);
+				sec_fe->setTone(m_sec_sequence.current()++->tone);
+				break;
+			case eSecCommand::SEND_DISEQC:
+				sec_fe->sendDiseqc(m_sec_sequence.current()->diseqc);
+				eDebugNoSimulateNoNewLine("[SEC] sendDiseqc: ");
+				for (int i=0; i < m_sec_sequence.current()->diseqc.len; ++i)
+				    eDebugNoSimulateNoNewLine("%02x", m_sec_sequence.current()->diseqc.data[i]);
+			 	if (!memcmp(m_sec_sequence.current()->diseqc.data, "\xE0\x00\x00", 3))
+					eDebugNoSimulate("(DiSEqC reset)");
+				else if (!memcmp(m_sec_sequence.current()->diseqc.data, "\xE0\x00\x03", 3))
+					eDebugNoSimulate("(DiSEqC peripherial power on)");
+				else
+					eDebugNoSimulate("");
+				++m_sec_sequence.current();
+				break;
+			case eSecCommand::SEND_TONEBURST:
+				eDebugNoSimulate("[SEC] sendToneburst: %d", m_sec_sequence.current()->toneburst);
+				sec_fe->sendToneburst(m_sec_sequence.current()++->toneburst);
+				break;
+			case eSecCommand::SET_FRONTEND:
+			{
+				int enableEvents = (m_sec_sequence.current()++)->val;
+				eDebugNoSimulate("[SEC] setFrontend %d", enableEvents);
+				setFrontend(enableEvents);
+				break;
+			}
+			case eSecCommand::START_TUNE_TIMEOUT:
+			{
+				int tuneTimeout = m_sec_sequence.current()->timeout;
+				eDebugNoSimulate("[SEC] startTuneTimeout %d", tuneTimeout);
+				if (!m_simulate)
+					m_timeout->start(tuneTimeout, 1);
+				++m_sec_sequence.current();
+				break;
+			}
+			case eSecCommand::SET_TIMEOUT:
+				m_timeoutCount = m_sec_sequence.current()++->val;
+				eDebugNoSimulate("[SEC] set timeout %d", m_timeoutCount);
+				break;
+			case eSecCommand::IF_TIMEOUT_GOTO:
+				if (!m_timeoutCount)
+				{
+					eDebugNoSimulate("[SEC] rotor timout");
+					setSecSequencePos(m_sec_sequence.current()->steps);
+				}
+				else
+					++m_sec_sequence.current();
+				break;
+			case eSecCommand::MEASURE_IDLE_INPUTPOWER:
+			{
+				int idx = m_sec_sequence.current()++->val;
+				if ( idx == 0 || idx == 1 )
+				{
+					m_idleInputpower[idx] = sec_fe->readInputpower();
+					eDebugNoSimulate("[SEC] idleInputpower[%d] is %d", idx, m_idleInputpower[idx]);
+				}
+				else
+					eDebugNoSimulate("[SEC] idleInputpower measure index(%d) out of bound !!!", idx);
+				break;
+			}
+			case eSecCommand::IF_MEASURE_IDLE_WAS_NOT_OK_GOTO:
+			{
+				eSecCommand::pair &compare = m_sec_sequence.current()->compare;
+				int idx = compare.val;
+				if ( !m_simulate && (idx == 0 || idx == 1) )
+				{
+					int idle = sec_fe->readInputpower();
+					int diff = abs(idle-m_idleInputpower[idx]);
+					if ( diff > 0)
+					{
+						eDebugNoSimulate("measure idle(%d) was not okay.. (%d - %d = %d) retry", idx, m_idleInputpower[idx], idle, diff);
+						setSecSequencePos(compare.steps);
+						break;
+					}
+				}
+				++m_sec_sequence.current();
+				break;
+			}
+			case eSecCommand::IF_TUNER_LOCKED_GOTO:
+			{
+				eSecCommand::rotor &cmd = m_sec_sequence.current()->measure;
+				if (m_simulate)
+				{
+					setSecSequencePos(cmd.steps);
+					break;
+				}
+				int signal = 0;
+				int isLocked = readFrontendData(locked);
+				m_idleInputpower[0] = m_idleInputpower[1] = 0;
+				--m_timeoutCount;
+				if (!m_timeoutCount && m_retryCount > 0)
+					--m_retryCount;
+				if (isLocked && ((abs((signal = readFrontendData(signalQualitydB)) - cmd.lastSignal) < 40) || !cmd.lastSignal))
+				{
+					if (cmd.lastSignal)
+						eDebugNoSimulate("[SEC] locked step %d ok (%d %d)", cmd.okcount, signal, cmd.lastSignal);
+					else
+					{
+						eDebugNoSimulate("[SEC] locked step %d ok", cmd.okcount);
+						if (!cmd.okcount)
+							cmd.lastSignal = signal;
+					}
+					++cmd.okcount;
+					if (cmd.okcount > 4)
+					{
+						eDebugNoSimulate("ok > 4 .. goto %d\n", cmd.steps);
+						setSecSequencePos(cmd.steps);
+						m_state = stateLock;
+						m_stateChanged(this);
+						feEvent(-1); // flush events
+						m_sn->start();
+						break;
+					}
+				}
+				else
+				{
+					if (isLocked)
+						eDebugNoSimulate("[SEC] rotor locked step %d failed (oldSignal %d, curSignal %d)", cmd.okcount, signal, cmd.lastSignal);
+					else
+						eDebugNoSimulate("[SEC] rotor locked step %d failed (not locked)", cmd.okcount);
+					cmd.okcount=0;
+					cmd.lastSignal=0;
+				}
+				++m_sec_sequence.current();
+				break;
+			}
+			case eSecCommand::MEASURE_RUNNING_INPUTPOWER:
+				m_runningInputpower = sec_fe->readInputpower();
+				eDebugNoSimulate("[SEC] runningInputpower is %d", m_runningInputpower);
+				++m_sec_sequence.current();
+				break;
+			case eSecCommand::SET_ROTOR_MOVING:
+				if (!m_simulate)
+					m_sec->setRotorMoving(m_slotid, true);
+				++m_sec_sequence.current();
+				break;
+			case eSecCommand::SET_ROTOR_STOPPED:
+				if (!m_simulate)
+					m_sec->setRotorMoving(m_slotid, false);
+				++m_sec_sequence.current();
+				break;
+			case eSecCommand::IF_INPUTPOWER_DELTA_GOTO:
+			{
+				eSecCommand::rotor &cmd = m_sec_sequence.current()->measure;
+				if (m_simulate)
+				{
+					setSecSequencePos(cmd.steps);
+					break;
+				}
+				int idleInputpower = m_idleInputpower[ (sec_fe_data[CUR_VOLTAGE]&1) ? 0 : 1];
+				const char *txt = cmd.direction ? "running" : "stopped";
+				--m_timeoutCount;
+				if (!m_timeoutCount && m_retryCount > 0)
+					--m_retryCount;
+				eDebugNoSimulate("[SEC] waiting for rotor %s %d, idle %d, delta %d",
+					txt,
+					m_runningInputpower,
+					idleInputpower,
+					cmd.deltaA);
+				if ( (cmd.direction && abs(m_runningInputpower - idleInputpower) >= cmd.deltaA)
+					|| (!cmd.direction && abs(m_runningInputpower - idleInputpower) <= cmd.deltaA) )
+				{
+					++cmd.okcount;
+					eDebugNoSimulate("[SEC] rotor %s step %d ok", txt, cmd.okcount);
+					if ( cmd.okcount > 6 )
+					{
+						eDebugNoSimulate("[SEC] rotor is %s", txt);
+						if (setSecSequencePos(cmd.steps))
+							break;
+					}
+				}
+				else
+				{
+					eDebugNoSimulate("[SEC] rotor not %s... reset counter.. increase timeout", txt);
+					cmd.okcount=0;
+				}
+				++m_sec_sequence.current();
+				break;
+			}
+			case eSecCommand::IF_ROTORPOS_VALID_GOTO:
+				if (sec_fe_data[ROTOR_CMD] != -1 && sec_fe_data[ROTOR_POS] != -1)
+					setSecSequencePos(m_sec_sequence.current()->steps);
+				else
+					++m_sec_sequence.current();
+				break;
+			case eSecCommand::INVALIDATE_CURRENT_SWITCHPARMS:
+				eDebugNoSimulate("[SEC] invalidate current switch params");
+				sec_fe_data[CSW] = -1;
+				sec_fe_data[UCSW] = -1;
+				sec_fe_data[TONEBURST] = -1;
+				++m_sec_sequence.current();
+				break;
+			case eSecCommand::UPDATE_CURRENT_SWITCHPARMS:
+				sec_fe_data[CSW] = sec_fe_data[NEW_CSW];
+				sec_fe_data[UCSW] = sec_fe_data[NEW_UCSW];
+				sec_fe_data[TONEBURST] = sec_fe_data[NEW_TONEBURST];
+				eDebugNoSimulate("[SEC] update current switch params");
+				++m_sec_sequence.current();
+				break;
+			case eSecCommand::INVALIDATE_CURRENT_ROTORPARMS:
+				eDebugNoSimulate("[SEC] invalidate current rotorparams");
+				sec_fe_data[ROTOR_CMD] = -1;
+				sec_fe_data[ROTOR_POS] = -1;
+				++m_sec_sequence.current();
+				break;
+			case eSecCommand::UPDATE_CURRENT_ROTORPARAMS:
+				sec_fe_data[ROTOR_CMD] = sec_fe_data[NEW_ROTOR_CMD];
+				sec_fe_data[ROTOR_POS] = sec_fe_data[NEW_ROTOR_POS];
+				eDebugNoSimulate("[SEC] update current rotorparams %d %04lx %ld", m_timeoutCount, sec_fe_data[ROTOR_CMD], sec_fe_data[ROTOR_POS]);
+				++m_sec_sequence.current();
+				break;
+			case eSecCommand::SET_ROTOR_DISEQC_RETRYS:
+				m_retryCount = m_sec_sequence.current()++->val;
+				eDebugNoSimulate("[SEC] set rotor retries %d", m_retryCount);
+				break;
+			case eSecCommand::IF_NO_MORE_ROTOR_DISEQC_RETRYS_GOTO:
+				if (!m_retryCount)
+				{
+					eDebugNoSimulate("[SEC] no more rotor retrys");
+					setSecSequencePos(m_sec_sequence.current()->steps);
+				}
+				else
+					++m_sec_sequence.current();
+				break;
+			case eSecCommand::SET_POWER_LIMITING_MODE:
+			{
+				if (!m_simulate)
+				{
+					char proc_name[64];
+					sprintf(proc_name, "/proc/stb/frontend/%d/static_current_limiting", sec_fe->m_dvbid);
+					FILE *f=fopen(proc_name, "w");
+					if (f) // new interface exist?
+					{
+						bool slimiting = m_sec_sequence.current()->mode == eSecCommand::modeStatic;
+						if (fprintf(f, "%s", slimiting ? "on" : "off") <= 0)
+							eDebugNoSimulate("write %s failed!! (%m)", proc_name);
+						else
+							eDebugNoSimulate("[SEC] set %s current limiting", slimiting ? "static" : "dynamic");
+						fclose(f);
+					}
+					else if (sec_fe->m_need_rotor_workaround)
+					{
+						char dev[16];
+						int slotid = sec_fe->m_slotid;
+						// FIXMEEEEEE hardcoded i2c devices for dm7025 and dm8000
+						if (slotid < 2)
+							sprintf(dev, "/dev/i2c/%d", slotid);
+						else if (slotid == 2)
+							sprintf(dev, "/dev/i2c/2"); // first nim socket on DM8000 use /dev/i2c/2
+						else if (slotid == 3)
+							sprintf(dev, "/dev/i2c/4"); // second nim socket on DM8000 use /dev/i2c/4
+						int fd = ::open(dev, O_RDWR);
+
+						unsigned char data[2];
+						::ioctl(fd, I2C_SLAVE_FORCE, 0x10 >> 1);
+						if(::read(fd, data, 1) != 1)
+							eDebugNoSimulate("[SEC] error read lnbp (%m)");
+						if ( m_sec_sequence.current()->mode == eSecCommand::modeStatic )
+						{
+							data[0] |= 0x80;  // enable static current limiting
+							eDebugNoSimulate("[SEC] set static current limiting");
+						}
+						else
+						{
+							data[0] &= ~0x80;  // enable dynamic current limiting
+							eDebugNoSimulate("[SEC] set dynamic current limiting");
+						}
+						if(::write(fd, data, 1) != 1)
+							eDebugNoSimulate("[SEC] error write lnbp (%m)");
+						::close(fd);
+					}
+				}
+				++m_sec_sequence.current();
+				break;
+			}
+			default:
+				eDebugNoSimulate("[SEC] unhandled sec command %d",
+					++m_sec_sequence.current()->cmd);
+				++m_sec_sequence.current();
+		}
+		if (!m_simulate)
+			m_tuneTimer->start(delay,true);
+	}
+	if (regFE)
+		regFE->dec_use();
+	if (m_simulate && m_sec_sequence.current() != m_sec_sequence.end())
+		tuneLoop();
+}
+
+void eDVBFrontend::setFrontend(bool recvEvents)
+{
+	if (!m_simulate)
+	{
+		eDebug("setting frontend %d", m_dvbid);
+		if (recvEvents)
+			m_sn->start();
+		feEvent(-1); // flush events
+#if HAVE_DVB_API_VERSION >= 5
+		if (m_type == iDVBFrontend::feSatellite)
+		{
+			fe_rolloff_t rolloff = ROLLOFF_35;
+			fe_pilot_t pilot = PILOT_OFF;
+			fe_modulation_t modulation = QPSK;
+			fe_delivery_system_t system = SYS_DVBS;
+			switch(oparm.sat.system)
+			{
+			case eDVBFrontendParametersSatellite::System_DVB_S: system = SYS_DVBS; break;
+			case eDVBFrontendParametersSatellite::System_DVB_S2: system = SYS_DVBS2; break;
+			};
+			switch(oparm.sat.modulation)
+			{
+			case eDVBFrontendParametersSatellite::Modulation_QPSK: modulation = QPSK; break;
+			case eDVBFrontendParametersSatellite::Modulation_8PSK: modulation = PSK_8; break;
+			case eDVBFrontendParametersSatellite::Modulation_QAM16: modulation = QAM_16; break;
+			};
+			switch(oparm.sat.pilot)
+			{
+			case eDVBFrontendParametersSatellite::Pilot_Off: pilot = PILOT_OFF; break;
+			case eDVBFrontendParametersSatellite::Pilot_On: pilot = PILOT_ON; break;
+			case eDVBFrontendParametersSatellite::Pilot_Unknown: pilot = PILOT_AUTO; break;
+			};
+			switch(oparm.sat.rolloff)
+			{
+			case eDVBFrontendParametersSatellite::RollOff_alpha_0_20: rolloff = ROLLOFF_20; break;
+			case eDVBFrontendParametersSatellite::RollOff_alpha_0_25: rolloff = ROLLOFF_25; break;
+			case eDVBFrontendParametersSatellite::RollOff_alpha_0_35: rolloff = ROLLOFF_35; break;
+			};
+			struct dtv_property p[10];
+			struct dtv_properties cmdseq;
+			cmdseq.props = p;
+			p[0].cmd = DTV_CLEAR;
+			p[1].cmd = DTV_DELIVERY_SYSTEM,	p[1].u.data = system;
+			p[2].cmd = DTV_FREQUENCY,	p[2].u.data = parm_frequency;
+			p[3].cmd = DTV_MODULATION,	p[3].u.data = modulation;
+			p[4].cmd = DTV_SYMBOL_RATE,	p[4].u.data = parm_u_qpsk_symbol_rate;
+			p[5].cmd = DTV_INNER_FEC,	p[5].u.data = parm_u_qpsk_fec_inner;
+			p[6].cmd = DTV_INVERSION,	p[6].u.data = parm_inversion;
+			if (system == SYS_DVBS2)
+			{
+				p[7].cmd = DTV_ROLLOFF,		p[7].u.data = rolloff;
+				p[8].cmd = DTV_PILOT,		p[8].u.data = pilot;
+				p[9].cmd = DTV_TUNE;
+				cmdseq.num = 10;
+			}
+			else
+			{
+				p[7].cmd = DTV_TUNE;
+				cmdseq.num = 8;
+			}
+			if (ioctl(m_fd, FE_SET_PROPERTY, &cmdseq) == -1)
+			{
+				perror("FE_SET_PROPERTY failed");
+				return;
+			}
+		}
+		else
+#endif
+		{
+			if (ioctl(m_fd, FE_SET_FRONTEND, &parm) == -1)
+			{
+				perror("FE_SET_FRONTEND failed");
+				return;
+			}
+		}
+	}
+}
+
+RESULT eDVBFrontend::getFrontendType(int &t)
+{
+	if (m_type == -1)
+		return -ENODEV;
+	t = m_type;
+	return 0;
+}
+
+RESULT eDVBFrontend::prepare_sat(const eDVBFrontendParametersSatellite &feparm, unsigned int tunetimeout)
+{
+	int res;
+	if (!m_sec)
+	{
+		eWarning("no SEC module active!");
+		return -ENOENT;
+	}
+	res = m_sec->prepare(*this, parm, feparm, 1 << m_slotid, tunetimeout);
+	if (!res)
+	{
+#if HAVE_DVB_API_VERSION >= 3
+		eDebugNoSimulate("prepare_sat System %d Freq %d Pol %d SR %d INV %d FEC %d orbpos %d system %d modulation %d pilot %d, rolloff %d",
+			feparm.system,
+			feparm.frequency,
+			feparm.polarisation,
+			feparm.symbol_rate,
+			feparm.inversion,
+			feparm.fec,
+			feparm.orbital_position,
+			feparm.system,
+			feparm.modulation,
+			feparm.pilot,
+			feparm.rolloff);
+#else
+		eDebugNoSimulate("prepare_sat System %d Freq %d Pol %d SR %d INV %d FEC %d orbpos %d",
+			feparm.system,
+			feparm.frequency,
+			feparm.polarisation,
+			feparm.symbol_rate,
+			feparm.inversion,
+			feparm.fec,
+			feparm.orbital_position);
+#endif
+		parm_u_qpsk_symbol_rate = feparm.symbol_rate;
+		switch (feparm.inversion)
+		{
+			case eDVBFrontendParametersSatellite::Inversion_On:
+				parm_inversion = INVERSION_ON;
+				break;
+			case eDVBFrontendParametersSatellite::Inversion_Off:
+				parm_inversion = INVERSION_OFF;
+				break;
+			default:
+			case eDVBFrontendParametersSatellite::Inversion_Unknown:
+				parm_inversion = INVERSION_AUTO;
+				break;
+		}
+		if (feparm.system == eDVBFrontendParametersSatellite::System_DVB_S)
+		{
+			switch (feparm.fec)
+			{
+				case eDVBFrontendParametersSatellite::FEC_None:
+					parm_u_qpsk_fec_inner = FEC_NONE;
+					break;
+				case eDVBFrontendParametersSatellite::FEC_1_2:
+					parm_u_qpsk_fec_inner = FEC_1_2;
+					break;
+				case eDVBFrontendParametersSatellite::FEC_2_3:
+					parm_u_qpsk_fec_inner = FEC_2_3;
+					break;
+				case eDVBFrontendParametersSatellite::FEC_3_4:
+					parm_u_qpsk_fec_inner = FEC_3_4;
+					break;
+				case eDVBFrontendParametersSatellite::FEC_5_6:
+					parm_u_qpsk_fec_inner = FEC_5_6;
+					break;
+				case eDVBFrontendParametersSatellite::FEC_7_8:
+					parm_u_qpsk_fec_inner = FEC_7_8;
+					break;
+				default:
+					eDebugNoSimulate("no valid fec for DVB-S set.. assume auto");
+				case eDVBFrontendParametersSatellite::FEC_Auto:
+					parm_u_qpsk_fec_inner = FEC_AUTO;
+					break;
+			}
+		}
+#if HAVE_DVB_API_VERSION >= 3
+		else // DVB_S2
+		{
+			switch (feparm.fec)
+			{
+				case eDVBFrontendParametersSatellite::FEC_1_2:
+					parm_u_qpsk_fec_inner = FEC_S2_QPSK_1_2;
+					break;
+				case eDVBFrontendParametersSatellite::FEC_2_3:
+					parm_u_qpsk_fec_inner = FEC_S2_QPSK_2_3;
+					break;
+				case eDVBFrontendParametersSatellite::FEC_3_4:
+					parm_u_qpsk_fec_inner = FEC_S2_QPSK_3_4;
+					break;
+				case eDVBFrontendParametersSatellite::FEC_3_5:
+					parm_u_qpsk_fec_inner = FEC_S2_QPSK_3_5;
+					break;
+				case eDVBFrontendParametersSatellite::FEC_4_5:
+					parm_u_qpsk_fec_inner = FEC_S2_QPSK_4_5;
+					break;
+				case eDVBFrontendParametersSatellite::FEC_5_6:
+					parm_u_qpsk_fec_inner = FEC_S2_QPSK_5_6;
+					break;
+				case eDVBFrontendParametersSatellite::FEC_7_8:
+					parm_u_qpsk_fec_inner = FEC_S2_QPSK_7_8;
+					break;
+				case eDVBFrontendParametersSatellite::FEC_8_9:
+					parm_u_qpsk_fec_inner = FEC_S2_QPSK_8_9;
+					break;
+				case eDVBFrontendParametersSatellite::FEC_9_10:
+					parm_u_qpsk_fec_inner = FEC_S2_QPSK_9_10;
+					break;
+				default:
+					eDebugNoSimulate("no valid fec for DVB-S2 set.. abort !!");
+					return -EINVAL;
+			}
+#if HAVE_DVB_API_VERSION < 5
+			parm_inversion |= (feparm.rolloff << 2); // Hack.. we use bit 2..3 of inversion param for rolloff
+			parm_inversion |= (feparm.pilot << 4); // Hack.. we use bit 4..5 of inversion param for pilot
+			if (feparm.modulation == eDVBFrontendParametersSatellite::Modulation_8PSK) 
+			{
+				parm_u_qpsk_fec_inner = (fe_code_rate_t)((int)parm_u_qpsk_fec_inner+9);
+				// 8PSK fec driver values are decimal 9 bigger
+			}
+#endif
+		}
+#endif
+		// FIXME !!! get frequency range from tuner
+		if ( parm_frequency < 900000 || parm_frequency > 2200000 )
+		{
+			eDebugNoSimulate("%d mhz out of tuner range.. dont tune", parm_frequency/1000);
+			return -EINVAL;
+		}
+		eDebugNoSimulate("tuning to %d mhz", parm_frequency/1000);
+	}
+	oparm.sat = feparm;
+	return res;
+}
+
+RESULT eDVBFrontend::prepare_cable(const eDVBFrontendParametersCable &feparm)
+{
+#if HAVE_DVB_API_VERSION < 3
+	parm_frequency = feparm.frequency;
+#else
+	parm_frequency = feparm.frequency * 1000;
+#endif
+	parm_u_qam_symbol_rate = feparm.symbol_rate;
+	switch (feparm.modulation)
+	{
+	case eDVBFrontendParametersCable::Modulation_QAM16:
+		parm_u_qam_modulation = QAM_16;
+		break;
+	case eDVBFrontendParametersCable::Modulation_QAM32:
+		parm_u_qam_modulation = QAM_32;
+		break;
+	case eDVBFrontendParametersCable::Modulation_QAM64:
+		parm_u_qam_modulation = QAM_64;
+		break;
+	case eDVBFrontendParametersCable::Modulation_QAM128:
+		parm_u_qam_modulation = QAM_128;
+		break;
+	case eDVBFrontendParametersCable::Modulation_QAM256:
+		parm_u_qam_modulation = QAM_256;
+		break;
+	default:
+	case eDVBFrontendParametersCable::Modulation_Auto:
+		parm_u_qam_modulation = QAM_AUTO;
+		break;
+	}
+	switch (feparm.inversion)
+	{
+	case eDVBFrontendParametersCable::Inversion_On:
+		parm_inversion = INVERSION_ON;
+		break;
+	case eDVBFrontendParametersCable::Inversion_Off:
+		parm_inversion = INVERSION_OFF;
+		break;
+	default:
+	case eDVBFrontendParametersCable::Inversion_Unknown:
+		parm_inversion = INVERSION_AUTO;
+		break;
+	}
+	switch (feparm.fec_inner)
+	{
+	case eDVBFrontendParametersCable::FEC_None:
+		parm_u_qam_fec_inner = FEC_NONE;
+		break;
+	case eDVBFrontendParametersCable::FEC_1_2:
+		parm_u_qam_fec_inner = FEC_1_2;
+		break;
+	case eDVBFrontendParametersCable::FEC_2_3:
+		parm_u_qam_fec_inner = FEC_2_3;
+		break;
+	case eDVBFrontendParametersCable::FEC_3_4:
+		parm_u_qam_fec_inner = FEC_3_4;
+		break;
+	case eDVBFrontendParametersCable::FEC_5_6:
+		parm_u_qam_fec_inner = FEC_5_6;
+		break;
+	case eDVBFrontendParametersCable::FEC_7_8:
+		parm_u_qam_fec_inner = FEC_7_8;
+		break;
+#if HAVE_DVB_API_VERSION >= 3
+	case eDVBFrontendParametersCable::FEC_8_9:
+		parm_u_qam_fec_inner = FEC_8_9;
+		break;
+#endif
+	default:
+	case eDVBFrontendParametersCable::FEC_Auto:
+		parm_u_qam_fec_inner = FEC_AUTO;
+		break;
+	}
+	eDebugNoSimulate("tuning to %d khz, sr %d, fec %d, modulation %d, inversion %d",
+		parm_frequency/1000,
+		parm_u_qam_symbol_rate,
+		parm_u_qam_fec_inner,
+		parm_u_qam_modulation,
+		parm_inversion);
+	oparm.cab = feparm;
+	return 0;
+}
+
+RESULT eDVBFrontend::prepare_terrestrial(const eDVBFrontendParametersTerrestrial &feparm)
+{
+	parm_frequency = feparm.frequency;
+
+	switch (feparm.bandwidth)
+	{
+	case eDVBFrontendParametersTerrestrial::Bandwidth_8MHz:
+		parm_u_ofdm_bandwidth = BANDWIDTH_8_MHZ;
+		break;
+	case eDVBFrontendParametersTerrestrial::Bandwidth_7MHz:
+		parm_u_ofdm_bandwidth = BANDWIDTH_7_MHZ;
+		break;
+	case eDVBFrontendParametersTerrestrial::Bandwidth_6MHz:
+		parm_u_ofdm_bandwidth = BANDWIDTH_6_MHZ;
+		break;
+	default:
+	case eDVBFrontendParametersTerrestrial::Bandwidth_Auto:
+		parm_u_ofdm_bandwidth = BANDWIDTH_AUTO;
+		break;
+	}
+	switch (feparm.code_rate_LP)
+	{
+	case eDVBFrontendParametersTerrestrial::FEC_1_2:
+		parm_u_ofdm_code_rate_LP = FEC_1_2;
+		break;
+	case eDVBFrontendParametersTerrestrial::FEC_2_3:
+		parm_u_ofdm_code_rate_LP = FEC_2_3;
+		break;
+	case eDVBFrontendParametersTerrestrial::FEC_3_4:
+		parm_u_ofdm_code_rate_LP = FEC_3_4;
+		break;
+	case eDVBFrontendParametersTerrestrial::FEC_5_6:
+		parm_u_ofdm_code_rate_LP = FEC_5_6;
+		break;
+	case eDVBFrontendParametersTerrestrial::FEC_7_8:
+		parm_u_ofdm_code_rate_LP = FEC_7_8;
+		break;
+	default:
+	case eDVBFrontendParametersTerrestrial::FEC_Auto:
+		parm_u_ofdm_code_rate_LP = FEC_AUTO;
+		break;
+	}
+	switch (feparm.code_rate_HP)
+	{
+	case eDVBFrontendParametersTerrestrial::FEC_1_2:
+		parm_u_ofdm_code_rate_HP = FEC_1_2;
+		break;
+	case eDVBFrontendParametersTerrestrial::FEC_2_3:
+		parm_u_ofdm_code_rate_HP = FEC_2_3;
+		break;
+	case eDVBFrontendParametersTerrestrial::FEC_3_4:
+		parm_u_ofdm_code_rate_HP = FEC_3_4;
+		break;
+	case eDVBFrontendParametersTerrestrial::FEC_5_6:
+		parm_u_ofdm_code_rate_HP = FEC_5_6;
+		break;
+	case eDVBFrontendParametersTerrestrial::FEC_7_8:
+		parm_u_ofdm_code_rate_HP = FEC_7_8;
+		break;
+	default:
+	case eDVBFrontendParametersTerrestrial::FEC_Auto:
+		parm_u_ofdm_code_rate_HP = FEC_AUTO;
+		break;
+	}
+	switch (feparm.modulation)
+	{
+	case eDVBFrontendParametersTerrestrial::Modulation_QPSK:
+		parm_u_ofdm_constellation = QPSK;
+		break;
+	case eDVBFrontendParametersTerrestrial::Modulation_QAM16:
+		parm_u_ofdm_constellation = QAM_16;
+		break;
+	case eDVBFrontendParametersTerrestrial::Modulation_QAM64:
+		parm_u_ofdm_constellation = QAM_64;
+		break;
+	default:
+	case eDVBFrontendParametersTerrestrial::Modulation_Auto:
+		parm_u_ofdm_constellation = QAM_AUTO;
+		break;
+	}
+	switch (feparm.transmission_mode)
+	{
+	case eDVBFrontendParametersTerrestrial::TransmissionMode_2k:
+		parm_u_ofdm_transmission_mode = TRANSMISSION_MODE_2K;
+		break;
+	case eDVBFrontendParametersTerrestrial::TransmissionMode_8k:
+		parm_u_ofdm_transmission_mode = TRANSMISSION_MODE_8K;
+		break;
+	default:
+	case eDVBFrontendParametersTerrestrial::TransmissionMode_Auto:
+		parm_u_ofdm_transmission_mode = TRANSMISSION_MODE_AUTO;
+		break;
+	}
+	switch (feparm.guard_interval)
+	{
+		case eDVBFrontendParametersTerrestrial::GuardInterval_1_32:
+			parm_u_ofdm_guard_interval = GUARD_INTERVAL_1_32;
+			break;
+		case eDVBFrontendParametersTerrestrial::GuardInterval_1_16:
+			parm_u_ofdm_guard_interval = GUARD_INTERVAL_1_16;
+			break;
+		case eDVBFrontendParametersTerrestrial::GuardInterval_1_8:
+			parm_u_ofdm_guard_interval = GUARD_INTERVAL_1_8;
+			break;
+		case eDVBFrontendParametersTerrestrial::GuardInterval_1_4:
+			parm_u_ofdm_guard_interval = GUARD_INTERVAL_1_4;
+			break;
+		default:
+		case eDVBFrontendParametersTerrestrial::GuardInterval_Auto:
+			parm_u_ofdm_guard_interval = GUARD_INTERVAL_AUTO;
+			break;
+	}
+	switch (feparm.hierarchy)
+	{
+		case eDVBFrontendParametersTerrestrial::Hierarchy_None:
+			parm_u_ofdm_hierarchy_information = HIERARCHY_NONE;
+			break;
+		case eDVBFrontendParametersTerrestrial::Hierarchy_1:
+			parm_u_ofdm_hierarchy_information = HIERARCHY_1;
+			break;
+		case eDVBFrontendParametersTerrestrial::Hierarchy_2:
+			parm_u_ofdm_hierarchy_information = HIERARCHY_2;
+			break;
+		case eDVBFrontendParametersTerrestrial::Hierarchy_4:
+			parm_u_ofdm_hierarchy_information = HIERARCHY_4;
+			break;
+		default:
+		case eDVBFrontendParametersTerrestrial::Hierarchy_Auto:
+			parm_u_ofdm_hierarchy_information = HIERARCHY_AUTO;
+			break;
+	}
+	switch (feparm.inversion)
+	{
+	case eDVBFrontendParametersTerrestrial::Inversion_On:
+		parm_inversion = INVERSION_ON;
+		break;
+	case eDVBFrontendParametersTerrestrial::Inversion_Off:
+		parm_inversion = INVERSION_OFF;
+		break;
+	default:
+	case eDVBFrontendParametersTerrestrial::Inversion_Unknown:
+		parm_inversion = INVERSION_AUTO;
+		break;
+	}
+	oparm.ter = feparm;
+	return 0;
+}
+
+RESULT eDVBFrontend::tune(const iDVBFrontendParameters &where)
+{
+	unsigned int timeout = 5000;
+	eDebugNoSimulate("(%d)tune", m_dvbid);
+
+	m_timeout->stop();
+
+	int res=0;
+
+	if (!m_sn && !m_simulate)
+	{
+		eDebug("no frontend device opened... do not try to tune !!!");
+		res = -ENODEV;
+		goto tune_error;
+	}
+
+	if (m_type == -1)
+	{
+		res = -ENODEV;
+		goto tune_error;
+	}
+
+	if (!m_simulate)
+		m_sn->stop();
+
+	m_sec_sequence.clear();
+
+	where.calcLockTimeout(timeout);
+
+	switch (m_type)
+	{
+	case feSatellite:
+	{
+		eDVBFrontendParametersSatellite feparm;
+		if (where.getDVBS(feparm))
+		{
+			eDebug("no dvbs data!");
+			res = -EINVAL;
+			goto tune_error;
+		}
+		if (m_rotor_mode != feparm.no_rotor_command_on_tune && !feparm.no_rotor_command_on_tune)
+		{
+			eDVBFrontend *sec_fe = this;
+			long tmp = m_data[LINKED_PREV_PTR];
+			while (tmp != -1)
+			{
+				eDVBRegisteredFrontend *linked_fe = (eDVBRegisteredFrontend*)tmp;
+				sec_fe = linked_fe->m_frontend;
+				sec_fe->getData(LINKED_NEXT_PTR, tmp);
+			}
+			eDebug("(fe%d) reset diseqc after leave rotor mode!", m_dvbid);
+			sec_fe->m_data[CSW] = sec_fe->m_data[UCSW] = sec_fe->m_data[TONEBURST] = sec_fe->m_data[ROTOR_CMD] = sec_fe->m_data[ROTOR_POS] = -1; // reset diseqc
+		}
+		m_rotor_mode = feparm.no_rotor_command_on_tune;
+		if (!m_simulate)
+			m_sec->setRotorMoving(m_slotid, false);
+		res=prepare_sat(feparm, timeout);
+		if (res)
+			goto tune_error;
+
+		break;
+	}
+	case feCable:
+	{
+		eDVBFrontendParametersCable feparm;
+		if (where.getDVBC(feparm))
+		{
+			res = -EINVAL;
+			goto tune_error;
+		}
+		res=prepare_cable(feparm);
+		if (res)
+			goto tune_error;
+
+		m_sec_sequence.push_back( eSecCommand(eSecCommand::START_TUNE_TIMEOUT, timeout) );
+		m_sec_sequence.push_back( eSecCommand(eSecCommand::SET_FRONTEND, 1) );
+		break;
+	}
+	case feTerrestrial:
+	{
+		eDVBFrontendParametersTerrestrial feparm;
+		if (where.getDVBT(feparm))
+		{
+			eDebug("no -T data");
+			res = -EINVAL;
+			goto tune_error;
+		}
+		res=prepare_terrestrial(feparm);
+		if (res)
+			goto tune_error;
+
+		std::string enable_5V;
+		char configStr[255];
+		snprintf(configStr, 255, "config.Nims.%d.terrestrial_5V", m_slotid);
+		m_sec_sequence.push_back( eSecCommand(eSecCommand::START_TUNE_TIMEOUT, timeout) );
+		ePythonConfigQuery::getConfigValue(configStr, enable_5V);
+		if (enable_5V == "True")
+			m_sec_sequence.push_back( eSecCommand(eSecCommand::SET_VOLTAGE, iDVBFrontend::voltage13) );
+		else
+			m_sec_sequence.push_back( eSecCommand(eSecCommand::SET_VOLTAGE, iDVBFrontend::voltageOff) );
+		m_sec_sequence.push_back( eSecCommand(eSecCommand::SET_FRONTEND, 1) );
+
+		break;
+	}
+	}
+
+	m_sec_sequence.current() = m_sec_sequence.begin();
+
+	if (!m_simulate)
+	{
+		m_tuneTimer->start(0,true);
+		m_tuning = 1;
+		if (m_state != stateTuning)
+		{
+			m_state = stateTuning;
+			m_stateChanged(this);
+		}
+	}
+	else
+		tuneLoop();
+
+	return res;
+
+tune_error:
+	m_tuneTimer->stop();
+	return res;
+}
+
+RESULT eDVBFrontend::connectStateChange(const Slot1<void,iDVBFrontend*> &stateChange, ePtr<eConnection> &connection)
+{
+	connection = new eConnection(this, m_stateChanged.connect(stateChange));
+	return 0;
+}
+
+RESULT eDVBFrontend::setVoltage(int voltage)
+{
+	if (m_type == feCable)
+		return -1;
+#if HAVE_DVB_API_VERSION < 3
+	secVoltage vlt;
+#else
+	bool increased=false;
+	fe_sec_voltage_t vlt;
+#endif
+	m_data[CUR_VOLTAGE]=voltage;
+	switch (voltage)
+	{
+	case voltageOff:
+		m_data[CSW]=m_data[UCSW]=m_data[TONEBURST]=-1; // reset diseqc
+		vlt = SEC_VOLTAGE_OFF;
+		break;
+	case voltage13_5:
+#if HAVE_DVB_API_VERSION < 3
+		vlt = SEC_VOLTAGE_13_5;
+		break;
+#else
+		increased = true;
+#endif
+	case voltage13:
+		vlt = SEC_VOLTAGE_13;
+		break;
+	case voltage18_5:
+#if HAVE_DVB_API_VERSION < 3
+		vlt = SEC_VOLTAGE_18_5;
+		break;
+#else
+		increased = true;
+#endif
+	case voltage18:
+		vlt = SEC_VOLTAGE_18;
+		break;
+	default:
+		return -ENODEV;
+	}
+	if (m_simulate)
+		return 0;
+#if HAVE_DVB_API_VERSION < 3
+	return ::ioctl(m_secfd, SEC_SET_VOLTAGE, vlt);
+#else
+	if (m_type == feSatellite && ::ioctl(m_fd, FE_ENABLE_HIGH_LNB_VOLTAGE, increased) < 0)
+		perror("FE_ENABLE_HIGH_LNB_VOLTAGE");
+	return ::ioctl(m_fd, FE_SET_VOLTAGE, vlt);
+#endif
+}
+
+RESULT eDVBFrontend::getState(int &state)
+{
+	state = m_state;
+	return 0;
+}
+
+RESULT eDVBFrontend::setTone(int t)
+{
+	if (m_type != feSatellite)
+		return -1;
+#if HAVE_DVB_API_VERSION < 3
+	secToneMode_t tone;
+#else
+	fe_sec_tone_mode_t tone;
+#endif
+	m_data[CUR_TONE]=t;
+	switch (t)
+	{
+	case toneOn:
+		tone = SEC_TONE_ON;
+		break;
+	case toneOff:
+		tone = SEC_TONE_OFF;
+		break;
+	default:
+		return -ENODEV;
+	}
+	if (m_simulate)
+		return 0;
+#if HAVE_DVB_API_VERSION < 3	
+	return ::ioctl(m_secfd, SEC_SET_TONE, tone);
+#else	
+	return ::ioctl(m_fd, FE_SET_TONE, tone);
+#endif
+}
+
+#if HAVE_DVB_API_VERSION < 3 && !defined(SEC_DISEQC_SEND_MASTER_CMD)
+	#define SEC_DISEQC_SEND_MASTER_CMD _IOW('o', 97, struct secCommand *)
+#endif
+
+RESULT eDVBFrontend::sendDiseqc(const eDVBDiseqcCommand &diseqc)
+{
+	if (m_simulate)
+		return 0;
+#if HAVE_DVB_API_VERSION < 3
+	struct secCommand cmd;
+	cmd.type = SEC_CMDTYPE_DISEQC_RAW;
+	cmd.u.diseqc.cmdtype = diseqc.data[0];
+	cmd.u.diseqc.addr = diseqc.data[1];
+	cmd.u.diseqc.cmd = diseqc.data[2];
+	cmd.u.diseqc.numParams = diseqc.len-3;
+	memcpy(cmd.u.diseqc.params, diseqc.data+3, diseqc.len-3);
+	if (::ioctl(m_secfd, SEC_DISEQC_SEND_MASTER_CMD, &cmd))
+#else
+	struct dvb_diseqc_master_cmd cmd;
+	memcpy(cmd.msg, diseqc.data, diseqc.len);
+	cmd.msg_len = diseqc.len;
+	if (::ioctl(m_fd, FE_DISEQC_SEND_MASTER_CMD, &cmd))
+#endif
+		return -EINVAL;
+	return 0;
+}
+
+#if HAVE_DVB_API_VERSION < 3 && !defined(SEC_DISEQC_SEND_BURST)
+	#define SEC_DISEQC_SEND_BURST _IO('o', 96)
+#endif
+RESULT eDVBFrontend::sendToneburst(int burst)
+{
+	if (m_simulate)
+		return 0;
+#if HAVE_DVB_API_VERSION < 3
+	secMiniCmd cmd = SEC_MINI_NONE;
+#else
+	fe_sec_mini_cmd_t cmd = SEC_MINI_A;
+#endif
+	if ( burst == eDVBSatelliteDiseqcParameters::A )
+		cmd = SEC_MINI_A;
+	else if ( burst == eDVBSatelliteDiseqcParameters::B )
+		cmd = SEC_MINI_B;
+#if HAVE_DVB_API_VERSION < 3
+	if (::ioctl(m_secfd, SEC_DISEQC_SEND_BURST, cmd))
+		return -EINVAL;
+#else
+	if (::ioctl(m_fd, FE_DISEQC_SEND_BURST, cmd))
+		return -EINVAL;
+#endif
+	return 0;
+}
+
+RESULT eDVBFrontend::setSEC(iDVBSatelliteEquipmentControl *sec)
+{
+	m_sec = sec;
+	return 0;
+}
+
+RESULT eDVBFrontend::setSecSequence(const eSecCommandList &list)
+{
+	m_sec_sequence = list;
+	return 0;
+}
+
+RESULT eDVBFrontend::getData(int num, long &data)
+{
+	if ( num < NUM_DATA_ENTRIES )
+	{
+		data = m_data[num];
+		return 0;
+	}
+	return -EINVAL;
+}
+
+RESULT eDVBFrontend::setData(int num, long val)
+{
+	if ( num < NUM_DATA_ENTRIES )
+	{
+		m_data[num] = val;
+		return 0;
+	}
+	return -EINVAL;
+}
+
+int eDVBFrontend::isCompatibleWith(ePtr<iDVBFrontendParameters> &feparm)
+{
+	int type;
+	if (feparm->getSystem(type) || type != m_type || !m_enabled)
+		return 0;
+	if (m_type == eDVBFrontend::feSatellite)
+	{
+		ASSERT(m_sec);
+		eDVBFrontendParametersSatellite sat_parm;
+		int ret = feparm->getDVBS(sat_parm);
+		ASSERT(!ret);
+		if (sat_parm.system == eDVBFrontendParametersSatellite::System_DVB_S2 && !m_can_handle_dvbs2)
+			return 0;
+		ret = m_sec->canTune(sat_parm, this, 1 << m_slotid);
+		if (ret > 1 && sat_parm.system == eDVBFrontendParametersSatellite::System_DVB_S && m_can_handle_dvbs2)
+			ret -= 1;
+		return ret;
+	}
+	else if (m_type == eDVBFrontend::feCable)
+		return 2;  // more prio for cable frontends
+	else if (m_type == eDVBFrontend::feTerrestrial)
+		return 1;
+	return 0;
+}
+
+bool eDVBFrontend::setSlotInfo(ePyObject obj)
+{
+	ePyObject Id, Descr, Enabled, IsDVBS2;
+	if (!PyTuple_Check(obj) || PyTuple_Size(obj) != 4)
+		goto arg_error;
+	Id = PyTuple_GET_ITEM(obj, 0);
+	Descr = PyTuple_GET_ITEM(obj, 1);
+	Enabled = PyTuple_GET_ITEM(obj, 2);
+	IsDVBS2 = PyTuple_GET_ITEM(obj, 3);
+	if (!PyInt_Check(Id) || !PyString_Check(Descr) || !PyBool_Check(Enabled) || !PyBool_Check(IsDVBS2))
+		goto arg_error;
+	strcpy(m_description, PyString_AS_STRING(Descr));
+	m_slotid = PyInt_AsLong(Id);
+	m_enabled = Enabled == Py_True;
+	// HACK.. the rotor workaround is neede for all NIMs with LNBP21 voltage regulator...
+	m_need_rotor_workaround = !!strstr(m_description, "Alps BSBE1") ||
+		!!strstr(m_description, "Alps BSBE2") ||
+		!!strstr(m_description, "Alps -S") ||
+		!!strstr(m_description, "BCM4501");
+	m_can_handle_dvbs2 = IsDVBS2 == Py_True;
+	eDebugNoSimulate("setSlotInfo for dvb frontend %d to slotid %d, descr %s, need rotorworkaround %s, enabled %s, DVB-S2 %s",
+		m_dvbid, m_slotid, m_description, m_need_rotor_workaround ? "Yes" : "No", m_enabled ? "Yes" : "No", m_can_handle_dvbs2 ? "Yes" : "No" );
+	return true;
+arg_error:
+	PyErr_SetString(PyExc_StandardError,
+		"eDVBFrontend::setSlotInfo must get a tuple with first param slotid, second param slot description and third param enabled boolean");
+	return false;
+}
+
+RESULT eDVBFrontend::turnOffSatCR(int satcr)
+{
+	eSecCommandList sec_sequence;
+	// check if voltage is disabled
+	eSecCommand::pair compare;
+	compare.steps = +9;	//nothing to do
+	compare.voltage = iDVBFrontend::voltageOff;
+	sec_sequence.push_back( eSecCommand(eSecCommand::IF_NOT_VOLTAGE_GOTO, compare) );
+	sec_sequence.push_back( eSecCommand(eSecCommand::SET_VOLTAGE, iDVBFrontend::voltage13) );
+	sec_sequence.push_back( eSecCommand(eSecCommand::SLEEP, 50 ) );
+
+	sec_sequence.push_back( eSecCommand(eSecCommand::SET_VOLTAGE, iDVBFrontend::voltage18_5) );
+	sec_sequence.push_back( eSecCommand(eSecCommand::SET_TONE, iDVBFrontend::toneOff) );
+	sec_sequence.push_back( eSecCommand(eSecCommand::SLEEP, 250) );
+
+	eDVBDiseqcCommand diseqc;
+	memset(diseqc.data, 0, MAX_DISEQC_LENGTH);
+	diseqc.len = 5;
+	diseqc.data[0] = 0xE0;
+	diseqc.data[1] = 0x10;
+	diseqc.data[2] = 0x5A;
+	diseqc.data[3] = satcr << 5;
+	diseqc.data[4] = 0x00;
+
+	sec_sequence.push_back( eSecCommand(eSecCommand::SEND_DISEQC, diseqc) );
+	sec_sequence.push_back( eSecCommand(eSecCommand::SLEEP, 50+20+14*diseqc.len) );
+	sec_sequence.push_back( eSecCommand(eSecCommand::SET_VOLTAGE, iDVBFrontend::voltage13) );
+	setSecSequence(sec_sequence);
+	return 0;
+}
+
+RESULT eDVBFrontend::ScanSatCR()
+{
+	setFrontend();
+	usleep(20000);
+	setTone(iDVBFrontend::toneOff);
+	return 0;
+}
diff -Nur enigma2-nightly/lib/dvb/volume.cpp enigma2-nightly.spark/lib/dvb/volume.cpp
--- enigma2-nightly/lib/dvb/volume.cpp	2010-08-11 18:16:49.592748615 +0800
+++ enigma2-nightly.spark/lib/dvb/volume.cpp	2010-08-11 18:12:24.901612579 +0800
@@ -29,7 +29,9 @@
 eDVBVolumecontrol::eDVBVolumecontrol()
 {
 	volumeUnMute();
+#ifndef __sh__
 	setVolume(100, 100);
+#endif
 }
 
 int eDVBVolumecontrol::openMixer()
diff -Nur enigma2-nightly/lib/dvb_ci/dvbci_appmgr.cpp enigma2-nightly.spark/lib/dvb_ci/dvbci_appmgr.cpp
--- enigma2-nightly/lib/dvb_ci/dvbci_appmgr.cpp	2010-08-11 18:16:49.593768249 +0800
+++ enigma2-nightly.spark/lib/dvb_ci/dvbci_appmgr.cpp	2010-08-11 18:12:24.794468884 +0800
@@ -6,17 +6,32 @@
 
 eDVBCIApplicationManagerSession::eDVBCIApplicationManagerSession(eDVBCISlot *tslot)
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	slot = tslot;
 	slot->setAppManager(this);
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 eDVBCIApplicationManagerSession::~eDVBCIApplicationManagerSession()
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	slot->setAppManager(NULL);
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 int eDVBCIApplicationManagerSession::receivedAPDU(const unsigned char *tag,const void *data, int len)
 {
+#ifdef __sh__
+	eDebug("eDVBCIApplicationManagerSession::%s >", __func__);
+#endif
 	eDebugNoNewLine("SESSION(%d)/APP %02x %02x %02x: ", session_nb, tag[0], tag[1], tag[2]);
 	for (int i=0; i<len; i++)
 		eDebugNoNewLine("%02x ", ((const unsigned char*)data)[i]);
@@ -58,11 +73,17 @@
 			break;
 		}
 	}
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 	return 0;
 }
 
 int eDVBCIApplicationManagerSession::doAction()
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
   switch (state)
   {
   case stateStarted:
@@ -70,6 +91,9 @@
     const unsigned char tag[3]={0x9F, 0x80, 0x20}; // application manager info e    sendAPDU(tag);
 		sendAPDU(tag);
     state=stateFinal;
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
     return 1;
   }
   case stateFinal:
@@ -81,19 +105,35 @@
       const unsigned char tag[3]={0x9F, 0x80, 0x22};  // Tenter_menu
       sendAPDU(tag);
       wantmenu=0;
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
       return 0;
     } else
       return 0;
   default:
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
     return 0;
   }
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 int eDVBCIApplicationManagerSession::startMMI()
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	eDebug("in appmanager -> startmmi()");
 	const unsigned char tag[3]={0x9F, 0x80, 0x22};  // Tenter_menu
 	sendAPDU(tag);
+#ifdef __sh__
+	slot->mmiOpened();
+	eDebug("%s <", __func__);
+#endif
 	return 0;
 }
 
diff -Nur enigma2-nightly/lib/dvb_ci/dvbci_camgr.cpp enigma2-nightly.spark/lib/dvb_ci/dvbci_camgr.cpp
--- enigma2-nightly/lib/dvb_ci/dvbci_camgr.cpp	2010-08-11 18:16:49.594872397 +0800
+++ enigma2-nightly.spark/lib/dvb_ci/dvbci_camgr.cpp	2010-08-11 18:12:24.796695157 +0800
@@ -5,17 +5,32 @@
 
 eDVBCICAManagerSession::eDVBCICAManagerSession(eDVBCISlot *tslot)
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	slot = tslot;
 	slot->setCAManager(this);
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 eDVBCICAManagerSession::~eDVBCICAManagerSession()
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	slot->setCAManager(NULL);
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 int eDVBCICAManagerSession::receivedAPDU(const unsigned char *tag, const void *data, int len)
 {
+#ifdef __sh__
+	eDebug("eDVBCICAManagerSession::%s >", __func__);
+#endif
 	eDebugNoNewLine("SESSION(%d)/CA %02x %02x %02x: ", session_nb, tag[0], tag[1],tag[2]);
 	for (int i=0; i<len; i++)
 		eDebugNoNewLine("%02x ", ((const unsigned char*)data)[i]);
@@ -41,11 +56,17 @@
 			break;
 		}
 	}
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 	return 0;
 }
 
 int eDVBCICAManagerSession::doAction()
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	switch (state)
 	{
 	case stateStarted:
@@ -53,21 +74,38 @@
 		const unsigned char tag[3]={0x9F, 0x80, 0x30}; // ca info enq
 		sendAPDU(tag);
 		state=stateFinal;
+#ifdef __sh__
+		//Dagobert disable polling
+		slot->setPoll(false);
+		eDebug("%s <", __func__);
+#endif
 		return 0;
 	}
 	case stateFinal:
 		eDebug("stateFinal und action! kann doch garnicht sein ;)");
 	default:
+#ifdef __sh__
+		eDebug("%s <", __func__);
+#endif
 		return 0;
 	}
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 int eDVBCICAManagerSession::sendCAPMT(unsigned char *data, int len)
 {
 	const unsigned char tag[3]={0x9F, 0x80, 0x32}; // ca_pmt
 
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	sendAPDU(tag, data, len);
 
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 	return 0;
 }
 
diff -Nur enigma2-nightly/lib/dvb_ci/dvbci.cpp enigma2-nightly.spark/lib/dvb_ci/dvbci.cpp
--- enigma2-nightly/lib/dvb_ci/dvbci.cpp	2010-08-11 18:16:49.592748615 +0800
+++ enigma2-nightly.spark/lib/dvb_ci/dvbci.cpp	2010-08-11 18:12:24.799579724 +0800
@@ -16,6 +16,10 @@
 #include <lib/dvb_ci/dvbci_appmgr.h>
 #include <lib/dvb_ci/dvbci_mmi.h>
 
+#ifdef __sh__
+#include <linux/dvb/ca.h>
+#endif
+
 #include <dvbsi++/ca_program_map_section.h>
 
 //#define CIDEBUG 1
@@ -28,6 +32,175 @@
 
 eDVBCIInterfaces *eDVBCIInterfaces::instance = 0;
 
+#ifdef __sh__
+
+#define x_debug
+
+/* ******************************************* */
+/* our module list */
+
+#define module_list "/usr/local/share/enigma2/module.list"
+
+struct module_s
+{
+	char 	name[256];
+	int	polling_time;
+};
+
+static struct module_s* our_modules = NULL;
+static int no_modules = 0;
+
+int getModulePollTimeFromFile(const char* ourModule)
+{
+	eDebug("%s ->%s\n", __func__, ourModule);
+
+	if (ourModule == NULL)
+		return -1;
+		
+	if (our_modules == NULL)
+	{
+		FILE* fd = fopen(module_list, "r");
+		char  buffer[512];
+		
+		if (fd == NULL)
+		{
+			eDebug("error reading module list (%s)\n", module_list);
+			return -1;
+		}
+		
+		while (fgets(buffer, 512, fd) != NULL)
+		{
+			if ((buffer[0] == '#') || (buffer[0] ==  '!'))
+				continue;
+				
+			no_modules++;
+			our_modules = (struct module_s*) realloc(our_modules, sizeof(struct module_s) * no_modules);
+
+			sscanf(buffer, "%s %d", 
+				our_modules[no_modules - 1].name, 
+				&our_modules[no_modules - 1].polling_time);
+
+			eDebug("%d. name = %s - pollTime = %d", no_modules - 1, our_modules[no_modules - 1].name,
+								our_modules[no_modules - 1].polling_time);
+		}
+	}
+
+	for (int vLoop = 0; vLoop < no_modules; vLoop++)
+	{
+		eDebug("%d. %s ->pollTime = %d", vLoop, our_modules[vLoop].name, our_modules[vLoop].polling_time);
+	
+		if (strlen(ourModule) < strlen(our_modules[vLoop].name))		
+			continue;
+			
+		if (strstr(ourModule, our_modules[vLoop].name) != NULL)
+		{
+			eDebug("%d. found module in list (%s) ->pollTime = %d", vLoop, our_modules[vLoop].name, our_modules[vLoop].polling_time);
+			return our_modules[vLoop].polling_time;
+		}
+	}
+	
+	eDebug("Module not found in %s ->default poll time = 100ms", module_list);
+	
+	return 100;
+}
+
+bool eDVBCISlot::checkQueueSize()
+{
+	return (sendqueue.size() > 0);
+
+}
+
+void eDVBCISlot::thread()
+{
+	eDebug("eDVBCISlot::%s >\n",__func__); 
+
+	hasStarted();
+	nice(4);
+
+	//I want to sleep a little until all is really read
+	//->we should fix this later and determine while polling
+	//starts to early
+	sleep(2);
+
+	while (1)
+	{
+		int poller = 0;
+		
+		if ((getState() == stateInserted) ||
+		    (getState() == stateResetted))
+		{
+		
+		   std::string appname = eDVBCI_UI::getInstance()->getAppName(getSlotID());
+
+		   //eDebug("appname %s\n", appname.c_str());
+
+		   if (appname.empty())
+		   {
+			poller = 100;	
+		   } else
+		   {
+		   	if (getModulePollTime() == -1)
+			   setModulePollTime(getModulePollTimeFromFile(appname.c_str()));
+		   
+		   	poller = getModulePollTime();
+		   }
+
+		   if (getPoll())
+		   {
+			   struct timeval last = getPollTime();
+			   struct timeval now;
+			   struct timezone dummy;
+
+			   //during menu actions, or if the mmi_sessions is not ready we poll regardless if the
+			   //configuration says us not to poll
+			   if ((poller == 0) && ((mmi_active) || (ca_manager == 0)))
+				   poller = 100;
+
+			   /* dagobert: there maybe a ca_manager but the caids has not yet been
+			    * delivered so lets poll ...
+			    */	
+                           if ((ca_manager != 0) && (ca_manager->getCAIDs().empty() == true))
+			   {	
+				   poller = 100;
+			   	   
+				   //eDebug("pollTime %d, mmi_active = %d, ca_manager = %x, %d\n", poller, mmi_active, ca_manager, ca_manager->getCAIDs().empty());
+			   } else
+                           if (ca_manager != 0)
+			   {
+				   //eDebug("pollTime %d, mmi_active = %d, ca_manager = %x, %d\n", poller, mmi_active, ca_manager, ca_manager->getCAIDs().empty());
+			   }
+			   else		
+			   {	   
+			           //eDebug("pollTime %d, mmi_active = %d, ca_manager = %x\n", poller, mmi_active, ca_manager);
+			   }
+
+			   if (poller != 0)
+
+			   {
+			      gettimeofday(&now, &dummy);
+
+			      if ((difftime(now.tv_sec, last.tv_sec) != 0) ||
+				(now.tv_usec >= last.tv_usec + (poller * 1000)))
+			      {
+				 //send a data last (0xa0) message if there are no messages waiting in the queue
+				 if (checkQueueSize() == false)
+				    send(NULL, 0);
+				 setPollTime(now);
+			      }
+			   }
+		    }
+		}
+
+		if (poller != 0)
+			usleep(poller * 1000);
+		else
+			usleep(1000000);
+		
+	}
+}
+
+#endif
+
 eDVBCIInterfaces::eDVBCIInterfaces()
 {
 	int num_ci = 0;
@@ -40,10 +213,21 @@
 	{
 		struct stat s;
 		char filename[128];
+#ifdef __sh__
+		sprintf(filename, "/dev/dvb/adapter0/ci%d", num_ci);
+#else
 		sprintf(filename, "/dev/ci%d", num_ci);
+#endif
 
 		if (stat(filename, &s))
+#ifdef __sh__
+		{
+			eDebug("stat on %s failed\n", filename);		
+#endif
 			break;
+#ifdef __sh__
+		}
+#endif
 
 		ePtr<eDVBCISlot> cislot;
 
@@ -105,6 +289,9 @@
 int eDVBCIInterfaces::reset(int slotid)
 {
 	eDVBCISlot *slot;
+#ifdef __sh__
+	eDebug("eDVBCIInterfaces::reset %d\n", slotid);
+#endif
 
 	if( (slot = getSlot(slotid)) == 0 )
 		return -1;
@@ -940,9 +1127,80 @@
 	return -1;
 }
 
+#ifdef __sh__
+/* ********************** start of __sh__ ************************* */
+
+
+/* taken from dvb-apps 
+ * todo / fixme: add copyright etc ...
+ */
+#define T_SB                0x80	// sb                           primitive   h<--m
+#define T_RCV               0x81	// receive                      primitive   h-->m
+#define T_CREATE_T_C        0x82	// create transport connection  primitive   h-->m
+#define T_C_T_C_REPLY       0x83	// ctc reply                    primitive   h<--m
+#define T_DELETE_T_C        0x84	// delete tc                    primitive   h<->m
+#define T_D_T_C_REPLY       0x85	// dtc reply                    primitive   h<->m
+#define T_REQUEST_T_C       0x86	// request transport connection primitive   h<--m
+#define T_NEW_T_C           0x87	// new tc / reply to t_request  primitive   h-->m
+#define T_T_C_ERROR         0x77	// error creating tc            primitive   h-->m
+#define T_DATA_LAST         0xA0	// convey data from higher      constructed h<->m
+				 // layers
+#define T_DATA_MORE         0xA1	// convey data from higher      constructed h<->m
+				 // layers
+#endif
+
+
 int eDVBCISlot::send(const unsigned char *data, size_t len)
 {
 	int res=0;
+#ifdef __sh__
+#ifdef x_debug
+	eDebug("eDVBCISlot::send >\n");
+#endif	
+
+		unsigned char *d = new unsigned char[len + 5];
+		
+		// only poll connection if we are not awaiting an answer
+		pollConnection = false;
+		
+		/* should we send a data last ?
+		 */
+		if (data != NULL)
+		{
+		   if ((data[2] >= T_SB) && (data[2] <= T_NEW_T_C))
+		   {
+		      memcpy(d, data, len);
+		   } else
+		   {
+		      //send data_last and data
+		      memcpy(d + 5, data, len);
+
+		      d[0] = getSlotID();
+		      d[1] = connection_id;
+		      d[2] = T_DATA_LAST; 	
+		      d[3] = len + 1; 		/* len */
+		      d[4] = connection_id; 	/* transport connection identifier*/
+
+		      len += 5;	
+		   }
+		}
+		else
+		{
+		      //send a data last only
+		      d[0] = getSlotID();
+		      d[1] = connection_id;
+		      d[2] = T_DATA_LAST; 	
+		      d[3] = len + 1; 		/* len */
+		      d[4] = connection_id; 	/* transport connection identifier*/
+
+		      len = 5;	
+		}
+#ifdef x_debug
+		eDebugNoNewLine("write (%d): > ", getSlotID());
+		for(int i=0; i < len; i++)
+			eDebugNoNewLine("%02x ",d[i]);
+#endif
+#else
 	//int i;
 	//eDebugNoNewLine("< ");
 	//for(i=0;i<len;i++)
@@ -956,19 +1214,224 @@
 	{
 		unsigned char *d = new unsigned char[len];
 		memcpy(d, data, len);
+#endif
 		sendqueue.push( queueData(d, len) );
 		notifier->setRequested(eSocketNotifier::Read | eSocketNotifier::Priority | eSocketNotifier::Write);
+#ifdef __sh__
+#ifdef x_debug
+	eDebug("eDVBCISlot::send <\n");
+#endif
+#else
 	}
+#endif
 
 	return res;
 }
 
+#ifdef __sh__
+/* from dvb-apps
+ * fixme: add copyright and url
+ */
+int asn_1_decode(uint16_t * length, uint8_t * asn_1_array,
+		 uint32_t asn_1_array_len)
+{
+	uint8_t length_field;
+
+	if (asn_1_array_len < 1)
+		return -1;
+	length_field = asn_1_array[0];
+
+	if (length_field < 0x80) {
+		// there is only one word
+		*length = length_field & 0x7f;
+		return 1;
+	} else if (length_field == 0x81) {
+		if (asn_1_array_len < 2)
+			return -1;
+
+		*length = asn_1_array[1];
+		return 2;
+	} else if (length_field == 0x82) {
+		if (asn_1_array_len < 3)
+			return -1;
+
+		*length = (asn_1_array[1] << 8) | asn_1_array[2];
+		return 3;
+	}
+
+	return -1;
+}
+
+void eDVBCISlot::process_tpdu(char tpdu_tag, __u8* data, int asn_data_length, int con_id)
+{
+      switch (tpdu_tag) 
+      {
+	 case T_C_T_C_REPLY:
+	      eDebug("Got CTC Replay (slot %d, con %d)\n", getSlotID(), con_id);
+
+	      //answer with data last (and if we have with data)
+	      send(NULL, 0);
+	      
+	      break;
+	 case T_DELETE_T_C:
+//FIXME: close sessions etc; slot->reset ?
+//we must answer here with t_c_replay
+
+	      eDebug("Got \"Delete Transport Connection\" from module ->currently not handled!\n");
+	      
+	      break;
+	 case T_D_T_C_REPLY:
+
+	      eDebug("Got \"Delete Transport Connection Replay\" from module!\n");
+	      break;
+
+	 case T_REQUEST_T_C:
+
+	      eDebug("Got \"Request Transport Connection\" from Module ->currently not handled!\n");
+
+	      break;
+	 case T_DATA_MORE:
+	 {
+		int new_data_length = received_len + asn_data_length;
+
+	        eDebug("Got \"Data More\" from Module\n");
+
+		__u8 *new_data_buffer = (__u8*)
+	    		realloc(received_data, new_data_length);
+	
+		received_data = new_data_buffer;
+
+		memcpy(received_data + received_len, data, asn_data_length);
+		
+		received_len = new_data_length;
+					
+	      break;
+	 }
+	 case T_DATA_LAST:
+	 
+	        eDebug("Got \"Data Last\" from Module\n");
+		
+		/* single package */
+	        if (received_data == NULL) 
+		{
+
+	        	eDebug("->single package\n");
+#ifdef x_debug	
+			eDebugNoNewLine("calling receiveData with data (len %d)> ", asn_data_length);
+			for(int i = 0;i < asn_data_length; i++)
+				eDebugNoNewLine("%02x ", data[i]);
+#endif
+
+			eDVBCISession::receiveData(this, data, asn_data_length);
+			eDVBCISession::pollAll();
+		} else 
+		{
+			/* chained package */
+			int new_data_length = received_len + asn_data_length;
+
+	        	eDebug("->chained data\n");
+
+			__u8 *new_data_buffer =
+	    			(__u8*) realloc(received_data, new_data_length);
+	
+			received_data = new_data_buffer;
+
+			memcpy(received_data + received_len, data, asn_data_length);
+		
+			received_len = new_data_length;
+					
+			free(received_data);
+			received_data = NULL;
+			received_len = 0;
+
+#ifdef x_debug	
+			eDebugNoNewLine("calling receiveData with data (len %d)> ", asn_data_length);
+			for(int i = 0;i < received_len; i++)
+				eDebugNoNewLine("%02x ", received_data[i]);
+#endif
+
+			eDVBCISession::receiveData(this, received_data, received_len);
+			eDVBCISession::pollAll();
+		}
+	      break;
+	 case T_SB:
+	 {
+	      eDebug("Got \"SB\" from Module\n");
+
+	      if (data[0] & 0x80)
+	      {
+	      	eDebug("->data ready (%d)\n", getSlotID());
+	
+		//we now wait for an answer so dont poll
+		pollConnection = false;
+
+		// send the RCV and ask for the data
+		unsigned char* send_data = new unsigned char[5];
+
+
+		send_data[0] = getSlotID();
+		send_data[1] = connection_id;
+		send_data[2] = T_RCV;
+		send_data[3] = 1;
+		send_data[4] = connection_id;
+
+#ifdef not_direct
+		sendqueue.push( queueData(send_data, 5));
+#else
+		write(fd, send_data, 5);
+		delete send_data;
+#endif
+	      } else
+	      {
+	        //if the queue is not empty we dont need to send
+		//a polling to the module.
+		if (checkQueueSize() == false)
+			pollConnection = true;
+	      }	
+
+	      break;
+	 }
+	 default:
+	      eDebug("unhandled tpdu_tag 0x%0x\n", tpdu_tag);
+      }
+}
+#endif
+
 void eDVBCISlot::data(int what)
 {
 	eDebugCI("CISlot %d what %d\n", getSlotID(), what);
 	if(what == eSocketNotifier::Priority) {
+#ifdef __sh__
+#ifdef x_debug	
+	eDebug("pollpri\n");
+#endif
+		if ((state == stateInvalid) || (state == stateRemoved))
+		{
+			unsigned char data[5];
+
+			eDebug("ci inserted\n");
+/* doing a hw reset is time wasting because the hw must be initilized. but
+ * the polling mechanism of e2 starts right in the moment where many
+ * other things started. doing no reset here seems to lead in some
+ * missing packages from/to module and so the connection at startup
+ * sometimes does not work.
+ *
+ * I think a proper solution is todo the sending of T_create after a
+ * time offset in the thread?!
+ */
+			reset();
+		} else
+		if((state == stateInserted) || (state == stateResetted))
+		{
+#else
 		if(state != stateRemoved) {
+#endif
 			state = stateRemoved;
+#ifdef __sh__
+			eDebug("ci removed\n");
+			/* kill thread */
+			kill(true);
+#endif	
 			while(sendqueue.size())
 			{
 				delete [] sendqueue.top().data;
@@ -976,12 +1439,17 @@
 			}
 			eDVBCISession::deleteSessions(this);
 			eDVBCIInterfaces::getInstance()->ciRemoved(this);
+#ifdef __sh__
+			notifier->setRequested(eSocketNotifier::Write | eSocketNotifier::Read | eSocketNotifier::Priority);
+#else
 			notifier->setRequested(eSocketNotifier::Read);
+#endif
 			eDVBCI_UI::getInstance()->setState(getSlotID(),0);
 		}
 		return;
 	}
-
+#ifdef __sh__
+#else
 	if (state == stateInvalid)
 		reset();
 
@@ -992,11 +1460,86 @@
 		notifier->setRequested(eSocketNotifier::Read|eSocketNotifier::Priority);
 		/* enable PRI to detect removal or errors */
 	}
+#endif
 
 	if (what & eSocketNotifier::Read) {
+#ifdef __sh__
+		__u8* data = (__u8*) malloc(4096);
+#else
 		__u8 data[4096];
+#endif
 		int r;
+#ifdef __sh__
+		__u8* orig_data = data;
+#ifdef x_debug	
+		eDebug("pollin\n");
+#endif
+		pollConnection = false;
+#endif
 		r = ::read(fd, data, 4096);
+#ifdef __sh__
+		if (r < 0)
+		{
+			eDebug("r = %d, errno = %d\n", r, errno);
+			eDebug("%s", strerror(errno));
+		}
+
+		eDebug("read %d bytes for slot %d\n", r, getSlotID());
+
+#ifdef x_debug	
+		eDebugNoNewLine("read (%d): > ", getSlotID());
+		for(int i = 0; i < r; i++)
+			eDebugNoNewLine("%02x ",data[i]);
+		eDebug("");
+#endif
+
+
+		int s_id = data[0];
+		int c_id = data[1];
+		
+		eDebug("%d: s_id = %d, c_id = %d\n", getSlotID(), s_id, c_id);
+
+		/* taken from the dvb-apps */
+		int data_length = r - 2;
+		data += 2; /* remove leading slot and connection id */
+		while (data_length > 0)
+		{
+			unsigned char tpdu_tag = data[0];
+			unsigned short asn_data_length;
+			int length_field_len;
+		
+			if ((length_field_len = asn_1_decode(&asn_data_length, data + 1, data_length - 1)) < 0) 
+			{
+				eDebug("Received data with invalid asn from module on slot %02x\n", getSlotID());
+				break;
+			}
+
+			if ((asn_data_length < 1) ||
+		    	    (asn_data_length > (data_length - (1 + length_field_len)))) 
+			{
+				eDebug("Received data with invalid length from module on slot %02x\n", getSlotID());
+				break;
+			}
+
+			connection_id = data[1 + length_field_len];
+		
+			//eDebug("Setting connection_id from received data to %d\n", connection_id);
+		
+			data += 1 + length_field_len + 1;
+			data_length -= (1 + length_field_len + 1);
+			asn_data_length--;
+
+			process_tpdu(tpdu_tag, data, asn_data_length, connection_id);
+			
+			// skip over the consumed data
+			data += asn_data_length;
+			data_length -= asn_data_length;
+
+		} // while (data_length)
+	
+		if (orig_data != NULL)
+			free(orig_data);
+#else
 		if(r > 0) {
 //			int i;
 //			eDebugNoNewLine("> ");
@@ -1007,19 +1550,49 @@
 			eDVBCISession::pollAll();
 			return;
 		}
+#endif
 	}
 	else if (what & eSocketNotifier::Write) {
+#ifdef __sh__
+#ifdef x_debug	
+		eDebug("pollout\n");
+#endif
+#endif
 		if (!sendqueue.empty()) {
 			const queueData &qe = sendqueue.top();
+#ifdef __sh__
+#ifdef x_debug	
+			eDebugNoNewLine("sendqueue (%d) > ", getSlotID());
+			for(int i = 0;i < qe.len;i++)
+				eDebugNoNewLine("%02x ", qe.data[i]);
+#endif
+#endif
 			int res = ::write(fd, qe.data, qe.len);
 			if (res >= 0 && (unsigned int)res == qe.len)
 			{
+#ifdef __sh__
+				eDebug("sendqueue: write %d data on fd %d\n", res, fd);
+#endif
 				delete [] qe.data;
 				sendqueue.pop();
 			}
+#ifdef __sh__
+			else
+			{
+				eDebug("r = %d, errno = %d, %s\n", res, errno, strerror(errno));
+			}			
+#endif
 		}
 		else
+#ifdef __sh__
+		{
+		   eDebug("sendqueue emtpy\n");
 			notifier->setRequested(eSocketNotifier::Read|eSocketNotifier::Priority);
+		   pollConnection = true;
+		}
+#else
+			notifier->setRequested(eSocketNotifier::Read|eSocketNotifier::Priority); 
+#endif
 	}
 }
 
@@ -1039,7 +1612,11 @@
 	
 	slotid = nr;
 
+#ifdef __sh__
+	sprintf(filename, "/dev/dvb/adapter0/ci%d", nr);
+#else
 	sprintf(filename, "/dev/ci%d", nr);
+#endif
 
 //	possible_caids.insert(0x1702);
 //	possible_providers.insert(providerPair("PREMIERE", 0xC00000));
@@ -1050,8 +1627,21 @@
 	eDebugCI("CI Slot %d has fd %d", getSlotID(), fd);
 	state = stateInvalid;
 
+#ifdef __sh__
+	/* init buffer to NULL (see T_DATA_LAST and MORE) */
+	received_data = NULL;
+	received_len = 0;
+#endif
 	if (fd >= 0)
 	{
+#ifdef __sh__
+		connection_id = slotid + 1;
+
+		pollConnection = false;
+		last_poll.tv_sec = 0;
+		last_poll.tv_usec = 0;
+		pollTime = -1;
+#endif
 		notifier = eSocketNotifier::create(context, fd, eSocketNotifier::Read | eSocketNotifier::Priority | eSocketNotifier::Write);
 		CONNECT(notifier->activated, eDVBCISlot::data);
 	} else
@@ -1063,7 +1653,14 @@
 eDVBCISlot::~eDVBCISlot()
 {
 	eDVBCISession::deleteSessions(this);
-}
+#ifdef __sh__
+	/* kill thread */
+	kill(true);
+#endif	
+}
+#ifdef __sh__
+/* ********************** end of __sh__ ************************* */
+#endif	
 
 void eDVBCISlot::setAppManager( eDVBCIApplicationManagerSession *session )
 {
@@ -1085,10 +1682,25 @@
 	return slotid;
 }
 
+#ifdef __sh__
+/* ********************** start of __sh__ ************************* */
+#endif
 int eDVBCISlot::reset()
 {
 	eDebug("CI Slot %d: reset requested", getSlotID());
-
+#ifdef __sh__
+	/* kill thread */
+	kill(true);
+
+	state = stateResetted;
+
+	pollConnection = false;
+	last_poll.tv_sec = 0;
+	last_poll.tv_usec = 0;
+	pollTime = -1;
+	mmi_active = false;
+	eDVBCI_UI::getInstance()->setAppName(getSlotID(), "");
+#else
 	if (state == stateInvalid)
 	{
 		unsigned char buf[256];
@@ -1096,6 +1708,7 @@
 		while(::read(fd, buf, 256)>0);
 		state = stateResetted;
 	}
+#endif	
 
 	while(sendqueue.size())
 	{
@@ -1103,11 +1716,74 @@
 		sendqueue.pop();
 	}
 
+#ifdef __sh__
+	if (ioctl(fd, CA_RESET, getSlotID()) < 0)
+		eDebug("IOCTL CA_RESET failed for slot %d\n", slotid);
+
+	ca_slot_info_t info;
+
+	info.num = slotid;
+
+	eDebug("waiting on cam on slot %d\n", slotid);
+
+	//we block until we have a connection or failed
+	int count = 0;
+	while (count != 50)
+	{
+		count++;
+	   	if (ioctl(fd, CA_GET_SLOT_INFO, &info) < 0)
+			eDebug("IOCTL CA_GET_SLOT_INFO failed for slot %d\n", slotid);
+
+	   	if (info.flags & CA_CI_MODULE_READY)
+			break;
+	   	
+#ifdef later
+		if ((info.flags & CA_CI_MODULE_INVALID) && (count > 5))
+			break;
+#endif			
+		usleep(100000);
+	}
+
+	if (info.flags & CA_CI_MODULE_READY)
+        {
+		unsigned char data[5];
+
+		eDebug("cam present\n");
+
+		eDVBCI_UI::getInstance()->setState(getSlotID(),1);
+		notifier->setRequested(eSocketNotifier::Write | eSocketNotifier::Read | eSocketNotifier::Priority);
+
+		data[0] = getSlotID();
+		data[1] = getSlotID() + 1; 	/* conid */
+		data[2] = T_CREATE_T_C;
+		data[3] = 1;
+		data[4] = getSlotID() + 1 	/*conid*/;
+
+#ifdef x_debug	
+		eDebugNoNewLine("write (%d): > ", getSlotID());
+		for(int i=0; i< 5; i++)
+			eDebugNoNewLine("%02x ",data[i]);
+#endif
+
+		send(data, 5);
+		run();
+	}
+	else
+	{
+		eDebug("cam not present\n");
+		state = stateRemoved;
+	}
+#else
 	ioctl(fd, 0);
+#endif
 
 	return 0;
 }
 
+#ifdef __sh__
+/* ********************** end of __sh__ ************************* */
+#endif
+
 int eDVBCISlot::startMMI()
 {
 	eDebug("CI Slot %d: startMMI()", getSlotID());
diff -Nur enigma2-nightly/lib/dvb_ci/dvbci_datetimemgr.cpp enigma2-nightly.spark/lib/dvb_ci/dvbci_datetimemgr.cpp
--- enigma2-nightly/lib/dvb_ci/dvbci_datetimemgr.cpp	2010-08-11 18:16:49.594872397 +0800
+++ enigma2-nightly.spark/lib/dvb_ci/dvbci_datetimemgr.cpp	2010-08-11 18:12:24.801464068 +0800
@@ -5,6 +5,9 @@
 
 int eDVBCIDateTimeSession::receivedAPDU(const unsigned char *tag,const void *data, int len)
 {
+#ifdef __sh__
+	eDebug("eDVBCIDateTimeSession::%s >", __func__);
+#endif
 	eDebugNoNewLine("SESSION(%d)/DATETIME %02x %02x %02x: ", session_nb, tag[0],tag[1], tag[2]);
 	for (int i=0; i<len; i++)
 		eDebugNoNewLine("%02x ", ((const unsigned char*)data)[i]);
@@ -16,6 +19,9 @@
 		{
 		case 0x40:
 			state=stateSendDateTime;
+#ifdef __sh__
+			eDebug("%s <", __func__);
+#endif
 			return 1;
 			break;
 		default:
@@ -23,25 +29,43 @@
 			break;
 		}
 	}
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 	return 0;
 }
 
 int eDVBCIDateTimeSession::doAction()
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	switch (state)
 	{
 	case stateStarted:
+#ifdef __sh__
+		eDebug("%s <", __func__);
+#endif
 		return 0;
 	case stateSendDateTime:
 	{
 		unsigned char tag[3]={0x9f, 0x84, 0x41}; // date_time_response
 		unsigned char msg[7]={0, 0, 0, 0, 0, 0, 0};
 		sendAPDU(tag, msg, 7);
+#ifdef __sh__
+		eDebug("%s <", __func__);
+#endif
 		return 0;
 	}
 	case stateFinal:
 		eDebug("stateFinal und action! kann doch garnicht sein ;)");
 	default:
+#ifdef __sh__
+		eDebug("%s <", __func__);
+#endif
 		return 0;
 	}
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
diff -Nur enigma2-nightly/lib/dvb_ci/dvbci.h enigma2-nightly.spark/lib/dvb_ci/dvbci.h
--- enigma2-nightly/lib/dvb_ci/dvbci.h	2010-08-11 18:16:49.593768249 +0800
+++ enigma2-nightly.spark/lib/dvb_ci/dvbci.h	2010-08-11 18:12:24.801464068 +0800
@@ -5,6 +5,9 @@
 
 #include <lib/base/ebase.h>
 #include <lib/service/iservice.h>
+#ifdef __sh__
+#include <lib/base/thread.h>
+#endif
 #include <lib/python/python.h>
 #include <set>
 #include <queue>
@@ -43,7 +46,11 @@
 typedef std::set<uint16_t> caidSet;
 typedef std::set<eServiceReference> serviceSet;
 
+#ifdef __sh__
+class eDVBCISlot: public iObject, public Object, public eThread
+#else
 class eDVBCISlot: public iObject, public Object
+#endif
 {
 	friend class eDVBCIInterfaces;
 	DECLARE_REF(eDVBCISlot);
@@ -66,6 +73,17 @@
 	bool user_mapped;
 	void data(int);
 	bool plugged;
+#ifdef __sh__
+	//dagobert
+	char 		connection_id;
+	bool 		pollConnection;
+	struct timeval 	last_poll;
+	int 		pollTime;
+	bool		mmi_active;	
+
+	int		received_len;
+	__u8* 		received_data;
+#endif
 public:
 	enum {stateRemoved, stateInserted, stateInvalid, stateResetted};
 	eDVBCISlot(eMainloop *context, int nr);
@@ -95,6 +113,24 @@
 	int getNumOfServices() { return running_services.size(); }
 	int setSource(data_source source);
 	int setClockRate(int);
+#ifdef __sh__
+	//Dagobert
+	void setPoll(bool poll) { pollConnection = poll; }
+	bool getPoll() { return pollConnection; }
+
+	void setPollTime(struct timeval t) { last_poll = t; }
+	struct timeval getPollTime() { return last_poll; }
+
+	void setModulePollTime(int t) { pollTime = t; }
+	int getModulePollTime() { return pollTime; }
+	bool checkQueueSize();
+
+	void thread();  // thread function
+	void mmiOpened() { mmi_active = true; };
+	void mmiClosed() { mmi_active = false; };
+
+	void process_tpdu(char tpdu_tag, __u8* data, int asn_data_length, int con_id);
+#endif	
 };
 
 struct CIPmtHandler
diff -Nur enigma2-nightly/lib/dvb_ci/dvbci_mmi.cpp enigma2-nightly.spark/lib/dvb_ci/dvbci_mmi.cpp
--- enigma2-nightly/lib/dvb_ci/dvbci_mmi.cpp	2010-08-11 18:16:49.594872397 +0800
+++ enigma2-nightly.spark/lib/dvb_ci/dvbci_mmi.cpp	2010-08-11 18:12:24.802899402 +0800
@@ -19,18 +19,34 @@
 
 eDVBCIMMISession::eDVBCIMMISession(eDVBCISlot *tslot)
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	slot = tslot;
 	slot->setMMIManager(this);
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 eDVBCIMMISession::~eDVBCIMMISession()
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+	slot->mmiClosed();
+#endif	
 	slot->setMMIManager(NULL);
 	eDVBCI_UI::getInstance()->mmiSessionDestroyed(slot->getSlotID());
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 int eDVBCIMMISession::receivedAPDU(const unsigned char *tag, const void *data, int len)
 {
+#ifdef __sh__
+	eDebug("eDVBCIMMISession::%s >", __func__);
+#endif
 	eDebugNoNewLine("SESSION(%d)/MMI %02x %02x %02x: ", session_nb, tag[0], tag[1],tag[2]);
 	for (int i=0; i<len; i++)
 		eDebugNoNewLine("%02x ", ((const unsigned char*)data)[i]);
@@ -40,14 +56,23 @@
 		if (eDVBCI_UI::getInstance()->processMMIData(slot->getSlotID(), tag, data, len) == 1)
 		{
 			state=stateDisplayReply;
+#ifdef __sh__
+			eDebug("%s <", __func__);
+#endif
 			return 1;
 		}
 
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 	return 0;
 }
 
 int eDVBCIMMISession::doAction()
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	switch (state)
 	{
 	case stateStarted:
@@ -76,6 +101,9 @@
 	default:
 		break;
 	}
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 	return 0;
 }
 
@@ -87,6 +115,9 @@
 	unsigned char data[]={0x00};
 	sendAPDU(tag, data, 1);
 	
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 	return 0;
 }
 
@@ -99,6 +130,9 @@
 	data[0] = answer & 0xff;
 	sendAPDU(tag, data, 1);
 	
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 	return 0;
 }
 
@@ -114,6 +148,9 @@
 	unsigned char tag[]={0x9f, 0x88, 0x08};
 	sendAPDU(tag, data, len+1);
 
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 	return 0;
 }
 
@@ -125,6 +162,9 @@
 	unsigned char data[]={0x00}; // canceled
 	sendAPDU(tag, data, 1);
 	
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 	return 0;
 }
 
diff -Nur enigma2-nightly/lib/dvb_ci/dvbci_resmgr.cpp enigma2-nightly.spark/lib/dvb_ci/dvbci_resmgr.cpp
--- enigma2-nightly/lib/dvb_ci/dvbci_resmgr.cpp	2010-08-11 18:16:49.595735374 +0800
+++ enigma2-nightly.spark/lib/dvb_ci/dvbci_resmgr.cpp	2010-08-11 18:12:24.804633940 +0800
@@ -5,7 +5,12 @@
 
 int eDVBCIResourceManagerSession::receivedAPDU(const unsigned char *tag,const void *data, int len)
 {
+#ifdef __sh__
+	eDebug("eDVBCIResourceManagerSession::%s >", __func__);
+	eDebugNoNewLine("SESSION(%d) %02x %02x %02x (len = %d): ", session_nb, tag[0], tag[1], tag[2], len);
+#else
 	eDebugNoNewLine("SESSION(%d) %02x %02x %02x: ", session_nb, tag[0], tag[1], tag[2]);
+#endif
 	for (int i=0; i<len; i++)
 		eDebugNoNewLine("%02x ", ((const unsigned char*)data)[i]);
 	eDebug("");
@@ -16,6 +21,9 @@
 		case 0x10:  // profile enquiry
 			eDebug("cam fragt was ich kann.");
 			state=stateProfileEnquiry;
+#ifdef __sh__
+			eDebug("%s <", __func__);
+#endif
 			return 1;
 			break;
 		case 0x11: // Tprofile
@@ -28,6 +36,9 @@
 
 			if (state == stateFirstProfileEnquiry)
 			{
+#ifdef __sh__
+				eDebug("%s <", __func__);
+#endif
 				// profile change
 				return 1;
 			}
@@ -38,11 +49,17 @@
 		}
 	}
 	
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 	return 0;
 }
 
 int eDVBCIResourceManagerSession::doAction()
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	switch (state)
 	{
 	case stateStarted:
@@ -50,6 +67,9 @@
 		const unsigned char tag[3]={0x9F, 0x80, 0x10}; // profile enquiry
 		sendAPDU(tag);
 		state = stateFirstProfileEnquiry;
+#ifdef __sh__
+		eDebug("%s <", __func__);
+#endif
 		return 0;
 	}
 	case stateFirstProfileEnquiry:
@@ -57,6 +77,9 @@
 		const unsigned char tag[3]={0x9F, 0x80, 0x12}; // profile change
 		sendAPDU(tag);
 		state=stateProfileChange;
+#ifdef __sh__
+		eDebug("%s <", __func__);
+#endif
 		return 0;
 	}
 	case stateProfileChange:
@@ -86,5 +109,8 @@
 	default:
 		break;
 	}
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 	return 0;
 }
diff -Nur enigma2-nightly/lib/dvb_ci/dvbci_session.cpp enigma2-nightly.spark/lib/dvb_ci/dvbci_session.cpp
--- enigma2-nightly/lib/dvb_ci/dvbci_session.cpp	2010-08-11 18:16:49.595735374 +0800
+++ enigma2-nightly.spark/lib/dvb_ci/dvbci_session.cpp	2010-08-11 18:12:24.805920900 +0800
@@ -14,6 +14,9 @@
 
 int eDVBCISession::buildLengthField(unsigned char *pkt, int len)
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	if (len < 127)
 	{
 		*pkt++=len;
@@ -34,14 +37,23 @@
 		eDebug("too big length");
 		exit(0);
 	}
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 int eDVBCISession::parseLengthField(const unsigned char *pkt, int &len)
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	len=0;
 	if (!(*pkt&0x80)) 
 	{
 		len = *pkt;
+#ifdef __sh__
+		eDebug("%s <", __func__);
+#endif
 		return 1;
 	}
 	for (int i=0; i<(pkt[0]&0x7F); ++i)
@@ -49,6 +61,9 @@
 		len <<= 8;
 		len |= pkt[i + 1];
 	}
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 	return (pkt[0] & 0x7F) + 1;
 }
 
@@ -56,22 +71,37 @@
 {
 	unsigned char pkt[len+3+4];
 	int l;
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	memcpy(pkt, tag, 3);
 	l=buildLengthField(pkt+3, len);
 	if (data)
 		memcpy(pkt+3+l, data, len);
 	sendSPDU(0x90, 0, 0, pkt, len+3+l);
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 void eDVBCISession::sendSPDU(unsigned char tag, const void *data, int len, const void *apdu, int alen)
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	sendSPDU(slot, tag, data, len, session_nb, apdu, alen);
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 void eDVBCISession::sendSPDU(eDVBCISlot *slot, unsigned char tag, const void *data, int len, unsigned short session_nb, const void *apdu,int alen)
 {
 	unsigned char pkt[4096];
 	unsigned char *ptr=pkt;
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	*ptr++=tag;
 	ptr+=buildLengthField(ptr, len+2);
 	if (data)
@@ -85,6 +115,9 @@
 
 	ptr+=alen;
 	slot->send(pkt, ptr - pkt);
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 void eDVBCISession::sendOpenSessionResponse(eDVBCISlot *slot, unsigned char session_status, const unsigned char *resource_identifier, unsigned short session_nb)
@@ -94,32 +127,53 @@
 	eDebug("sendOpenSessionResponse");
 	memcpy(pkt + 1, resource_identifier, 4);
 	sendSPDU(slot, 0x92, pkt, 5, session_nb);
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 void eDVBCISession::recvCreateSessionResponse(const unsigned char *data)
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	status = data[0];
 	state = stateStarted;
 	action = 1;
 	eDebug("create Session Response, status %x", status);
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 void eDVBCISession::recvCloseSessionRequest(const unsigned char *data)
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	state = stateInDeletion;
 	action = 1;
 	eDebug("close Session Request");
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 void eDVBCISession::deleteSessions(const eDVBCISlot *slot)
 {
 	ePtr<eDVBCISession> ptr;
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	for (unsigned short session_nb=0; session_nb < SLMS; ++session_nb)
 	{
 		ptr = sessions[session_nb];
 		if (ptr && ptr->slot == slot)
 			sessions[session_nb]=0;
 	}
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 void eDVBCISession::createSession(eDVBCISlot *slot, const unsigned char *resource_identifier, unsigned char &status, ePtr<eDVBCISession> &session)
@@ -127,12 +181,21 @@
 	unsigned long tag;
 	unsigned short session_nb;
 
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	for (session_nb=1; session_nb < SLMS; ++session_nb)
 		if (!sessions[session_nb-1])
 			break;
+#ifdef __sh__		
+	eDebug("use session_nb = %d\n", session_nb);
+#endif		
 	if (session_nb == SLMS)
 	{
 		status=0xF3;
+#ifdef __sh__
+	        eDebug("%s <", __func__);
+#endif
 		return;
 	}
 
@@ -190,16 +253,28 @@
 		status = 0;
 	}
 	session->state = stateInCreation;
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 void eDVBCISession::handleClose()
 {
 	unsigned char data[1]={0x00};
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	sendSPDU(0x96, data, 1, 0, 0);
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 int eDVBCISession::pollAll()
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	for (int session_nb=1; session_nb < SLMS; ++session_nb)
 		if (sessions[session_nb-1])
 		{
@@ -214,8 +289,18 @@
 				r=sessions[session_nb-1]->poll();
 
 			if (r)
+#ifdef __sh__
+			{
+				eDebug("%s <", __func__);
+#endif
 				return 1;
+#ifdef __sh__
+			}
+#endif
 		}
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 	return 0;
 }
 
@@ -224,6 +309,9 @@
 	const unsigned char *pkt = (const unsigned char*)ptr;
 	unsigned char tag = *pkt++;
 	int llen, hlen;
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 
 	eDebug("slot: %p",slot);
 
@@ -251,12 +339,22 @@
 	else
 	{
 		unsigned session_nb;
+#ifdef __sh__
+		eDebug("hlen = %d, %d, %d\n", hlen,  pkt[hlen-2], pkt[hlen-1]);
+#endif
 		session_nb=pkt[hlen-2]<<8;
 		session_nb|=pkt[hlen-1]&0xFF;
 		
 		if ((!session_nb) || (session_nb >= SLMS))
 		{
 			eDebug("PROTOCOL: illegal session number %x", session_nb);
+#ifdef __sh__
+			//Dagobert during start-up we seems to have some problems
+			//on some modules which "looses" the connection. So reset
+			//it
+			deleteSessions(slot);
+			slot->reset();
+#endif
 			return;
 		}
 		
@@ -290,6 +388,10 @@
 	len -= hlen;
 
 	if (session)
+#ifdef __sh__
+	{
+		eDebug("len %d\n", len);
+#endif
 		while (len > 0)
 		{
 			int alen;
@@ -299,6 +401,9 @@
 			hlen=parseLengthField(pkt, alen);
 			pkt+=hlen;
 			len-=hlen;
+#ifdef __sh__
+			eDebug("len = %d, hlen = %d, alen = %d\n", len, hlen, alen);
+#endif
 
 			//if (eDVBCIModule::getInstance()->workarounds_active & eDVBCIModule::workaroundMagicAPDULength)
 			{
@@ -308,14 +413,23 @@
 					alen=len;
 				}
 			}
+#ifdef __sh__
+			eDebug("1. Call receivedAPDU tag = 0x%2x, len = %d\n", tag, alen);
+#endif
 			if (session->receivedAPDU(tag, pkt, alen))
 				session->action = 1;
 			pkt+=alen;
 			len-=alen;
 		}
 		
+#ifdef __sh__
+	}
+#endif
 	if (len)
 		eDebug("PROTOCOL: warning, TL-Data has invalid length");
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 eDVBCISession::~eDVBCISession()
diff -Nur enigma2-nightly/lib/dvb_ci/dvbci_ui.cpp enigma2-nightly.spark/lib/dvb_ci/dvbci_ui.cpp
--- enigma2-nightly/lib/dvb_ci/dvbci_ui.cpp	2010-08-11 18:16:49.595735374 +0800
+++ enigma2-nightly.spark/lib/dvb_ci/dvbci_ui.cpp	2010-08-11 18:12:24.806510403 +0800
@@ -17,8 +17,14 @@
 eDVBCI_UI::eDVBCI_UI()
 	:eMMI_UI(MAX_SLOTS)
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	ASSERT(!instance);
 	instance = this;
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 eDVBCI_UI *eDVBCI_UI::getInstance()
@@ -28,51 +34,96 @@
 
 void eDVBCI_UI::setInit(int slot)
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	eDVBCIInterfaces::getInstance()->initialize(slot);
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 void eDVBCI_UI::setReset(int slot)
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	eDVBCIInterfaces::getInstance()->reset(slot);
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 int eDVBCI_UI::startMMI(int slot)
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	eDVBCIInterfaces::getInstance()->startMMI(slot);
 	return 0;
 }
 
 int eDVBCI_UI::stopMMI(int slot)
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	eDVBCIInterfaces::getInstance()->stopMMI(slot);
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 	return 0;
 }
 
 int eDVBCI_UI::answerMenu(int slot, int answer)
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	eDVBCIInterfaces::getInstance()->answerText(slot, answer);
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 	return 0;
 }
 
 int eDVBCI_UI::answerEnq(int slot, char *value)
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	eDVBCIInterfaces::getInstance()->answerEnq(slot, value);
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 	return 0;
 }
 
 int eDVBCI_UI::cancelEnq(int slot)
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	eDVBCIInterfaces::getInstance()->cancelEnq(slot);
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 	return 0;
 }
 
 int eDVBCI_UI::getMMIState(int slot)
 {
+#ifdef __sh__
+	eDebug("%s ><", __func__);
+#endif
 	return eDVBCIInterfaces::getInstance()->getMMIState(slot);
 }
 
 int eDVBCI_UI::setClockRate(int slot, int rate)
 {
+#ifdef __sh__
+	eDebug("%s ><", __func__);
+#endif
 	return eDVBCIInterfaces::getInstance()->setCIClockRate(slot, rate);
 }
 
diff -Nur enigma2-nightly/lib/gdi/accel.cpp enigma2-nightly.spark/lib/gdi/accel.cpp
--- enigma2-nightly/lib/gdi/accel.cpp	2010-08-11 18:16:49.596830746 +0800
+++ enigma2-nightly.spark/lib/gdi/accel.cpp	2010-08-11 18:12:24.807824847 +0800
@@ -9,8 +9,25 @@
 #include <lib/gdi/gpixmap.h>
 
 gAccel *gAccel::instance;
+#if not defined(__sh__) 
 #define BCM_ACCEL
+#else
+#define STMFB_ACCEL
+#endif
 
+#ifdef STMFB_ACCEL
+extern int stmfb_accel_init(void);
+extern void stmfb_accel_close(void);
+extern void stmfb_accel_blit(
+		int src_addr, int src_width, int src_height, int src_stride, int src_format,
+		int dst_addr, int dst_width, int dst_height, int dst_stride,
+		int src_x, int src_y, int width, int height,
+		int dst_x, int dst_y, int dwidth, int dheight);
+extern void stmfb_accel_fill(
+		int dst_addr, int dst_width, int dst_height, int dst_stride,
+		int x, int y, int width, int height,
+		unsigned long color);
+#endif
 #ifdef ATI_ACCEL
 extern int ati_accel_init(void);
 extern void ati_accel_close(void);
@@ -47,6 +64,9 @@
 	m_accel_allocation = 0;
 	instance = this;
 
+#ifdef STMFB_ACCEL	
+	stmfb_accel_init();
+#endif
 #ifdef ATI_ACCEL	
 	ati_accel_init();
 #endif
@@ -57,6 +77,9 @@
 
 gAccel::~gAccel()
 {
+#ifdef STMFB_ACCEL	
+	stmfb_accel_close();
+#endif
 #ifdef ATI_ACCEL
 	ati_accel_close();
 #endif
@@ -87,6 +110,77 @@
 
 int gAccel::blit(gSurface *dst, const gSurface *src, const eRect &p, const eRect &area, int flags)
 {
+#ifdef STMFB_ACCEL
+	//eDebug( "src: %4d %4d %4d %4d\tdst: %4d %4d %4d %4d\n"
+	//		"area: %4d %4d %4d %4d\tp: %4d %4d %4d %4d\n",
+	//		src->data_phys, src->x, src->y, src->stride,
+	//		dst->data_phys, dst->x, dst->y, dst->stride, 
+	//		area.left(), area.top(), area.width(), area.height(),
+	//		p.x(), p.y(), p.width(), p.height());
+
+	int src_format = 0;
+	void *data = 0;
+     	int data_phys = 0;
+
+	if (src->bpp == 32)
+		src_format = 0;
+	else if ((src->bpp == 8) && (dst->bpp == 32))
+	{
+		src_format = 1;
+        	if(accelAlloc(data, data_phys, area.height() * area.width() * 4))
+			return -1;
+
+		__u8 *srcptr=(__u8*)src->data;
+		__u8 *dstptr=(__u8*)data;
+		__u32 pal[256];
+
+		for (int i=0; i<256; ++i)
+		{
+			if (src->clut.data && (i<src->clut.colors))
+				pal[i]=(src->clut.data[i].a<<24)|(src->clut.data[i].r<<16)|(src->clut.data[i].g<<8)|(src->clut.data[i].b);
+			else
+				pal[i]=0x010101*i;
+			if((pal[i]&0xFF000000) >= 0xE0000000)
+				pal[i] = 0xFF000000;
+			pal[i]^=0xFF000000;
+		}
+		srcptr+=area.left()*src->bypp+area.top()*src->stride;
+
+		for (int y=0; y<area.height(); y++)
+		{
+			int width=area.width();
+			unsigned char *psrc=(unsigned char*)srcptr;
+			__u32 *pdst=(__u32*)dstptr;
+
+			while (width--)
+				*pdst++=pal[*psrc++];
+
+			srcptr+=src->stride;
+			dstptr+=area.width() * 4;
+		}
+	} else {
+		if(data_phys)
+			accelFree(data_phys);
+		return -1;
+	}
+
+	if(data_phys)
+	{
+		stmfb_accel_blit(
+			data_phys, 0, 0, area.width() * 4, src_format,
+			dst->data_phys, dst->x, dst->y, dst->stride,
+			0, 0, area.width(), area.height(),
+			p.x(), p.y(), p.width(), p.height());
+		accelFree(data_phys);
+	} else {
+		stmfb_accel_blit(
+			src->data_phys, src->x, src->y, src->stride, src_format,
+			dst->data_phys, dst->x, dst->y, dst->stride,
+			area.left(), area.top(), area.width(), area.height(),
+			p.x(), p.y(), p.width(), p.height());
+	}
+	return 0;
+#endif
 #ifdef ATI_ACCEL
 	ati_accel_blit(
 		src->data_phys, src->x, src->y, src->stride,
diff -Nur enigma2-nightly/lib/gdi/fb.cpp enigma2-nightly.spark/lib/gdi/fb.cpp
--- enigma2-nightly/lib/gdi/fb.cpp	2010-08-11 18:16:49.598896560 +0800
+++ enigma2-nightly.spark/lib/gdi/fb.cpp	2010-08-11 18:12:24.807824847 +0800
@@ -70,6 +70,15 @@
 		perror("mmap");
 		goto nolfb;
 	}
+#if defined(__sh__) 
+	//we use 2MB at the end of the buffer, the rest does the blitter 
+	lfb_direct = lfb;     
+	lfb += 1920*1080*4;     
+	topDiff = 0;
+	leftDiff = 0;
+	rightDiff = 0;
+	bottomDiff = 0;
+#endif 
 
 	showConsole(0);
 
@@ -83,6 +92,9 @@
 
 int fbClass::showConsole(int state)
 {
+#if defined(__sh__) 
+	int fd=open("/dev/ttyAS1", O_RDWR); 
+#else 
 	int fd=open("/dev/vc/0", O_RDWR);
 	if(fd>=0)
 	{
@@ -92,13 +104,18 @@
 		}
 		close(fd);
 	}
+#endif
 	return 0;
 }
 
 int fbClass::SetMode(unsigned int nxRes, unsigned int nyRes, unsigned int nbpp)
 {
 	screeninfo.xres_virtual=screeninfo.xres=nxRes;
+#if defined(__sh__) 
+	screeninfo.yres_virtual=screeninfo.yres=nyRes; 
+#else 
 	screeninfo.yres_virtual=(screeninfo.yres=nyRes)*2;
+#endif
 	screeninfo.height=0;
 	screeninfo.width=0;
 	screeninfo.xoffset=screeninfo.yoffset=0;
@@ -129,6 +146,7 @@
 		break;
 	}
 
+#if not defined(__sh__) 
 	if (ioctl(fd, FBIOPUT_VSCREENINFO, &screeninfo)<0)
 	{
 		// try single buffering
@@ -143,6 +161,7 @@
 		eDebug(" - double buffering not available.");
 	} else
 		eDebug(" - double buffering available!");
+#endif
 	
 	m_number_of_pages = screeninfo.yres_virtual / nyRes;
 	
@@ -154,6 +173,10 @@
 			nxRes, nyRes, nbpp,
 			screeninfo.xres, screeninfo.yres, screeninfo.bits_per_pixel);
 	}
+#if defined(__sh__) 
+	xResFB=nxRes; 
+	yResFB=nyRes; 
+#endif 
 	xRes=screeninfo.xres;
 	yRes=screeninfo.yres;
 	bpp=screeninfo.bits_per_pixel;
@@ -164,7 +187,9 @@
 		printf("fb failed\n");
 	}
 	stride=fix.line_length;
+#if not defined(__sh__) 
 	memset(lfb, 0, stride*yRes);
+#endif
 	return 0;
 }
 
@@ -183,10 +208,32 @@
 
 void fbClass::blit()
 {
+#if defined(__sh__) 
+	STMFBIO_BLT_DATA  bltData; 
+	memset(&bltData, 0, sizeof(STMFBIO_BLT_DATA)); 
+	bltData.operation  = BLT_OP_COPY; 
+	bltData.srcOffset  = 1920*1080*4; 
+	bltData.srcPitch   = xResFB * 4; 
+	bltData.dstOffset  = 0; 
+	bltData.dstPitch   = xRes*4; 
+	bltData.src_top    = 0; bltData.src_left   = 0; 
+	bltData.src_right  = xResFB; bltData.src_bottom = yResFB; 
+	bltData.srcFormat = SURF_BGRA8888; bltData.dstFormat = SURF_BGRA8888;
+	bltData.srcMemBase = STMFBGP_FRAMEBUFFER; bltData.dstMemBase = STMFBGP_FRAMEBUFFER; 
+	bltData.dst_top    = 0 + topDiff; 
+	bltData.dst_left   = 0 + leftDiff; 
+	bltData.dst_right  = xRes + rightDiff; 
+	bltData.dst_bottom = yRes + bottomDiff; 
+	if (ioctl(fd, STMFBIO_BLT, &bltData ) < 0) 
+	{ 
+		perror("FBIO_BLIT"); 
+	} 
+#else 
 	if (m_manual_blit == 1) {
 		if (ioctl(fd, FBIO_BLIT) < 0)
 			perror("FBIO_BLIT");
 	}
+#endif
 }
 
 fbClass::~fbClass()
@@ -231,19 +278,62 @@
 
 void fbClass::enableManualBlit()
 {
+#if not defined(__sh__) 
 	unsigned char tmp = 1;
 	if (ioctl(fd,FBIO_SET_MANUAL_BLIT, &tmp)<0)
 		perror("FBIO_SET_MANUAL_BLIT");
 	else
 		m_manual_blit = 1;
+#endif
 }
 
 void fbClass::disableManualBlit()
 {
+#if not defined(__sh__) 
 	unsigned char tmp = 0;
 	if (ioctl(fd,FBIO_SET_MANUAL_BLIT, &tmp)<0) 
 		perror("FBIO_SET_MANUAL_BLIT");
 	else
 		m_manual_blit = 0;
+#endif
 }
 
+#if defined(__sh__) 
+void fbClass::clearFBblit()
+{
+	//set real frambuffer transparent
+	memset(lfb_direct, 0x00, xRes * yRes * 4);
+	blit();
+}
+
+int fbClass::getFBdiff(int ret)
+{
+	if(ret == 0)
+		return topDiff;
+	else if(ret == 1)
+		return leftDiff;
+	else if(ret == 2)
+		return rightDiff;
+	else if(ret == 3)
+		return bottomDiff;
+	else
+		return -1;
+
+}
+
+void fbClass::setFBdiff(int top, int left, int right, int bottom)
+{
+	if(top < 0) top = 0;
+	if(top > yRes) top = yRes;
+	topDiff = top;
+	if(left < 0) left = 0;
+	if(left > xRes) left = xRes;
+	leftDiff = left;
+	if(right > 0) right = 0;
+	if(-right > xRes) right = -xRes;
+	rightDiff = right;
+	if(bottom > 0) bottom = 0;
+	if(-bottom > yRes) bottom = -yRes;
+	bottomDiff = bottom;
+}
+#endif
diff -Nur enigma2-nightly/lib/gdi/fb.h enigma2-nightly.spark/lib/gdi/fb.h
--- enigma2-nightly/lib/gdi/fb.h	2010-08-11 18:16:49.598896560 +0800
+++ enigma2-nightly.spark/lib/gdi/fb.h	2010-08-11 18:12:24.808982415 +0800
@@ -4,10 +4,18 @@
 #include <lib/base/eerror.h>
 #include <linux/fb.h>
 
+#if defined(__sh__) 
+	#include <linux/stmfb.h> 
+#endif
 class fbClass
 {
 	int fd;
 	unsigned int xRes, yRes, stride, bpp;
+#if defined(__sh__) 
+	unsigned int xResFB, yResFB; 
+	int topDiff, leftDiff, rightDiff, bottomDiff; 
+	unsigned char *lfb_direct;
+#endif
 	int available;
 	struct fb_var_screeninfo screeninfo, oldscreen;
 	fb_cmap cmap;
@@ -19,7 +27,11 @@
 	int m_number_of_pages;
 	int m_phys_mem;
 #ifdef SWIG
+#if defined(__sh__) 
+	fbClass(const char *fb="/dev/fb0"); 
+#else 
 	fbClass(const char *fb="/dev/fb/0");
+#endif
 	~fbClass();
 public:
 #else
@@ -41,7 +53,11 @@
 	unsigned int Stride() { return stride; }
 	fb_cmap *CMAP() { return &cmap; }
 
+#if defined(__sh__) 
+	fbClass(const char *fb="/dev/fb0"); 
+#else 
 	fbClass(const char *fb="/dev/fb/0");
+#endif
 	~fbClass();
 	
 			// low level gfx stuff
@@ -52,6 +68,11 @@
 	int lock();
 	void unlock();
 	int islocked() { return locked; }
+#if defined(__sh__) 
+	void clearFBblit();
+	int getFBdiff(int ret);
+	void setFBdiff(int top, int right, int left, int bottom);
+#endif
 };
 
 #endif
diff -Nur enigma2-nightly/lib/gdi/gfbdc.cpp enigma2-nightly.spark/lib/gdi/gfbdc.cpp
--- enigma2-nightly/lib/gdi/gfbdc.cpp	2010-08-11 18:16:49.600757909 +0800
+++ enigma2-nightly.spark/lib/gdi/gfbdc.cpp	2010-08-11 18:12:24.809671139 +0800
@@ -170,13 +170,37 @@
 
 void gFBDC::setResolution(int xres, int yres)
 {
+#if defined(__sh__) 
+	/* if xres and yres are negative call SetMode with the lates xres and yres  
+	 * we need that to read the new screen dimesnions after a resolution change 
+	 * without changing the frambuffer dimensions
+	 */ 
+	if(xres<0 && yres<0 ){ 
+		fb->SetMode(m_xres, m_yres, 32); 
+		return; 
+	} 
+#else 
 	if ((m_xres == xres) && (m_yres == yres))
 		return;
+#endif
 
 	m_xres = xres; m_yres = yres;
 
 	fb->SetMode(m_xres, m_yres, 32);
 
+#if defined(__sh__) 
+	surface.type = 0; 
+	surface.x = m_xres; 
+	surface.y = m_yres; 
+	surface.bpp = 32; 
+	surface.bypp = 4; 
+	surface.stride = m_xres * 4; 
+	surface.data = fb->lfb; 
+	surface.offset = 0;
+
+	for (int y=0; y<m_yres; y++)    // make whole screen transparent 
+		memset(fb->lfb+ y * m_xres * 4, 0x00, m_xres * 4);
+#else 
 	for (int y=0; y<m_yres; y++)	// make whole screen transparent
 		memset(fb->lfb+y*fb->Stride(), 0x00, fb->Stride());
 
@@ -188,6 +212,7 @@
 	surface.stride = fb->Stride();
 	surface.data = fb->lfb;
 	surface.offset = 0;
+#endif
 
 	surface.data_phys = fb->getPhysAddr();
 
@@ -210,12 +235,19 @@
 	} else
 		m_enable_double_buffering = 0;
 
+#ifdef __sh__
+	eDebug("%dkB available for acceleration surfaces.", (fb->Available() - fb_size - (1920*1080*4))/1024);
+	eDebug("resolution: %d x %d x %d (stride: %d)", surface.x, surface.y, surface.bpp, fb->Stride());
+
+	if (gAccel::getInstance())
+		gAccel::getInstance()->setAccelMemorySpace(fb->lfb + fb_size, surface.data_phys + fb_size, fb->Available() - fb_size - (1920*1080*4));
+#else
 	eDebug("%dkB available for acceleration surfaces.", (fb->Available() - fb_size)/1024);
 	eDebug("resolution: %d x %d x %d (stride: %d)", surface.x, surface.y, surface.bpp, fb->Stride());
 
 	if (gAccel::getInstance())
 		gAccel::getInstance()->setAccelMemorySpace(fb->lfb + fb_size, surface.data_phys + fb_size, fb->Available() - fb_size);
-
+#endif
 	if (!surface.clut.data)
 	{
 		surface.clut.colors = 256;
diff -Nur enigma2-nightly/lib/gdi/gpixmap.cpp enigma2-nightly.spark/lib/gdi/gpixmap.cpp
--- enigma2-nightly/lib/gdi/gpixmap.cpp	2010-08-11 18:16:49.601756893 +0800
+++ enigma2-nightly.spark/lib/gdi/gpixmap.cpp	2010-08-11 18:12:24.867013398 +0800
@@ -163,6 +163,10 @@
 			else
 				col=0x10101*color;
 			
+#if defined(__sh__) 
+if((col&0xFF000000) == 0xFF000000)
+col = 0xFF000000;
+#endif
 			col^=0xFF000000;
 			
 			if (surface->data_phys && gAccel::getInstance())
@@ -195,6 +199,10 @@
 			__u32 col;
 
 			col = color.argb();
+#if defined(__sh__) 
+if((col&0xFF000000) == 0xFF000000)
+col = 0xFF000000;
+#endif
 			col^=0xFF000000;
 
 			if (surface->data_phys && gAccel::getInstance())
@@ -318,7 +326,10 @@
 		if (flag & blitScale)
 		{
 			eWarning("unimplemented: scale on non-accel surfaces");
+//if accel blit fails, do direkt blit
+#ifndef __sh__
 			continue;
+#endif
 		}
 
 		if ((surface->bpp == 8) && (src.surface->bpp==8))
@@ -422,6 +433,10 @@
 					pal[i]=(src.surface->clut.data[i].a<<24)|(src.surface->clut.data[i].r<<16)|(src.surface->clut.data[i].g<<8)|(src.surface->clut.data[i].b);
 				else
 					pal[i]=0x010101*i;
+#if defined(__sh__) 
+if((pal[i]&0xFF000000) >= 0xE0000000)
+pal[i] = 0xFF000000;
+#endif
 				pal[i]^=0xFF000000;
 			}
 
diff -Nur enigma2-nightly/lib/gdi/grc.cpp enigma2-nightly.spark/lib/gdi/grc.cpp
--- enigma2-nightly/lib/gdi/grc.cpp	2010-08-11 18:16:49.601756893 +0800
+++ enigma2-nightly.spark/lib/gdi/grc.cpp	2010-08-11 18:12:24.875524947 +0800
@@ -4,6 +4,11 @@
 #include <lib/base/init.h>
 #include <lib/base/init_num.h>
 
+#if defined(__sh__)
+#include "include/shmE2.h"
+extern char *shm;
+#endif
+
 #ifndef SYNC_PAINT
 void *gRC::thread_wrapper(void *ptr)
 {
@@ -125,7 +130,12 @@
 				m_compositing->Release();
 			} else if(o.dc)
 			{
+#if defined(__sh__)
+				if(checkshmentry(shm, "stopGUI=") != 1)
+					o.dc->exec(&o);
+#else
 				o.dc->exec(&o);
+#endif
 				// o.dc is a gDC* filled with grabref... so we must release it here
 				o.dc->Release();
 			}
@@ -175,9 +185,19 @@
 
 				if (!idle)
 				{
+#if defined(__sh__)
+					if(checkshmentry(shm, "stopSpinner=") != 1)
+					{
+						if (!m_spinner_enabled)
+							eDebug("main thread is non-idle! display spinner!");
+						enableSpinner();
+					} else
+						disableSpinner();
+#else
 					if (!m_spinner_enabled)
 						eDebug("main thread is non-idle! display spinner!");
 					enableSpinner();
+#endif
 				} else
 					disableSpinner();
 			}
diff -Nur enigma2-nightly/lib/gdi/Makefile.am enigma2-nightly.spark/lib/gdi/Makefile.am
--- enigma2-nightly/lib/gdi/Makefile.am	2010-08-11 18:16:49.596830746 +0800
+++ enigma2-nightly.spark/lib/gdi/Makefile.am	2010-08-11 18:12:24.811594345 +0800
@@ -6,7 +6,7 @@
 libenigma_gdi_a_SOURCES = \
 	region.cpp grc.cpp epng.cpp erect.cpp fb.cpp font.cpp font_arabic.cpp gfbdc.cpp  \
 	glcddc.cpp gpixmap.cpp lcd.cpp gfont.cpp accel.cpp picload.cpp picexif.cpp \
-	compositing.cpp bcm.cpp
+	compositing.cpp bcm.cpp stmfb.cpp
 
 if WITH_SDL
 libenigma_gdi_a_SOURCES += sdl.cpp
diff -Nur enigma2-nightly/lib/gdi/stmfb.cpp enigma2-nightly.spark/lib/gdi/stmfb.cpp
--- enigma2-nightly/lib/gdi/stmfb.cpp	1970-01-01 08:00:00.000000000 +0800
+++ enigma2-nightly.spark/lib/gdi/stmfb.cpp	2010-08-11 18:12:24.812511786 +0800
@@ -0,0 +1,75 @@
+/*
+  Interface to the Dreambox dm800/dm8000 proprietary accel interface.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <linux/fb.h>
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+#include <linux/stmfb.h>
+
+
+#include <lib/base/ebase.h>
+
+static int fb_fd;
+static int exec_list(void);
+
+int stmfb_accel_init(void)
+{
+	fb_fd = open("/dev/fb0", O_RDWR);
+	if (fb_fd < 0)
+	{
+		perror("/dev/fb0");
+		return 1;
+	}
+
+	eDebug("STMFB accel interface available\n");
+	return 0;
+}
+
+void stmfb_accel_close(void)
+{
+	close(fb_fd);
+}
+
+void stmfb_accel_blit(
+		int src_addr, int src_width, int src_height, int src_stride, int src_format,
+		int dst_addr, int dst_width, int dst_height, int dst_stride,
+		int src_x, int src_y, int width, int height,
+		int dst_x, int dst_y, int dwidth, int dheight)
+{
+	STMFBIO_BLT_DATA bltData;
+	memset(&bltData, 0, sizeof(STMFBIO_BLT_DATA));
+
+	bltData.operation  = BLT_OP_COPY;
+	bltData.srcOffset  = (src_addr - dst_addr) + (1920*1080*4);
+	bltData.srcPitch   = src_stride;
+	bltData.src_left   = src_x;
+	bltData.src_top    = src_y;
+	bltData.src_right  = src_x + width;
+	bltData.src_bottom = src_y + height;
+
+	bltData.dstOffset  = 1920*1080*4;
+	bltData.dstPitch   = dst_stride;
+	bltData.dst_left   = dst_x;
+	bltData.dst_top    = dst_y;
+	bltData.dst_right  = dst_x + dwidth;
+	bltData.dst_bottom = dst_y + dheight;
+
+	if (ioctl(fb_fd, STMFBIO_BLT, &bltData ) < 0)
+	{
+		eDebug("Error ioctl FBIO_BLIT");
+	}
+}
+
+void stmfb_accel_fill(
+		int dst_addr, int dst_width, int dst_height, int dst_stride,
+		int x, int y, int width, int height,
+		unsigned long color)
+{
+//	printf("unimplemented bcm_accel_fill\n");
+}
+
diff -Nur enigma2-nightly/lib/python/Components/Harddisk.py enigma2-nightly.spark/lib/python/Components/Harddisk.py
--- enigma2-nightly/lib/python/Components/Harddisk.py	2010-08-11 18:16:49.619946692 +0800
+++ enigma2-nightly.spark/lib/python/Components/Harddisk.py	2010-08-11 18:12:24.869485799 +0800
@@ -1,9 +1,26 @@
-from os import system, listdir, statvfs, popen, makedirs, stat, major, minor, path, access
-from Tools.Directories import SCOPE_HDD, resolveFilename
+#--->
+#-from os import system, listdir, statvfs, popen, makedirs, stat, major, minor, path, access
+#-from Tools.Directories import SCOPE_HDD, resolveFilename
+#---<
+#+++>
+from os import system, listdir, statvfs, popen, makedirs, stat, major, minor, path, access, readlink, remove, path as os_path
+from Tools.Directories import SCOPE_HDD, resolveFilename, removeDir
+#+++<
 from Tools.CList import CList
 from SystemInfo import SystemInfo
 import time
 from Components.Console import Console
+#+++>
+from enigma import eConsoleAppContainer, evfd
+import os
+
+def tryOpen(filename):
+	try:
+		procFile = open(filename)
+	except IOError:
+		return ""
+	return procFile
+#+++<
 
 def readFile(filename):
 	file = open(filename)
@@ -18,13 +35,16 @@
 	def __init__(self, device):
 		self.device = device
 
-		if access("/dev/.udev", 0):
-			self.type = self.DEVTYPE_UDEV
-		elif access("/dev/.devfsd", 0):
-			self.type = self.DEVTYPE_DEVFS
-		else:
-			print "Unable to determine structure of /dev"
-
+#--->
+#-		if access("/dev/.udev", 0):
+#-			self.type = self.DEVTYPE_UDEV
+#-		elif access("/dev/.devfsd", 0):
+#-			self.type = self.DEVTYPE_DEVFS
+#-		else:
+#-			print "Unable to determine structure of /dev"
+#+++>
+		self.type = self.DEVTYPE_UDEV
+#+++<
 		self.max_idle_time = 0
 		self.idle_running = False
 		self.timer = None
@@ -32,7 +52,8 @@
 		self.dev_path = ''
 		self.disk_path = ''
 		self.phys_path = path.realpath(self.sysfsPath('device'))
-
+		
+		print "[Harddisk] found: ", self.phys_path
 		if self.type == self.DEVTYPE_UDEV:
 			self.dev_path = '/dev/' + self.device
 			self.disk_path = self.dev_path
@@ -43,7 +64,7 @@
 			s_minor = int(tmp[1])
 			for disc in listdir("/dev/discs"):
 				dev_path = path.realpath('/dev/discs/' + disc)
-				disk_path = dev_path + '/disc'
+ 				disk_path = dev_path + '/disc'
 				try:
 					rdev = stat(disk_path).st_rdev
 				except OSError:
@@ -171,13 +192,22 @@
 		for line in lines:
 			parts = line.strip().split(" ")
 			if path.realpath(parts[0]).startswith(self.dev_path):
-				cmd = ' ' . join([cmd, parts[1]])
-
+#--->			
+#-				cmd = ' ' . join([cmd, parts[1]])
+#---<
+#+++>
+				cmd = ' -fl ' . join([cmd, parts[1]])
+#+++<
 		res = system(cmd)
 		return (res >> 8)
 
 	def createPartition(self):
-		cmd = 'printf "0,\n;\n;\n;\ny\n" | sfdisk -f ' + self.disk_path
+#--->
+#-		cmd = 'printf "0,\n;\n;\n;\ny\n" | sfdisk -f ' + self.disk_path
+#---<
+#+++>
+		cmd = 'echo "0,\n;\n;\n;\ny\n" | sfdisk -f ' + self.disk_path
+#+++<
 		res = system(cmd)
 		return (res >> 8)
 
@@ -185,8 +215,21 @@
 		cmd = "mkfs.ext3 "
 		if self.diskSize() > 4 * 1024:
 			cmd += "-T largefile "
-		cmd += "-m0 -O dir_index " + self.partitionPath("1")
-		res = system(cmd)
+
+		cmd += "-m0 -O dir_index -L RECORD " + self.partitionPath("1")
+		print "cmd", cmd
+#--->
+#-		res = system(cmd)
+#---<
+#+++>
+		print "[Harddisk] mkfs: ", cmd
+		if os.path.exists("/sbin/cmd") is True:
+			self.container = eConsoleAppContainer()
+			self.container.execute("/sbin/cmd " + cmd)
+			res = 0
+		else:	
+			res = system(cmd)
+#+++<
 		return (res >> 8)
 
 	def mount(self):
@@ -202,7 +245,7 @@
 		for line in lines:
 			parts = line.strip().split(" ")
 			if path.realpath(parts[0]) == self.partitionPath("1"):
-				cmd = "mount -t ext3 " + parts[0]
+				cmd = "mount -t ext3 " + parts[0] + " /media/hdd"
 				res = system(cmd)
 				break
 
@@ -219,7 +262,18 @@
 		# We autocorrect any failures
 		# TODO: we could check if the fs is actually ext3
 		cmd = "fsck.ext3 -f -p " + self.partitionPath("1")
-		res = system(cmd)
+#--->
+#-		res = system(cmd)
+#---<
+#+++>		
+		print "[Harddisk] fsck: ", cmd
+		if os.path.exists("/sbin/cmd") is True:
+			self.container = eConsoleAppContainer()
+			self.container.execute("/sbin/cmd " + cmd)
+			res = 0
+		else:	
+			res = system(cmd)
+#+++<
 		return (res >> 8)
 
 	def killPartition(self, n):
@@ -394,28 +448,47 @@
 				return True
 		return False
 
+#--->
+#-DEVICEDB =  \
+#-	{"dm8000":
+#-		{
+#-			# dm8000:
+#-			"/devices/platform/brcm-ehci.0/usb1/1-1/1-1.1/1-1.1:1.0": "Front USB Slot",
+#-			"/devices/platform/brcm-ehci.0/usb1/1-1/1-1.2/1-1.2:1.0": "Back, upper USB Slot",
+#-			"/devices/platform/brcm-ehci.0/usb1/1-1/1-1.3/1-1.3:1.0": "Back, lower USB Slot",
+#-			"/devices/platform/brcm-ehci-1.1/usb2/2-1/2-1:1.0/host1/target1:0:0/1:0:0:0": "DVD Drive",
+#-		},
+#-	"dm800":
+#-	{
+#-		# dm800:
+#-		"/devices/platform/brcm-ehci.0/usb1/1-2/1-2:1.0": "Upper USB Slot",
+#-		"/devices/platform/brcm-ehci.0/usb1/1-1/1-1:1.0": "Lower USB Slot",
+#-	},
+#-	"dm7025":
+#-	{
+#-		# dm7025:
+#-		"/devices/pci0000:00/0000:00:14.1/ide1/1.0": "CF Card Slot", #hdc
+#-		"/devices/pci0000:00/0000:00:14.1/ide0/0.0": "Internal Harddisk"
+#-	}
+#-	}
+#---<
+#+++>
 DEVICEDB =  \
-	{"dm8000":
+	{"ufs910":
 		{
-			# dm8000:
-			"/devices/platform/brcm-ehci.0/usb1/1-1/1-1.1/1-1.1:1.0": "Front USB Slot",
-			"/devices/platform/brcm-ehci.0/usb1/1-1/1-1.2/1-1.2:1.0": "Back, upper USB Slot",
-			"/devices/platform/brcm-ehci.0/usb1/1-1/1-1.3/1-1.3:1.0": "Back, lower USB Slot",
-			"/devices/platform/brcm-ehci-1.1/usb2/2-1/2-1:1.0/host1/target1:0:0/1:0:0:0": "DVD Drive",
+			"/devices/platform/ST40-ehci.2/usb1/1-1/1-1.4/1-1.4:1.0": "Front USB Slot",
+			"/devices/platform/ST40-ehci.2/usb1/1-1/1-1.3/1-1.3:1.0": "Back, upper USB Slot",
+			"/devices/platform/ST40-ehci.2/usb1/1-1/1-1.2/1-1.2:1.0": "Back, lower USB Slot",
 		},
-	"dm800":
-	{
-		# dm800:
-		"/devices/platform/brcm-ehci.0/usb1/1-2/1-2:1.0": "Upper USB Slot",
-		"/devices/platform/brcm-ehci.0/usb1/1-1/1-1:1.0": "Lower USB Slot",
-	},
-	"dm7025":
-	{
-		# dm7025:
-		"/devices/pci0000:00/0000:00:14.1/ide1/1.0": "CF Card Slot", #hdc
-		"/devices/pci0000:00/0000:00:14.1/ide0/0.0": "Internal Harddisk"
-	}
+	"UFS922":
+		{
+			"/devices/platform/ST40-ehci.2/usb1/1-1/1-1.1/1-1.1:1.0/": "Back, upper USB Slot",
+			"/devices/platform/ST40-ehci.2/usb1/1-1/1-1.2/1-1.2:1.0/": "Back, lower USB Slot",
+			"/devices/platform/ST40-ehci.2/usb1/1-1/1-1.3/1-1.3:1.0/": "Front USB Slot",
+		}	
 	}
+#+++<
+
 
 class HarddiskManager:
 	def __init__(self):
@@ -440,6 +513,8 @@
 					("/media/net", _("Network Mount")),
 					("/media/ram", _("Ram Disk")),
 					("/media/usb", _("USB Stick")),
+					("/media/upnp", _("UPNP Stick")),
+					("/media/ftp", _("FTP Stick")),
 					("/", _("Internal Flash"))
 				]
 
@@ -455,7 +530,12 @@
 		try:
 			removable = bool(int(readFile(devpath + "/removable")))
 			dev = int(readFile(devpath + "/dev").split(':')[0])
-			if dev in (7, 31): # loop, mtdblock
+#--->
+#-			if dev in (7, 31): # loop, mtdblock
+#---<
+#+++>
+			if dev in [1, 7, 31, 253]: # ram, loop, mtdblock, ramzswap
+#+++<
 				blacklisted = True
 			if blockdev[0:2] == 'sr':
 				is_cdrom = True
@@ -515,6 +595,13 @@
 			except OSError:
 				physdev = dev
 				print "couldn't determine blockdev physdev for device", device
+#+++>		
+		else:
+			dev, part = self.splitDeviceName(device)
+		if part is not 0:
+			print "[Harddisk] start automount"
+			#Automount(device,"mount")
+#+++<		
 
 		# device is the device name, without /dev
 		# physdev is the physical device path, which we (might) use to determine the userfriendly name
@@ -547,6 +634,12 @@
 					self.hdd.remove(hdd)
 					break
 			SystemInfo["Harddisk"] = len(self.hdd) > 0
+#+++>
+		dev, part = self.splitDeviceName(device)
+		if part is not 0:
+			print "[Harddisk] start auto umount"
+			#Automount(device,"umount")
+#+++<
 
 	def HDDCount(self):
 		return len(self.hdd)
@@ -616,5 +709,5 @@
 			if x.mountpoint == mountpoint:
 				self.partitions.remove(x)
 				self.on_partition_list_change("remove", x)
-
+		
 harddiskmanager = HarddiskManager()
diff -Nur enigma2-nightly/lib/python/Components/NimManager.py enigma2-nightly.spark/lib/python/Components/NimManager.py
--- enigma2-nightly/lib/python/Components/NimManager.py	2010-08-11 18:16:49.622352132 +0800
+++ enigma2-nightly.spark/lib/python/Components/NimManager.py	2010-08-11 18:12:24.813485950 +0800
@@ -17,6 +17,10 @@
 from Tools.BoundFunction import boundFunction
 
 def getConfigSatlist(orbpos, satlist):
+#+++>  CAUSE OF CRASH!
+	if not satlist:
+		return None
+#+++<
 	default_orbpos = None
 	for x in satlist:
 		if x[0] == orbpos:
@@ -355,6 +359,9 @@
 
 					if currLnb.diseqcMode.value == "1_0":
 						currCO = currLnb.commandOrder1_0.value
+#+++>  WHY ???
+						sec.setRepeats(0)
+#+++<
 					else:
 						currCO = currLnb.commandOrder.value
 
@@ -982,7 +989,9 @@
 
 	lnb_choices = {
 		"universal_lnb": _("Universal LNB"),
-#		"unicable": _("Unicable"),
+#+++> activated Unicable
+		"unicable": _("Unicable"),
+#+++<
 		"c_band": _("C-Band"),
 		"user_defined": _("User defined")}
 
diff -Nur enigma2-nightly/lib/python/Components/Renderer/Progress.py enigma2-nightly.spark/lib/python/Components/Renderer/Progress.py
--- enigma2-nightly/lib/python/Components/Renderer/Progress.py	2010-08-11 18:16:49.624721149 +0800
+++ enigma2-nightly.spark/lib/python/Components/Renderer/Progress.py	2010-08-11 18:12:24.867512386 +0800
@@ -13,26 +13,60 @@
 	GUI_WIDGET = eSlider
 
 	def changed(self, what):
-		if what[0] == self.CHANGED_CLEAR:
-			(self.range, self.value) = ((0, 1), 0)
-			return
-
-		range = self.source.range or 100
-		value = self.source.value
-		if value is None:
-			value = 0
-		(self.range, self.value) = ((0, range), value)
+#--->
+#-		if what[0] == self.CHANGED_CLEAR:
+#-			(self.range, self.value) = ((0, 1), 0)
+#-			return
+#-
+#-		range = self.source.range or 100
+#-		value = self.source.value
+#-		if value is None:
+#-			value = 0
+#-		(self.range, self.value) = ((0, range), value)
+#---<
+#+++>
+		try:
+			if what[0] == self.CHANGED_CLEAR:
+				(self.range, self.value) = ((0, 1), 0)
+				return
+
+
+			range = (self.source and self.source.range) or 100
+			value = (self.source and self.source.value) or 0
+
+			if value is None:
+				value = 0
+			(self.range, self.value) = ((0, range), value)
+		except:
+			None
+#+++<
 
 	GUI_WIDGET = eSlider
 
 	def postWidgetCreate(self, instance):
-		instance.setRange(self.__start, self.__end)
-
+#--->
+#-		instance.setRange(self.__start, self.__end)
+#---<
+#+++>
+		try:
+			instance.setRange(self.__start, self.__end)
+		except:
+			None
+#+++<
 	def setRange(self, range):
-		(self.__start, self.__end) = range
-		if self.instance is not None:
-			self.instance.setRange(self.__start, self.__end)
-
+#--->
+#-		(self.__start, self.__end) = range
+#-		if self.instance is not None:
+#-			self.instance.setRange(self.__start, self.__end)
+#---<
+#+++>
+		try:
+			(self.__start, self.__end) = range
+			if self.instance is not None:
+				self.instance.setRange(self.__start, self.__end)
+		except:
+			None
+#+++<
 	def getRange(self):
 		return (self.__start, self.__end)
 
diff -Nur enigma2-nightly/lib/python/Components/TunerInfo.py enigma2-nightly.spark/lib/python/Components/TunerInfo.py
--- enigma2-nightly/lib/python/Components/TunerInfo.py	2010-08-11 18:16:49.627876442 +0800
+++ enigma2-nightly.spark/lib/python/Components/TunerInfo.py	2010-08-11 18:12:24.815459963 +0800
@@ -60,8 +60,17 @@
 			value = self.getValue(self.LOCK)
 
 		if self.type == self.SNR_DB:
-			if value != 0x12345678:
-				self.setText("%3.02f dB" % (value / 100.0))
+#--->   CAUSE OF CRASH!
+#-			if value != 0x12345678:
+#-				self.setText("%3.02f dB" % (value / 100.0))
+#---<
+#+++>   CAUSE OF CRASH!
+			if value is not None:
+				if value != 0x12345678:
+					self.setText("%3.02f dB" % (value / 100.0))
+				else:
+					self.setText("")
+#+++>   CAUSE OF CRASH!		
 			else:
 				self.setText("")
 		elif self.type == self.SNR_PERCENTAGE or self.type == self.AGC_PERCENTAGE:
diff -Nur enigma2-nightly/lib/python/Components/UsageConfig.py enigma2-nightly.spark/lib/python/Components/UsageConfig.py
--- enigma2-nightly/lib/python/Components/UsageConfig.py	2010-08-11 18:16:49.627876442 +0800
+++ enigma2-nightly.spark/lib/python/Components/UsageConfig.py	2010-08-11 18:12:24.862500249 +0800
@@ -51,6 +51,9 @@
 
 	config.usage.on_long_powerpress = ConfigSelection(default = "show_menu", choices = [
 		("show_menu", _("show shutdown menu")),
+#+++>
+		("standby", _("immediate standby")),
+#+++<
 		("shutdown", _("immediate shutdown")) ] )
 
 	config.usage.alternatives_priority = ConfigSelection(default = "0", choices = [
diff -Nur enigma2-nightly/lib/python/Components/VolumeControl.py enigma2-nightly.spark/lib/python/Components/VolumeControl.py
--- enigma2-nightly/lib/python/Components/VolumeControl.py	2010-08-11 18:16:49.627876442 +0800
+++ enigma2-nightly.spark/lib/python/Components/VolumeControl.py	2010-08-11 18:12:24.861832645 +0800
@@ -71,13 +71,27 @@
 		self.volumeDialog.hide()
 
 	def volMute(self, showMuteSymbol=True, force=False):
-		vol = self.volctrl.getVolume()
+#--->
+#-		vol = self.volctrl.getVolume()
+#---<
+#+++>
+		if config.audio.volume.value != 0:
+			vol = config.audio.volume.value
+		else:
+			vol = self.volctrl.getVolume()
+#+++<
 		if vol or force:
 			self.volctrl.volumeToggleMute()
 			if self.volctrl.isMuted():
 				if showMuteSymbol:
 					self.muteDialog.show()
 				self.volumeDialog.setValue(0)
+#+++>
+				self.volctrl.setVolume(0,0)
+#+++<
 			else:
 				self.muteDialog.hide()
 				self.volumeDialog.setValue(vol)
+#+++>
+				self.volctrl.setVolume(vol, vol)
+#+++<
diff -Nur enigma2-nightly/lib/python/Components/VolumeControl.py.orig enigma2-nightly.spark/lib/python/Components/VolumeControl.py.orig
--- enigma2-nightly/lib/python/Components/VolumeControl.py.orig	1970-01-01 08:00:00.000000000 +0800
+++ enigma2-nightly.spark/lib/python/Components/VolumeControl.py.orig	2010-08-11 18:11:32.832477865 +0800
@@ -0,0 +1,83 @@
+from enigma import eDVBVolumecontrol, eTimer
+from Tools.Profile import profile
+from Screens.Volume import Volume
+from Screens.Mute import Mute
+from GlobalActions import globalActionMap
+from config import config, ConfigSubsection, ConfigInteger
+
+profile("VolumeControl")
+#TODO .. move this to a own .py file
+class VolumeControl:
+	instance = None
+	"""Volume control, handles volUp, volDown, volMute actions and display
+	a corresponding dialog"""
+	def __init__(self, session):
+		global globalActionMap
+		globalActionMap.actions["volumeUp"]=self.volUp
+		globalActionMap.actions["volumeDown"]=self.volDown
+		globalActionMap.actions["volumeMute"]=self.volMute
+
+		assert not VolumeControl.instance, "only one VolumeControl instance is allowed!"
+		VolumeControl.instance = self
+
+		config.audio = ConfigSubsection()
+		config.audio.volume = ConfigInteger(default = 100, limits = (0, 100))
+
+		self.volumeDialog = session.instantiateDialog(Volume)
+		self.muteDialog = session.instantiateDialog(Mute)
+
+		self.hideVolTimer = eTimer()
+		self.hideVolTimer.callback.append(self.volHide)
+
+		vol = config.audio.volume.value
+		self.volumeDialog.setValue(vol)
+		self.volctrl = eDVBVolumecontrol.getInstance()
+		self.volctrl.setVolume(vol, vol)
+
+	def volSave(self):
+		if self.volctrl.isMuted():
+			config.audio.volume.value = 0
+		else:
+			config.audio.volume.value = self.volctrl.getVolume()
+		config.audio.volume.save()
+
+	def volUp(self):
+		self.setVolume(+1)
+
+	def volDown(self):
+		self.setVolume(-1)
+
+	def setVolume(self, direction):
+		oldvol = self.volctrl.getVolume()
+		if direction > 0:
+			self.volctrl.volumeUp()
+		else:
+			self.volctrl.volumeDown()
+		is_muted = self.volctrl.isMuted()
+		vol = self.volctrl.getVolume()
+		self.volumeDialog.show()
+		if is_muted:
+			self.volMute() # unmute
+		elif not vol:
+			self.volMute(False, True) # mute but dont show mute symbol
+		if self.volctrl.isMuted():
+			self.volumeDialog.setValue(0)
+		else:
+			self.volumeDialog.setValue(self.volctrl.getVolume())
+		self.volSave()
+		self.hideVolTimer.start(3000, True)
+
+	def volHide(self):
+		self.volumeDialog.hide()
+
+	def volMute(self, showMuteSymbol=True, force=False):
+		vol = self.volctrl.getVolume()
+		if vol or force:
+			self.volctrl.volumeToggleMute()
+			if self.volctrl.isMuted():
+				if showMuteSymbol:
+					self.muteDialog.show()
+				self.volumeDialog.setValue(0)
+			else:
+				self.muteDialog.hide()
+				self.volumeDialog.setValue(vol)
diff -Nur enigma2-nightly/lib/python/enigma_python.i enigma2-nightly.spark/lib/python/enigma_python.i
--- enigma2-nightly/lib/python/enigma_python.i	2010-08-11 18:16:49.821816964 +0800
+++ enigma2-nightly.spark/lib/python/enigma_python.i	2010-08-11 18:12:24.815459963 +0800
@@ -97,6 +97,7 @@
 #include <lib/dvb_ci/dvbci_ui.h>
 #include <lib/python/python.h>
 #include <lib/gdi/picload.h>
+#include <lib/driver/vfd.h> 
 %}
 
 %feature("ref")   iObject "$this->AddRef(); /* eDebug(\"AddRef (%s:%d)!\", __FILE__, __LINE__); */ "
@@ -212,6 +213,7 @@
 %include <lib/dvb/db.h>
 %include <lib/python/python.h>
 %include <lib/gdi/picload.h>
+%include <lib/driver/vfd.h> 
 /**************  eptr  **************/
 
 /**************  signals  **************/
diff -Nur enigma2-nightly/lib/python/Makefile.am enigma2-nightly.spark/lib/python/Makefile.am
--- enigma2-nightly/lib/python/Makefile.am	2010-08-11 18:16:49.630749699 +0800
+++ enigma2-nightly.spark/lib/python/Makefile.am	2010-08-11 18:12:24.817481843 +0800
@@ -10,7 +10,7 @@
 	python.cpp enigma_python_wrap.cxx connections.cpp
 
 enigma_python_wrap.cxx: enigma_python.i
-	swig -I$(top_srcdir)/ -c++ -python -O -nortti -nothreads enigma_python.i
+	swig -I$(top_srcdir)/ -c++ -python -D__sh__ -O -nortti -nothreads enigma_python.i
 	python enigma_py_patcher.py
 
 enigma.py: enigma_python_wrap.cxx
diff -Nur enigma2-nightly/lib/python/Plugins/Extensions/CuberevoVFD/__init__.py enigma2-nightly.spark/lib/python/Plugins/Extensions/CuberevoVFD/__init__.py
--- enigma2-nightly/lib/python/Plugins/Extensions/CuberevoVFD/__init__.py	1970-01-01 08:00:00.000000000 +0800
+++ enigma2-nightly.spark/lib/python/Plugins/Extensions/CuberevoVFD/__init__.py	2010-08-11 18:12:24.884614537 +0800
@@ -0,0 +1,2 @@
+
+
diff -Nur enigma2-nightly/lib/python/Plugins/Extensions/CuberevoVFD/Makefile.am enigma2-nightly.spark/lib/python/Plugins/Extensions/CuberevoVFD/Makefile.am
--- enigma2-nightly/lib/python/Plugins/Extensions/CuberevoVFD/Makefile.am	1970-01-01 08:00:00.000000000 +0800
+++ enigma2-nightly.spark/lib/python/Plugins/Extensions/CuberevoVFD/Makefile.am	2010-08-11 18:12:24.885989736 +0800
@@ -0,0 +1,7 @@
+installdir = $(LIBDIR)/enigma2/python/Plugins/Extensions/CuberevoVFD
+
+install_PYTHON =	\
+	__init__.py \
+	plugin.py
+
+ 
diff -Nur enigma2-nightly/lib/python/Plugins/Extensions/CuberevoVFD/plugin.py enigma2-nightly.spark/lib/python/Plugins/Extensions/CuberevoVFD/plugin.py
--- enigma2-nightly/lib/python/Plugins/Extensions/CuberevoVFD/plugin.py	1970-01-01 08:00:00.000000000 +0800
+++ enigma2-nightly.spark/lib/python/Plugins/Extensions/CuberevoVFD/plugin.py	2010-08-11 18:12:24.886613667 +0800
@@ -0,0 +1,350 @@
+from Screens.Screen import Screen
+from Screens.MessageBox import MessageBox
+from Plugins.Plugin import PluginDescriptor
+from Tools import Notifications
+from Components.Pixmap import Pixmap, MovingPixmap
+from Components.ActionMap import ActionMap, NumberActionMap
+from Components.Label import Label
+from Components.Button import Button
+from Components.Console import Console
+from Components.ConfigList import ConfigList
+from Components.config import config, configfile, ConfigSubsection, ConfigEnableDisable, \
+     getConfigListEntry, ConfigInteger, ConfigSelection
+from Components.ConfigList import ConfigListScreen
+from Plugins.Plugin import PluginDescriptor
+import ServiceReference
+#---- Civer start ----#
+#- from enigma import iPlayableService, eServiceCenter, iServiceInformation
+#- from enigma import evfd
+from enigma import *
+#----- Civer end ----#
+from Components.ServiceEventTracker import ServiceEventTracker, InfoBarBase
+from re import compile as re_compile, search as re_search
+
+import os
+
+my_global_session = None
+
+config.plugins.CuberevoVFD = ConfigSubsection()
+config.plugins.CuberevoVFD.scroll = ConfigSelection(default = "once", choices = [("never"), ("once"), ("always")])
+config.plugins.CuberevoVFD.brightness = ConfigSelection(default = "bright", choices = [("dark"), ("medium"), ("bright")])
+config.plugins.CuberevoVFD.showClock = ConfigEnableDisable(default = True)
+config.plugins.CuberevoVFD.setDaylight = ConfigEnableDisable(default = False)
+config.plugins.CuberevoVFD.timeMode = ConfigSelection(default = "24h", choices = [("12h"),("24h")])
+config.plugins.CuberevoVFD.setLed = ConfigEnableDisable(default = False)
+config.plugins.CuberevoVFD.setFan = ConfigEnableDisable(default = True)
+
+class CuberevoVFDSetup(ConfigListScreen, Screen):
+	skin = """
+		<screen position="100,100" size="550,400" title="CuberevoVFD Setup" >
+		<widget name="config" position="20,10" size="460,350" scrollbarMode="showOnDemand" />
+		<ePixmap position="140,350" size="140,40" pixmap="skin_default/buttons/green.png" alphatest="on" />
+		<ePixmap position="280,350" size="140,40" pixmap="skin_default/buttons/red.png" alphatest="on" />
+		<widget name="key_green" position="140,350" size="140,40" font="Regular;20" backgroundColor="#1f771f" zPosition="2" transparent="1" shadowColor="black" shadowOffset="-1,-1" />
+		<widget name="key_red" position="280,350" size="140,40" font="Regular;20" backgroundColor="#9f1313" zPosition="2" transparent="1" shadowColor="black" shadowOffset="-1,-1" />
+		</screen>"""
+
+
+	def __init__(self, session, args = None):
+		Screen.__init__(self, session)
+		self.onClose.append(self.abort)
+		
+		# create elements for the menu list
+		self.list = [ ]
+		self.list.append(getConfigListEntry(_("Show clock"), config.plugins.CuberevoVFD.showClock))
+		self.list.append(getConfigListEntry(_("Daylight"), config.plugins.CuberevoVFD.setDaylight))
+		self.list.append(getConfigListEntry(_("Time mode"), config.plugins.CuberevoVFD.timeMode))
+		self.list.append(getConfigListEntry(_("Set led"), config.plugins.CuberevoVFD.setLed))
+		self.list.append(getConfigListEntry(_("Brightness"), config.plugins.CuberevoVFD.brightness))
+		self.list.append(getConfigListEntry(_("Scroll long strings"), config.plugins.CuberevoVFD.scroll))
+		self.list.append(getConfigListEntry(_("Set fan"), config.plugins.CuberevoVFD.setFan))
+		ConfigListScreen.__init__(self, self.list)
+
+		self.Console = Console()
+		self["key_red"] = Button(_("Cancel"))
+		self["key_green"] = Button(_("Save"))
+
+		# DO NOT ASK.
+		self["setupActions"] = ActionMap(["SetupActions"],
+		{
+			"save": self.save,
+			"cancel": self.cancel,
+			"ok": self.save,
+		}, -2)
+
+	def abort(self):
+		print "aborting"
+
+	def save(self):
+		# save all settings
+		for x in self["config"].list:
+			x[1].save()
+
+		if config.plugins.CuberevoVFD.showClock.getValue():
+			cubeVfd.enableClock()
+		else:
+			cubeVfd.disableClock()
+
+		if config.plugins.CuberevoVFD.setDaylight.getValue():
+			cubeVfd.enableDaylight()
+		else:
+			cubeVfd.disableDaylight()
+
+		if config.plugins.CuberevoVFD.timeMode.value == "24h":
+			cubeVfd.enableTimeMode()
+		else:
+			cubeVfd.disableTimeMode()
+
+		# enable/disable fan activity
+		if config.plugins.CuberevoVFD.setFan.getValue():
+			cubeVfd.enableFan()
+		else:
+			cubeVfd.disableFan()
+
+		# enable/disable led activity
+		if config.plugins.CuberevoVFD.setLed.getValue():
+			cubeVfd.enableLed()
+		else:
+			cubeVfd.disableLed()
+
+	# set the brightness
+		brightness = 3
+		if config.plugins.CuberevoVFD.brightness.getValue() == "dark":
+			brightness = 1
+		elif config.plugins.CuberevoVFD.brightness.getValue() == "bright":
+			brightness = 7
+		evfd.getInstance().vfd_set_brightness(brightness)
+
+	# set the the scroll mode
+		if config.plugins.CuberevoVFD.scroll.value == "once":
+			scrollMode = 1
+		elif config.plugins.CuberevoVFD.scroll.value == "always":
+			scrollMode = 2
+		else:
+			scrollMode = 0
+		evfd.getInstance().vfd_set_ani(scrollMode)
+
+		configfile.save()
+
+		self.close()
+
+	def cancel(self):
+		for x in self["config"].list:
+			x[1].cancel()
+		self.close()
+
+
+class CuberevoVFD:
+	def __init__(self, session):
+		#print "CuberevoVFD initializing"
+#---- CIVER start ----#
+		global showmenuorpanel
+		showmenuorpanel = False
+		self.showtimer = eTimer()
+#---- CIVER end ----#
+		self.session = session
+		self.service = None
+		self.onClose = [ ]
+		self.__event_tracker = ServiceEventTracker(screen=self,eventmap=
+			{
+				iPlayableService.evSeekableStatusChanged: self.__evSeekableStatusChanged,
+				iPlayableService.evStart: self.__evStart,
+			})
+		self.Console = Console()
+		self.tsEnabled = False
+#---- CIVER start ----#
+		self.timer = eTimer()
+		self.timer.callback.append(self.handleTimer)
+		self.timer.start(1000, False)
+#---- CIVER end ----#
+		self.fanEnabled = config.plugins.CuberevoVFD.setFan.getValue()
+		self.ledEnabled = config.plugins.CuberevoVFD.setLed.getValue()
+		self.clockEnabled = config.plugins.CuberevoVFD.showClock.getValue()
+		self.daylightEnabled = config.plugins.CuberevoVFD.setDaylight.getValue()
+		if config.plugins.CuberevoVFD.timeMode.value == "24h":
+			self.timeModeEnabled = 1
+		else:
+			self.timeModeEnabled = 0
+		if self.fanEnabled == False:
+			self.disableFan()
+		else:
+			self.enableFan()
+		if self.ledEnabled == False:
+			self.disableLed()
+		else:
+			self.enableLed()
+		if config.plugins.CuberevoVFD.scroll.value == "once":
+			scrollMode = 1
+		elif config.plugins.CuberevoVFD.scroll.value == "always":
+			scrollMode = 2
+		else:
+			scrollMode = 0
+		evfd.getInstance().vfd_set_ani(scrollMode)
+
+#---- CIVER start---workaround to show servicename again after menues ----#
+	def handleTimer(self):
+		global showmenuorpanel
+		try:
+			from Plugins.Extensions.Aafpanel.plugin import inAAFPanel
+			showPanel = inAAFPanel
+		except:
+			#print '[CuberevoVFD] Error showPanel'
+			showPanel = None
+		try:
+			from Screens.Menu import inMenu
+			showMenu = inMenu
+		except:
+			#print '[CuberevoVFD] Error showMenu'
+			showMenu = None
+		if showMenu or showPanel:
+			self.showtimer.start(4000, True)
+		self.showtimer.callback.append(self.setshowmenuorpanel)
+		if not showMenu and not showPanel and showmenuorpanel is True:
+			showmenuorpanel = False
+			self.service = self.session.nav.getCurrentlyPlayingServiceReference()
+			if not self.service is None:
+				service = self.service.toCompareString()
+				servicename = ServiceReference.ServiceReference(service).getServiceName().replace('\xc2\x87', '').replace('\xc2\x86', '').ljust(16)
+				subservice = self.service.toString().split("::")
+				if subservice[0].count(':') == 9:
+					servicename =subservice[1].replace('\xc2\x87', '').replace('\xc3\x9f', 'ss').replace('\xc2\x86', '').ljust(16)
+				else:
+					servicename=servicename
+				evfd.getInstance().vfd_write_string(servicename[0:17])
+
+	def setshowmenuorpanel(self):
+		global showmenuorpanel
+		showmenuorpanel = True
+		self.showtimer.stop()
+#---- CIVER end ----#
+
+	def enableClock(self):
+		self.clockEnabled = True
+
+	def disableClock(self):
+		self.clockEnabled = False
+
+	def enableTimeMode(self):
+		self.timeModeEnabled = 1
+		try:
+			os.popen("/bin/cubefpctl --settimemode 1")
+		except OSError:
+			print "no memory"
+
+	def disableTimeMode(self):
+		self.timeModeEnabled = 0
+		try:
+			os.popen("/bin/cubefpctl --settimemode 0")
+		except OSError:
+			print "no memory"
+
+	def enableDaylight(self):
+		self.daylightEnabled = True
+		try:
+			os.popen("/bin/cubefpctl --setdaylight 1")
+		except OSError:
+			print "no memory"
+		try:
+			os.popen("/bin/cubefpctl --syncfptime")
+		except OSError:
+			print "no memory"
+
+	def disableDaylight(self):
+		self.daylightEnabled = False
+		try:
+			os.popen("/bin/cubefpctl --setdaylight 0")
+		except OSError:
+			print "no memory"
+		try:
+			os.popen("/bin/cubefpctl --syncfptime")
+		except OSError:
+			print "no memory"
+
+	def enableLed(self):
+		self.ledEnabled = True
+		evfd.getInstance().vfd_set_light(self.ledEnabled)
+
+	def disableLed(self):
+		self.ledEnabled = False
+		evfd.getInstance().vfd_set_light(self.ledEnabled)
+
+	def enableFan(self):
+		self.fanEnabled = True
+		evfd.getInstance().vfd_set_fan(self.fanEnabled)
+
+	def disableFan(self):
+		self.fanEnabled = False
+		evfd.getInstance().vfd_set_fan(self.fanEnabled)
+
+	def regExpMatch(self, pattern, string):
+		if string is None:
+			return None
+		try:
+			return pattern.search(string).group()
+		except AttributeError:
+			None
+	
+	def __evStart(self):
+		self.__evSeekableStatusChanged()
+	
+	def getTimeshiftState(self):
+		service = self.session.nav.getCurrentService()
+		if service is None:
+			return False
+		timeshift = service.timeshift()
+		if timeshift is None:
+			return False
+		return True
+
+	def __evSeekableStatusChanged(self):
+		tmp = self.getTimeshiftState()
+		if tmp == self.tsEnabled:
+			return
+		if tmp:
+			print "[Timeshift enabled]"
+			evfd.getInstance().vfd_set_icon(0x1A,True)
+		else:
+			print "[Timeshift disabled]"
+			evfd.getInstance().vfd_set_icon(0x1A,False)
+		self.tsEnabled = tmp
+		
+	def shutdown(self):
+		self.abort()
+
+	def abort(self):
+		print "CuberevoVFD aborting"
+
+def main(session, **kwargs):
+	session.open(CuberevoVFDSetup)
+
+cubeVfd = None
+gReason = -1
+mySession = None
+
+def controlcubeVfd():
+	global cubeVfd
+	global gReason
+	global mySession
+
+	if gReason == 0 and mySession != None and cubeVfd == None:
+		print "Starting CuberevoVFD"
+		cubeVfd = CuberevoVFD(mySession)
+	elif gReason == 1 and cubeVfd != None:
+		print "Stopping CuberevoVFD"
+		cubeVfd = None
+
+def autostart(reason, **kwargs):
+	global cubeVfd
+	global gReason
+	global mySession
+
+	if kwargs.has_key("session"):
+		global my_global_session
+		mySession = kwargs["session"]
+	else:
+		gReason = reason
+	controlcubeVfd()
+
+def Plugins(**kwargs):
+	return [ PluginDescriptor(name="CuberevoVFD", description="Change VFD display settings", where = PluginDescriptor.WHERE_PLUGINMENU, fnc=main),
+		PluginDescriptor(where = [PluginDescriptor.WHERE_SESSIONSTART, PluginDescriptor.WHERE_AUTOSTART], fnc = autostart) ]
diff -Nur enigma2-nightly/lib/python/Plugins/Extensions/Makefile.am enigma2-nightly.spark/lib/python/Plugins/Extensions/Makefile.am
--- enigma2-nightly/lib/python/Plugins/Extensions/Makefile.am	2010-08-11 18:16:49.659009696 +0800
+++ enigma2-nightly.spark/lib/python/Plugins/Extensions/Makefile.am	2010-08-11 18:12:24.818471272 +0800
@@ -1,6 +1,14 @@
 installdir = $(pkglibdir)/python/Plugins/Extensions
 
-SUBDIRS = TuxboxPlugins CutListEditor PicturePlayer MediaScanner MediaPlayer GraphMultiEPG SocketMMI DVDPlayer DVDBurn Modem
+SUBDIRS = CutListEditor PicturePlayer MediaScanner MediaPlayer GraphMultiEPG SocketMMI DVDPlayer DVDBurn
+
+if ENABLE_TF7700
+SUBDIRS += TopfieldVFD
+endif
+
+if ENABLE_CUBEREVO
+SUBDIRS += CuberevoVFD
+endif
 
 install_PYTHON =	\
 	__init__.py
diff -Nur enigma2-nightly/lib/python/Plugins/Extensions/TopfieldVFD/__init__.py enigma2-nightly.spark/lib/python/Plugins/Extensions/TopfieldVFD/__init__.py
--- enigma2-nightly/lib/python/Plugins/Extensions/TopfieldVFD/__init__.py	1970-01-01 08:00:00.000000000 +0800
+++ enigma2-nightly.spark/lib/python/Plugins/Extensions/TopfieldVFD/__init__.py	2010-08-11 18:12:24.819550162 +0800
@@ -0,0 +1,2 @@
+
+
diff -Nur enigma2-nightly/lib/python/Plugins/Extensions/TopfieldVFD/Makefile.am enigma2-nightly.spark/lib/python/Plugins/Extensions/TopfieldVFD/Makefile.am
--- enigma2-nightly/lib/python/Plugins/Extensions/TopfieldVFD/Makefile.am	1970-01-01 08:00:00.000000000 +0800
+++ enigma2-nightly.spark/lib/python/Plugins/Extensions/TopfieldVFD/Makefile.am	2010-08-11 18:12:24.820479747 +0800
@@ -0,0 +1,7 @@
+installdir = $(LIBDIR)/enigma2/python/Plugins/Extensions/TopfieldVFD
+
+install_PYTHON =	\
+	__init__.py \
+	plugin.py
+
+ 
diff -Nur enigma2-nightly/lib/python/Plugins/Extensions/TopfieldVFD/plugin.py enigma2-nightly.spark/lib/python/Plugins/Extensions/TopfieldVFD/plugin.py
--- enigma2-nightly/lib/python/Plugins/Extensions/TopfieldVFD/plugin.py	1970-01-01 08:00:00.000000000 +0800
+++ enigma2-nightly.spark/lib/python/Plugins/Extensions/TopfieldVFD/plugin.py	2010-08-11 18:12:24.821502472 +0800
@@ -0,0 +1,464 @@
+from Screens.Screen import Screen
+from Screens.MessageBox import MessageBox
+from Plugins.Plugin import PluginDescriptor
+from Tools import Notifications
+from Components.Pixmap import Pixmap, MovingPixmap
+from Components.ActionMap import ActionMap, NumberActionMap
+from Components.Label import Label
+from Components.Button import Button
+from Components.Console import Console
+from Components.ConfigList import ConfigList
+from Components.config import config, ConfigSubsection, ConfigEnableDisable, \
+     getConfigListEntry, ConfigInteger, ConfigSelection
+from Components.ConfigList import ConfigListScreen
+from Plugins.Plugin import PluginDescriptor
+import ServiceReference
+from enigma import iPlayableService, eTimer, eServiceCenter, iServiceInformation
+from enigma import evfd
+import time, fcntl, struct
+from Components.ServiceEventTracker import ServiceEventTracker, InfoBarBase
+from enigma import eTimer
+from re import compile as re_compile, search as re_search
+from time import time, localtime, strftime
+from Components.UsageConfig import defaultMoviePath
+from os import statvfs
+import array
+
+my_global_session = None
+debug = False
+
+
+config.plugins.TopfieldVFD = ConfigSubsection()
+config.plugins.TopfieldVFD.allCaps = ConfigEnableDisable(default = False)
+config.plugins.TopfieldVFD.scroll = ConfigSelection(choices = [("never"), ("once"), ("always")])
+config.plugins.TopfieldVFD.brightness = ConfigSelection(default = "medium", choices = [("dark"), ("medium"), ("bright")])
+config.plugins.TopfieldVFD.scrollPause = ConfigInteger(default = 100, limits = (1, 255))
+config.plugins.TopfieldVFD.scrollDelay = ConfigInteger(default = 10, limits = (1, 255))
+config.plugins.TopfieldVFD.typematicDelay = ConfigInteger(default = 3, limits = (0, 255))
+config.plugins.TopfieldVFD.typematicRate = ConfigInteger(default = 1, limits = (0, 255))
+config.plugins.TopfieldVFD.rcCommandSet = ConfigSelection(default = "TF7700 & Masterpiece", choices = [("TF7700"), ("Masterpiece"), ("TF7700 & Masterpiece")])
+config.plugins.TopfieldVFD.showClock = ConfigEnableDisable(default = True)
+config.plugins.TopfieldVFD.showEthernet = ConfigEnableDisable(default = True)
+
+# ioctl definitions for the VFD
+ioBootReason = 0x40003a0b
+ioOffFlush = struct.pack('LLB', 0x2, 0x0, 0x6)
+ioRec1Flush = struct.pack('LLB', 0x1000, 0x0, 0x6)
+ioRec2Flush = struct.pack('LLB', 0x2000, 0x0, 0x6)
+ioRecBothFlush = struct.pack('LLB', 0x3000, 0x0, 0x6)
+ioClockFlush = struct.pack('LLB', 0x20, 0x0, 0x6)
+ioClockOff = struct.pack('LLB', 0x20, 0x0, 0x0)
+ioHddClear =    struct.pack('LLB', 0x0, 0xff8000,0x0)
+ioHddUsage = (  struct.pack('LLB', 0x0, 0x006000,0xf),  # HDD empty
+                struct.pack('LLB', 0x0, 0x00e000,0xf),
+                struct.pack('LLB', 0x0, 0x01e000,0xf),
+                struct.pack('LLB', 0x0, 0x03e000,0xf),
+                struct.pack('LLB', 0x0, 0x07e000,0xf),
+                struct.pack('LLB', 0x0, 0x0fe000,0xf),
+                struct.pack('LLB', 0x0, 0x1fe000,0xf),
+                struct.pack('LLB', 0x0, 0x3fe000,0xf),
+                struct.pack('LLB', 0x0, 0x7fe000,0xf))  # HDD full
+ioHddFull = struct.pack('LLB', 0x0, 0x800000,0x6)       # "HDD full" flashing
+hddCheckPeriod = 60 # check every 60 seconds
+ioIconCmd = 0x400b3a20
+ioTimeshiftOn = struct.pack('LLB', 0x80, 0x0, 0xf)
+ioTimeshiftOff = struct.pack('LLB', 0x80, 0x0, 0x0)
+ioRec1On = struct.pack('LLB', 0x1000, 0x0, 0xf)
+ioRec1Off = struct.pack('LLB', 0x1000, 0x0, 0x0)
+ioRec2On = struct.pack('LLB', 0x2000, 0x0, 0xf)
+ioRec2Off = struct.pack('LLB', 0x2000, 0x0, 0x0)
+ioRecBothOn = struct.pack('LLB', 0x3000, 0x0, 0xf)
+ioRecBothOff = struct.pack('LLB', 0x3000, 0x0, 0x0)
+ioEthBothOff = struct.pack('LLB', 0x0c000000, 0x0, 0x0)
+ioEthLeftOn = struct.pack('LLB', 0x08000000, 0x0, 0xe)
+ioEthRightOn = struct.pack('LLB', 0x04000000, 0x0,0xb)
+
+ioColonOn = struct.pack('LLB', 0x4, 0x0,0x3)
+ioColonOff = struct.pack('LLB', 0x4, 0x0,0x0)
+ioBrightnessCmd = 0x40013a05
+ioIrFilter1Cmd = 0x40003a06
+ioIrFilter4Cmd = 0x40003a09
+ioTypematicDelayCmd = 0x40013a0d
+ioTypematicRateCmd = 0x40013a0e
+ioScrollModeCmd = 0x40033a15
+ioAllcapsCmd = 0x40013a14
+
+class TopfieldVFDSetup(ConfigListScreen, Screen):
+        skin = """
+                <screen position="100,100" size="550,400" title="TopfieldVFD Setup" >
+                <widget name="config" position="20,10" size="460,350" scrollbarMode="showOnDemand" />
+                <ePixmap position="140,350" size="140,40" pixmap="skin_default/buttons/green.png" alphatest="on" />
+                <ePixmap position="280,350" size="140,40" pixmap="skin_default/buttons/red.png" alphatest="on" />
+                <widget name="key_green" position="140,350" size="140,40" font="Regular;20" backgroundColor="#1f771f" zPosition="2" transparent="1" shadowColor="black" shadowOffset="-1,-1" />
+                <widget name="key_red" position="280,350" size="140,40" font="Regular;20" backgroundColor="#9f1313" zPosition="2" transparent="1" shadowColor="black" shadowOffset="-1,-1" />
+                </screen>"""
+
+
+        def __init__(self, session, args = None):
+                Screen.__init__(self, session)
+                self.onClose.append(self.abort)
+
+                # create elements for the menu list
+                self.list = [ ]
+                self.list.append(getConfigListEntry(_("Show clock"), config.plugins.TopfieldVFD.showClock))
+                self.list.append(getConfigListEntry(_("Show Ethernet activity"), config.plugins.TopfieldVFD.showEthernet))
+                self.list.append(getConfigListEntry(_("Brightness"), config.plugins.TopfieldVFD.brightness))
+                self.list.append(getConfigListEntry(_("All caps"), config.plugins.TopfieldVFD.allCaps))
+                self.list.append(getConfigListEntry(_("Scroll long strings"), config.plugins.TopfieldVFD.scroll))
+                self.list.append(getConfigListEntry(_("Scroll pause"), config.plugins.TopfieldVFD.scrollPause))
+                self.list.append(getConfigListEntry(_("Scroll delay"), config.plugins.TopfieldVFD.scrollDelay))
+                self.list.append(getConfigListEntry(_("Typematic delay"), config.plugins.TopfieldVFD.typematicDelay))
+                self.list.append(getConfigListEntry(_("Typematic rate"), config.plugins.TopfieldVFD.typematicRate))
+                self.list.append(getConfigListEntry(_("RC command set"), config.plugins.TopfieldVFD.rcCommandSet))
+                ConfigListScreen.__init__(self, self.list)
+
+                self.Console = Console()
+                self["key_red"] = Button(_("Cancel"))
+                self["key_green"] = Button(_("Save"))
+
+                # DO NOT ASK.
+                self["setupActions"] = ActionMap(["SetupActions"],
+                {
+                        "save": self.save,
+                        "cancel": self.cancel,
+                        "ok": self.save,
+                }, -2)
+
+        def abort(self):
+                print "aborting"
+
+        def save(self):
+                # save all settings
+                for x in self["config"].list:
+                        x[1].save()
+                tfVfd.setValues()
+                self.close()
+
+        def cancel(self):
+                for x in self["config"].list:
+                        x[1].cancel()
+                self.close()
+
+
+class TopfieldVFD:
+        def __init__(self, session):
+                #print "TopfieldVFD initializing"
+                self.session = session
+                self.service = None
+                self.onClose = [ ]
+                self.__event_tracker = ServiceEventTracker(screen=self,eventmap=
+                        {
+                                iPlayableService.evSeekableStatusChanged: self.__evSeekableStatusChanged,
+                                iPlayableService.evStart: self.__evStart,
+                        })
+                session.nav.record_event.append(self.gotRecordEvent)
+                self.Console = Console()
+                self.tsEnabled = False
+                self.recNum = 0
+                self.timer = eTimer()
+                self.timer.callback.append(self.handleTimer)
+                self.timer.start(1000, False)
+                self.txCount = 0
+                self.clock = 0
+                self.valuesSet = 0
+                self.hddUsed = 10 # initialize with an invalid value
+                self.hddCheckCounter = hddCheckPeriod
+                self.ethEnabled = config.plugins.TopfieldVFD.showEthernet.getValue()
+                self.clockEnabled = config.plugins.TopfieldVFD.showClock.getValue()
+                self.setValues()
+
+        def setValues(self):
+                #print "\nTopfiledVFD.setValues()\n"
+                if config.plugins.TopfieldVFD.showClock.value:
+                        self.enableClock()
+                else:
+                        self.disableClock()
+
+                # enable/disable displaying Ethernet activity
+                if config.plugins.TopfieldVFD.showEthernet.getValue():
+                        self.enableEthernet()
+                else:
+                        self.disableEthernet()
+
+                try:
+                        fd = open("/dev/fpc")
+
+                        # set the brightness
+                        brightness = 3
+                        if config.plugins.TopfieldVFD.brightness.getValue() == "dark":
+                                brightness = 1
+                        elif config.plugins.TopfieldVFD.brightness.getValue() == "bright":
+                                brightness = 5
+                        fcntl.ioctl(fd.fileno(), ioBrightnessCmd, struct.pack('B', brightness))
+
+                        # set the the scroll mode
+                        if config.plugins.TopfieldVFD.scroll.value == "once":
+                                scrollMode = 1
+                        elif config.plugins.TopfieldVFD.scroll.value == "always":
+                                scrollMode = 2
+                        else: # set to never by default
+                                scrollMode = 0
+                        scrollOpts = struct.pack('BBB', scrollMode,
+                                                int(config.plugins.TopfieldVFD.scrollPause.value),
+                                                int(config.plugins.TopfieldVFD.scrollDelay.value))
+                        fcntl.ioctl(fd.fileno(), ioScrollModeCmd, scrollOpts)
+
+                        # set the typematic values
+                        tmp = struct.pack('B', int(config.plugins.TopfieldVFD.typematicRate.value))
+                        fcntl.ioctl(fd.fileno(), ioTypematicRateCmd, tmp)
+                        tmp = struct.pack('B', int(config.plugins.TopfieldVFD.typematicDelay.value))
+                        fcntl.ioctl(fd.fileno(), ioTypematicDelayCmd, tmp)
+
+                        # set the IR filters
+                        if config.plugins.TopfieldVFD.rcCommandSet.getValue() == "Masterpiece":
+                                fcntl.ioctl(fd.fileno(), ioIrFilter1Cmd, struct.pack('B', 1))
+                                fcntl.ioctl(fd.fileno(), ioIrFilter4Cmd, struct.pack('B', 0))
+                        elif config.plugins.TopfieldVFD.rcCommandSet.getValue() == "TF7700":
+                                fcntl.ioctl(fd.fileno(), ioIrFilter1Cmd, struct.pack('B', 0))
+                                fcntl.ioctl(fd.fileno(), ioIrFilter4Cmd, struct.pack('B', 1))
+                        else: # enable both by default
+                                fcntl.ioctl(fd.fileno(), ioIrFilter1Cmd, struct.pack('B', 1))
+                                fcntl.ioctl(fd.fileno(), ioIrFilter4Cmd, struct.pack('B', 1))
+
+                        # set the allcaps parameter
+                        if config.plugins.TopfieldVFD.allCaps.value:
+                                fcntl.ioctl(fd.fileno(), ioAllcapsCmd, struct.pack('B', 1))
+                        else:
+                                fcntl.ioctl(fd.fileno(), ioAllcapsCmd, struct.pack('B', 0))
+
+#---- Topfi start ----#
+                        buf = array.array('h', [0])
+                        fcntl.ioctl(fd.fileno(),ioBootReason,buf,1)
+                        if buf[0] == 2:
+                                fcntl.ioctl(fd.fileno(), ioIconCmd, ioOffFlush)
+#---- Topfi end ----#
+
+                        fd.close()
+                        self.valuesSet = 1
+                except IOError,e:
+                        if debug:
+                                print "TopfieldVFD: setValues ", e
+
+        def enableEthernet(self):
+                self.ethEnabled = True
+
+        def disableEthernet(self):
+                self.ethEnabled = False
+                try:
+                        fd = open("/dev/fpc")
+                        fcntl.ioctl(fd.fileno(), ioIconCmd, ioEthBothOff)
+                        fd.close()
+                except IOError,e:
+                        if debug:
+                                print "TopfieldVFD: disableEthernet ", e
+
+        def enableClock(self):
+                self.clockEnabled = True
+                self.clock = " "
+                try:
+                        fd = open("/dev/fpc")
+                        fcntl.ioctl(fd.fileno(), ioIconCmd, ioColonOn)
+                        fd.close()
+                except IOError,e:
+                        if debug:
+                                print "TopfieldVFD: enableClock ", e
+
+        def disableClock(self):
+                self.clockEnabled = False
+                self.clock = " "
+                try:
+                        fd = open("/dev/fpc")
+                        fcntl.ioctl(fd.fileno(), ioIconCmd, ioColonOff)
+                        fd.close()
+                        open("/dev/fpsmall", "w").write("     ")
+                except IOError,e:
+                        if debug:
+                                print "TopfieldVFD: disableClock ", e
+
+        def regExpMatch(self, pattern, string):
+                if string is None:
+                        return None
+                try:
+                        return pattern.search(string).group()
+                except AttributeError:
+                        None
+
+        def displayHddUsed(self):
+
+                if debug:
+                        print "TopfieldVFD: determine HDD usage"
+
+                # determine the HDD usage
+                used = 0;
+                try:
+                        f = statvfs(defaultMoviePath())
+                        # there are 8 HDD segments in the VFD
+                        used = (f.f_blocks - f.f_bavail) * 8 / f.f_blocks
+                except OSError:
+                        used = 0;
+
+                if self.hddUsed != used:
+                        try:
+                                fd = open("/dev/fpc")
+                                if self.hddUsed > used:
+                                        fcntl.ioctl(fd.fileno(), ioIconCmd, ioHddClear)
+                                fcntl.ioctl(fd.fileno(), ioIconCmd, ioHddUsage[used])
+                                if used == 8:
+                                        fcntl.ioctl(fd.fileno(), ioIconCmd, ioHddFull)
+                                fd.close();
+                        except IOError,e:
+                                self.hddUsed = used # dummy operation
+                        self.hddUsed = used
+
+        def handleTimer(self):
+                #print "[ TopfieldVFD timer ]"
+                if self.valuesSet == 0:
+                        self.setValues()
+
+                if self.clockEnabled:
+                        clock = strftime("%k%M",localtime(time()))
+                        if clock != self.clock:
+                                self.clock = clock
+                                try:
+                                        open("/dev/fpsmall", "w").write(clock + "\0")
+                                except IOError,e:
+                                        if debug:
+                                                print "TopfieldVFD: handleTimer (clock) ", e
+
+                # check HDD periodically
+                if self.hddCheckCounter < hddCheckPeriod:
+                        self.hddCheckCounter += 1
+                else:
+                        self.hddCheckCounter = 0
+                        self.displayHddUsed()
+
+                if self.ethEnabled == False:
+                        return
+
+                result = open("/proc/net/dev").readlines()
+                numRegExp = "[0-9]+"
+                numPattern = re_compile(numRegExp)
+                txPattern = re_compile("eth0:[ ]*" + numRegExp)
+                for item in result:
+                        tmp = self.regExpMatch(txPattern, item)
+                        if tmp != None:
+                                tmp = tmp[5:].lstrip()
+                                try:
+                                        fd = open("/dev/fpc")
+                                        if self.txCount != tmp:
+                                                fcntl.ioctl(fd.fileno(), ioIconCmd, ioEthLeftOn)
+                                                fcntl.ioctl(fd.fileno(), ioIconCmd, ioEthRightOn)
+                                                self.txCount = tmp
+                                        else:
+                                                fcntl.ioctl(fd.fileno(), ioIconCmd, ioEthBothOff)
+                                        fd.close()
+                                except IOError,e:
+                                        if debug:
+                                                print "TopfieldVFD: handleTimer (Ethernet) ", e
+                                break
+
+        def __evStart(self):
+                self.__evSeekableStatusChanged()
+
+        def getTimeshiftState(self):
+                service = self.session.nav.getCurrentService()
+                if service is None:
+                        return False
+                timeshift = service.timeshift()
+                if timeshift is None:
+                        return False
+                return True
+
+        def __evSeekableStatusChanged(self):
+                tmp = self.getTimeshiftState()
+                if tmp == self.tsEnabled:
+                        return
+                try:
+                        fd = open("/dev/fpc")
+                        if tmp:
+                                print "[Timeshift enabled]"
+                                fcntl.ioctl(fd.fileno(), ioIconCmd, ioTimeshiftOn)
+                        else:
+                                print "[Timeshift disabled]"
+                                fcntl.ioctl(fd.fileno(), ioIconCmd, ioTimeshiftOff)
+                        fd.close()
+                except IOError,e:
+                        if debug:
+                                print "TopfieldVFD: __evSeekableStatusChanged ", e
+                self.tsEnabled = tmp
+
+        def gotRecordEvent(self, service, event):
+                recs = self.session.nav.getRecordings()
+                nrecs = len(recs)
+                if nrecs == self.recNum:
+                        return
+                try:
+                        fd = open("/dev/fpc")
+                        if config.usage.blinking_display_clock_during_recording.value:
+                                if nrecs > 1: # set rec 1+2 symbols
+                                        fcntl.ioctl(fd.fileno(), ioIconCmd, ioRecBothFlush)
+                                        fcntl.ioctl(fd.fileno(), ioIconCmd, ioClockFlush)
+                                elif nrecs > 0: # set rec 1 symbol
+                                        fcntl.ioctl(fd.fileno(), ioIconCmd, ioRecBothOff)
+                                        fcntl.ioctl(fd.fileno(), ioIconCmd, ioClockFlush)
+                                        fcntl.ioctl(fd.fileno(), ioIconCmd, ioRec1Flush)
+                                else:
+                                        fcntl.ioctl(fd.fileno(), ioIconCmd, ioClockOff)
+                                        fcntl.ioctl(fd.fileno(), ioIconCmd, ioRecBothOff)
+                        else:
+                                fcntl.ioctl(fd.fileno(), ioIconCmd, ioClockOff)
+                                if nrecs > 1: # set rec 1+2 symbols
+                                        fcntl.ioctl(fd.fileno(), ioIconCmd, ioRecBothOn)
+                                elif nrecs > 0: # set rec 1 symbol
+                                        fcntl.ioctl(fd.fileno(), ioIconCmd, ioRecBothOff)
+                                        fcntl.ioctl(fd.fileno(), ioIconCmd, ioRec1On)
+                                else:
+                                        fcntl.ioctl(fd.fileno(), ioIconCmd, ioRecBothOff)
+
+                        fd.close()
+                except IOError,e:
+                        if debug:
+                                print "TopfieldVFD: gotRecordEvent ", e
+                self.recNum = nrecs
+
+        def shutdown(self):
+                self.abort()
+
+        def abort(self):
+                print "TopfieldVFD aborting"
+
+def main(session, **kwargs):
+        session.open(TopfieldVFDSetup)
+
+tfVfd = None
+gReason = -1
+mySession = None
+
+def controlTfVfd():
+        global tfVfd
+        global gReason
+        global mySession
+
+        if gReason == 0 and mySession != None and tfVfd == None:
+                print "Starting TopfieldVFD"
+                tfVfd = TopfieldVFD(mySession)
+        elif gReason == 1 and tfVfd != None:
+                print "Stopping TopfieldVFD"
+                tfVfd.disableClock()
+                tfVfd = None
+
+def autostart(reason, **kwargs):
+        global tfVfd
+        global gReason
+        global mySession
+
+        if kwargs.has_key("session"):
+                global my_global_session
+                mySession = kwargs["session"]
+        else:
+                gReason = reason
+        controlTfVfd()
+
+def Plugins(**kwargs):
+        return [ PluginDescriptor(name="TopfieldVFD", description="Change VFD display settings", where = PluginDescriptor.WHERE_PLUGINMENU, fnc=main),
+                PluginDescriptor(where = [PluginDescriptor.WHERE_SESSIONSTART, PluginDescriptor.WHERE_AUTOSTART], fnc = autostart) ]
diff -Nur enigma2-nightly/lib/python/Plugins/Makefile.am enigma2-nightly.spark/lib/python/Plugins/Makefile.am
--- enigma2-nightly/lib/python/Plugins/Makefile.am	2010-08-11 18:16:49.670102868 +0800
+++ enigma2-nightly.spark/lib/python/Plugins/Makefile.am	2010-08-11 18:12:24.822769592 +0800
@@ -1,6 +1,6 @@
 installdir = $(pkglibdir)/python/Plugins
 
-SUBDIRS = Extensions SystemPlugins DemoPlugins
+SUBDIRS = Extensions SystemPlugins
 
 install_PYTHON =	\
 	__init__.py Plugin.py 
diff -Nur enigma2-nightly/lib/python/Plugins/SystemPlugins/Makefile.am enigma2-nightly.spark/lib/python/Plugins/SystemPlugins/Makefile.am
--- enigma2-nightly/lib/python/Plugins/SystemPlugins/Makefile.am	2010-08-11 18:16:49.685700971 +0800
+++ enigma2-nightly.spark/lib/python/Plugins/SystemPlugins/Makefile.am	2010-08-11 18:12:24.823596476 +0800
@@ -1,9 +1,9 @@
 installdir = $(pkglibdir)/python/Plugins/SystemPlugins
 
-SUBDIRS = SoftwareManager FrontprocessorUpgrade PositionerSetup Satfinder \
+SUBDIRS = SoftwareManager PositionerSetup Satfinder \
 	SkinSelector SatelliteEquipmentControl Videomode VideoTune Hotplug \
-	DefaultServicesScanner NFIFlash DiseqcTester CommonInterfaceAssignment \
-	CrashlogAutoSubmit CleanupWizard VideoEnhancement WirelessLan NetworkWizard \
+	DefaultServicesScanner DiseqcTester CommonInterfaceAssignment \
+	CrashlogAutoSubmit CleanupWizard VideoEnhancement VFD-Icons Tuxtxt NetworkWizard \
 	TempFanControl
 
 install_PYTHON =	\
diff -Nur enigma2-nightly/lib/python/Plugins/SystemPlugins/Tuxtxt/__init__.py enigma2-nightly.spark/lib/python/Plugins/SystemPlugins/Tuxtxt/__init__.py
--- enigma2-nightly/lib/python/Plugins/SystemPlugins/Tuxtxt/__init__.py	1970-01-01 08:00:00.000000000 +0800
+++ enigma2-nightly.spark/lib/python/Plugins/SystemPlugins/Tuxtxt/__init__.py	2010-08-11 18:12:24.824751250 +0800
@@ -0,0 +1,2 @@
+
+
diff -Nur enigma2-nightly/lib/python/Plugins/SystemPlugins/Tuxtxt/Makefile.am enigma2-nightly.spark/lib/python/Plugins/SystemPlugins/Tuxtxt/Makefile.am
--- enigma2-nightly/lib/python/Plugins/SystemPlugins/Tuxtxt/Makefile.am	1970-01-01 08:00:00.000000000 +0800
+++ enigma2-nightly.spark/lib/python/Plugins/SystemPlugins/Tuxtxt/Makefile.am	2010-08-11 18:12:24.825593961 +0800
@@ -0,0 +1,8 @@
+SUBDIRS = tuxtxt
+
+installdir = $(LIBDIR)/enigma2/python/Plugins/SystemPlugins/Tuxtxt
+
+install_PYTHON = \
+	__init__.py \
+	plugin.py
+
diff -Nur enigma2-nightly/lib/python/Plugins/SystemPlugins/Tuxtxt/plugin.py enigma2-nightly.spark/lib/python/Plugins/SystemPlugins/Tuxtxt/plugin.py
--- enigma2-nightly/lib/python/Plugins/SystemPlugins/Tuxtxt/plugin.py	1970-01-01 08:00:00.000000000 +0800
+++ enigma2-nightly.spark/lib/python/Plugins/SystemPlugins/Tuxtxt/plugin.py	2010-08-11 18:12:24.826689344 +0800
@@ -0,0 +1,78 @@
+from enigma import *
+from Screens.Screen import Screen
+from Plugins.Plugin import PluginDescriptor
+from Components.Sources.FrontendStatus import FrontendStatus
+from Components.TunerInfo import TunerInfo
+import os
+
+class ShellStarter(Screen):
+	skin = """
+		<screen position="0,0" size="720,576" title="TuxTXT" >
+		</screen>"""
+
+	def __init__(self, session, args = None):
+		print "__init"
+		self.skin = ShellStarter.skin
+		Screen.__init__(self, session)
+		#self.container=eConsoleAppContainer()
+		#self.container.appClosed.get().append(self.finished)
+		self.runapp()
+		
+	def runapp(self):
+		print "runappt"
+		service = self.session.nav.getCurrentService()
+		if service is not None:
+			self.info = service.info()
+		else:
+			self.info = None
+
+		#eDBoxLCD.getInstance().lock()
+		#eRCInput.getInstance().lock()
+		#fbClass.getInstance().lock()
+		#if self.container.execute("/usr/bin/tuxtxt "+self.getValue(iServiceInformation.sTXTPID)):
+		s="/usr/bin/tuxtxt "
+		s+=self.getValue(iServiceInformation.sTXTPID)
+		feInfo = service.frontendInfo()
+		feNumber = feInfo and feInfo.getFrontendInfo(iFrontendInformation.frontendNumber)
+		s+= " "
+		s+=str(feNumber)
+		s+=" &"
+		print s
+		try:
+			os.popen(s)
+		except OSError, e: 
+			print "OSError: ", e
+			#print "OSError"
+			#Why cant i use openWithCallback?
+			#from Screens.MessageBox import MessageBox
+			#def msgClosed(ret):
+			#	return
+			#self.session.openWithCallback(msgClosed, MessageBox, _("Swap needed"), MessageBox.TYPE_INFO)
+
+			self.finished(-1)
+		self.finished(-1)
+
+	def finished(self,retval):
+		print "finished"
+		#fbClass.getInstance().unlock()
+		#eRCInput.getInstance().unlock()
+		#eDBoxLCD.getInstance().unlock()
+		self.close()
+
+	def getValue(self, what):
+		print "getValue"
+		if self.info is None:
+			return ""
+		
+		v = "%d" % (self.info.getInfo(what))
+
+		return v
+
+
+def main(session, **kwargs):
+	print "main"
+	session.open(ShellStarter)
+
+def Plugins(**kwargs):
+	print "Plugins"
+	return PluginDescriptor(name="TuxTXT", description="Videotext", where = PluginDescriptor.WHERE_TELETEXT, fnc=main)
diff -Nur enigma2-nightly/lib/python/Plugins/SystemPlugins/VFD-Icons/__init__.py enigma2-nightly.spark/lib/python/Plugins/SystemPlugins/VFD-Icons/__init__.py
--- enigma2-nightly/lib/python/Plugins/SystemPlugins/VFD-Icons/__init__.py	1970-01-01 08:00:00.000000000 +0800
+++ enigma2-nightly.spark/lib/python/Plugins/SystemPlugins/VFD-Icons/__init__.py	2010-08-11 18:12:24.826689344 +0800
@@ -0,0 +1,2 @@
+
+
diff -Nur enigma2-nightly/lib/python/Plugins/SystemPlugins/VFD-Icons/LICENSE enigma2-nightly.spark/lib/python/Plugins/SystemPlugins/VFD-Icons/LICENSE
--- enigma2-nightly/lib/python/Plugins/SystemPlugins/VFD-Icons/LICENSE	1970-01-01 08:00:00.000000000 +0800
+++ enigma2-nightly.spark/lib/python/Plugins/SystemPlugins/VFD-Icons/LICENSE	2010-08-11 18:12:24.827756241 +0800
@@ -0,0 +1,9 @@
+This plugin is licensed under the Creative Commons 
+Attribution-NonCommercial-ShareAlike 3.0 Unported 
+License. To view a copy of this license, visit
+http://creativecommons.org/licenses/by-nc-sa/3.0/ or send a letter to Creative
+Commons, 559 Nathan Abbott Way, Stanford, California 94305, USA.
+
+This plugin is NOT free software. It is open source, you are allowed to
+modify it (if you keep the license), but it may not be commercially 
+distributed other than under the conditions noted above.
diff -Nur enigma2-nightly/lib/python/Plugins/SystemPlugins/VFD-Icons/Makefile.am enigma2-nightly.spark/lib/python/Plugins/SystemPlugins/VFD-Icons/Makefile.am
--- enigma2-nightly/lib/python/Plugins/SystemPlugins/VFD-Icons/Makefile.am	1970-01-01 08:00:00.000000000 +0800
+++ enigma2-nightly.spark/lib/python/Plugins/SystemPlugins/VFD-Icons/Makefile.am	2010-08-11 18:12:24.828649225 +0800
@@ -0,0 +1,9 @@
+installdir = $(pkglibdir)/python/Plugins/SystemPlugins/VFD-Icons
+
+SUBDIRS = meta
+
+install_PYTHON =	\
+	__init__.py \
+	plugin.py
+
+dist_install_DATA = LICENSE
diff -Nur enigma2-nightly/lib/python/Plugins/SystemPlugins/VFD-Icons/meta/Makefile.am enigma2-nightly.spark/lib/python/Plugins/SystemPlugins/VFD-Icons/meta/Makefile.am
--- enigma2-nightly/lib/python/Plugins/SystemPlugins/VFD-Icons/meta/Makefile.am	1970-01-01 08:00:00.000000000 +0800
+++ enigma2-nightly.spark/lib/python/Plugins/SystemPlugins/VFD-Icons/meta/Makefile.am	2010-08-11 18:12:24.829480337 +0800
@@ -0,0 +1,3 @@
+installdir = $(datadir)/meta/
+
+dist_install_DATA = plugin_vfd-icons.xml
diff -Nur enigma2-nightly/lib/python/Plugins/SystemPlugins/VFD-Icons/meta/plugin_vfd-icons.xml enigma2-nightly.spark/lib/python/Plugins/SystemPlugins/VFD-Icons/meta/plugin_vfd-icons.xml
--- enigma2-nightly/lib/python/Plugins/SystemPlugins/VFD-Icons/meta/plugin_vfd-icons.xml	1970-01-01 08:00:00.000000000 +0800
+++ enigma2-nightly.spark/lib/python/Plugins/SystemPlugins/VFD-Icons/meta/plugin_vfd-icons.xml	2010-08-11 18:12:24.829480337 +0800
@@ -0,0 +1,27 @@
+<default>
+	  <prerequisites>
+                    <tag type="System" />
+	  </prerequisites>
+          <info language="en">
+                    <author>Team Ducktales</author>
+                    <name>VFD-Icons</name>
+                    <packagename>enigma2-plugin-systemplugins-vfd-icons</packagename>
+		    <packagetype>internal</packagetype> <!-- internal/public , public is default, internal metas are not displayed inside plugin manager -->
+                    <shortdescription>Internal firmware updater.</shortdescription>
+                    <description>This system tool is internally used to program the hardware with firmware updates.
+                    </description>
+	  </info>
+          <info language="de">
+                    <author>Dream Multimedia</author>
+                    <name>FrontprocessorUpgrade</name>
+                    <packagename>enigma2-plugin-systemplugins-frontprocessorupgrade</packagename>
+		    <packagetype>internal</packagetype> <!-- internal/public , public is default, internal metas are not displayed inside plugin manager -->
+                    <shortdescription>Interner Firmware-Upgrader.</shortdescription>
+                    <description>Dieses Systemtool wird intern benutzt um Firmware-Upgrades für die Hardware aufzuspielen.
+                    </description>
+          </info>
+	  <files type="package"> <!-- without version, without .ipk -->
+		<file type="package" name="enigma2-plugin-systemplugins-frontprocessorupgrade" />
+	</files>
+
+</default>
diff -Nur enigma2-nightly/lib/python/Plugins/SystemPlugins/VFD-Icons/plugin.py enigma2-nightly.spark/lib/python/Plugins/SystemPlugins/VFD-Icons/plugin.py
--- enigma2-nightly/lib/python/Plugins/SystemPlugins/VFD-Icons/plugin.py	1970-01-01 08:00:00.000000000 +0800
+++ enigma2-nightly.spark/lib/python/Plugins/SystemPlugins/VFD-Icons/plugin.py	2010-08-11 18:12:24.830788191 +0800
@@ -0,0 +1,154 @@
+# -*- coding: utf-8 -*-
+from Plugins.Plugin import PluginDescriptor
+import ServiceReference
+from enigma import iPlayableService, eTimer, eServiceCenter, iServiceInformation
+from enigma import evfd
+import time
+from Components.ServiceEventTracker import ServiceEventTracker, InfoBarBase
+
+class VFDIcons:
+	def __init__(self, session):
+		# Save Session&Servicelist, Create Timer, Init Services
+		self.session = session
+		self.service = None
+		self.onClose = [ ]
+		self.__event_tracker = ServiceEventTracker(screen=self,eventmap=
+			{
+				iPlayableService.evUpdatedInfo: self.__evUpdatedInfo,
+				iPlayableService.evUpdatedEventInfo: self.__evUpdatedEventInfo,
+				iPlayableService.evVideoSizeChanged: self.__evVideoSizeChanged,
+				iPlayableService.evSeekableStatusChanged: self.__evSeekableStatusChanged,
+				iPlayableService.evStart: self.__evStart,
+				
+			})
+		session.nav.record_event.append(self.gotRecordEvent)
+		self.mp3Available = False
+		self.dolbyAvailable = False
+		
+	def __evStart(self):
+		print "[__evStart]"
+		self.__evSeekableStatusChanged()	
+		
+	def __evUpdatedInfo(self):
+		print "[__evUpdatedInfo]"
+		self.checkAudioTracks()
+		self.writeChannelName()
+		self.showCrypted()
+		self.showDolby()
+		self.showMp3()
+		
+	def writeChannelName(self):
+		print "[writeChannelName]"
+		servicename = ""
+		currPlay = self.session.nav.getCurrentService()
+		if currPlay != None and self.mp3Available:
+			# show the MP3 tag
+			servicename = currPlay.info().getInfoString(iServiceInformation.sTagTitle)
+		else:
+			# show the service name
+			self.service = self.session.nav.getCurrentlyPlayingServiceReference()
+			if not self.service is None:
+				service = self.service.toCompareString()
+				servicename = ServiceReference.ServiceReference(service).getServiceName().replace('\xc2\x87', '').replace('\xc2\x86', '').ljust(16)
+				subservice = self.service.toString().split("::")
+				if subservice[0].count(':') == 9:
+					servicename = subservice[1].replace('\xc2\x87', '').replace('\xc3\x9f', 'ss').replace('\xc2\x86', '').ljust(16)
+				else:
+					servicename=servicename
+			else:
+				print "no Service found"
+		
+		print "vfd display text:", servicename[0:63]
+		evfd.getInstance().vfd_write_string(servicename[0:63])
+		return 1
+		
+	def showCrypted(self):
+		print "[showCrypted]"
+		service=self.session.nav.getCurrentService()
+		if service is not None:
+			info=service.info()
+			crypted = info and info.getInfo(iServiceInformation.sIsCrypted) or -1
+			if crypted == 1 : #set crypt symbol
+				evfd.getInstance().vfd_set_icon(0x13,1)
+			else:
+				evfd.getInstance().vfd_set_icon(0x13,0)
+	
+	def checkAudioTracks(self):
+		self.dolbyAvailable = False
+		self.mp3Available = False
+		service=self.session.nav.getCurrentService()
+		if service is not None:
+			audio = service.audioTracks()
+			if audio:
+				n = audio.getNumberOfTracks()
+				for x in range(n):
+					i = audio.getTrackInfo(x)
+					description = i.getDescription();
+					if description.find("MP3") != -1:
+						self.mp3Available = True
+					if description.find("AC3") != -1 or description.find("DTS") != -1:
+						self.dolbyAvailable = True
+	
+	def showDolby(self):
+		print "[showDolby]"
+		if self.dolbyAvailable:
+			evfd.getInstance().vfd_set_icon(0x17,1)
+		else:
+			evfd.getInstance().vfd_set_icon(0x17,0)
+		
+	def showMp3(self):
+		print "[showMp3]"
+		if self.mp3Available:
+			evfd.getInstance().vfd_set_icon(0x15,1)
+		else:
+			evfd.getInstance().vfd_set_icon(0x15,0)
+		
+	def __evUpdatedEventInfo(self):
+		print "[__evUpdatedEventInfo]"
+		
+	def getSeekState(self):
+		service = self.session.nav.getCurrentService()
+		if service is None:
+			return False
+		seek = service.seek()
+		if seek is None:
+			return False
+		return seek.isCurrentlySeekable()
+		
+	def __evSeekableStatusChanged(self):
+		print "[__evSeekableStatusChanged]"
+		if self.getSeekState():
+			evfd.getInstance().vfd_set_icon(0x1A,1)
+		else:
+			evfd.getInstance().vfd_set_icon(0x1A,0)
+		
+	def __evVideoSizeChanged(self):
+		print "[__evVideoSizeChanged]"
+		service=self.session.nav.getCurrentService()
+		if service is not None:
+			info=service.info()
+			height = info and info.getInfo(iServiceInformation.sVideoHeight) or -1
+			if height > 576 : #set HD symbol
+				evfd.getInstance().vfd_set_icon(0x11,1)
+			else:
+				evfd.getInstance().vfd_set_icon(0x11,0)
+		
+	def gotRecordEvent(self, service, event):
+		recs = self.session.nav.getRecordings()
+		nrecs = len(recs)
+		if nrecs > 0: #set rec symbol
+			evfd.getInstance().vfd_set_icon(0x1e,1)
+		else:
+			evfd.getInstance().vfd_set_icon(0x1e,0)
+		
+
+VFDIconsInstance = None
+
+def main(session, **kwargs):
+	# Create Instance if none present, show Dialog afterwards
+	global VFDIconsInstance
+	if VFDIconsInstance is None:
+		VFDIconsInstance = VFDIcons(session)
+
+def Plugins(**kwargs):
+ 	return [ PluginDescriptor(name="VFDIcons", description="Icons in VFD", where = PluginDescriptor.WHERE_SESSIONSTART, fnc=main ) ]
diff -Nur enigma2-nightly/lib/python/Plugins/SystemPlugins/Videomode/plugin.py enigma2-nightly.spark/lib/python/Plugins/SystemPlugins/Videomode/plugin.py
--- enigma2-nightly/lib/python/Plugins/SystemPlugins/Videomode/plugin.py	2010-08-11 18:16:49.731942849 +0800
+++ enigma2-nightly.spark/lib/python/Plugins/SystemPlugins/Videomode/plugin.py	2010-08-11 18:12:24.831593678 +0800
@@ -85,7 +85,16 @@
 		elif config.av.aspect.value == "4_3":
 			self.list.append(getConfigListEntry(_("Display 16:9 content as"), config.av.policy_169))
 
-#		if config.av.videoport.value == "DVI":
+#--->
+#-#		if config.av.videoport.value == "DVI":
+#---<
+#+++>
+		if config.av.videoport.value == "Component":
+			self.list.append(getConfigListEntry(_("Color Format"), config.av.colorformat_yuv))
+		if config.av.videoport.value == "HDMI":
+			self.list.append(getConfigListEntry(_("Color Format"), config.av.colorformat_hdmi))
+			self.list.append(getConfigListEntry(_("Audio Source"), config.av.hdmi_audio_source))
+#+++<
 #			self.list.append(getConfigListEntry(_("Allow Unsupported Modes"), config.av.edid_override))
 		if config.av.videoport.value == "Scart":
 			self.list.append(getConfigListEntry(_("Color Format"), config.av.colorformat))
diff -Nur enigma2-nightly/lib/python/Plugins/SystemPlugins/Videomode/VideoHardware.py enigma2-nightly.spark/lib/python/Plugins/SystemPlugins/Videomode/VideoHardware.py
--- enigma2-nightly/lib/python/Plugins/SystemPlugins/Videomode/VideoHardware.py	2010-08-11 18:16:49.727750552 +0800
+++ enigma2-nightly.spark/lib/python/Plugins/SystemPlugins/Videomode/VideoHardware.py	2010-08-11 18:12:24.835722785 +0800
@@ -2,7 +2,6 @@
 from Components.config import config, ConfigSelection, ConfigSubDict, ConfigYesNo
 
 from Tools.CList import CList
-from Tools.HardwareInfo import HardwareInfo
 
 # The "VideoHardware" is the interface to /proc/stb/video.
 # It generates hotplug events, and gives you the list of 
@@ -13,93 +12,48 @@
 
 	modes = { }  # a list of (high-level) modes for a certain port.
 
-	rates["PAL"] =			{ "50Hz":		{ 50: "pal" },
-								"60Hz":		{ 60: "pal60" },
-								"multi":	{ 50: "pal", 60: "pal60" } }
+	rates["PAL"] =			{ "50Hz":		{ 50: "pal" } }
 
-	rates["NTSC"] =			{ "60Hz": 	{ 60: "ntsc" } }
+	rates["576i"] =			{ "50Hz": 	{ 50: "576i50" } }
 
-	rates["Multi"] =		{ "multi": 	{ 50: "pal", 60: "ntsc" } }
-
-	rates["480i"] =			{ "60Hz": 	{ 60: "480i" } }
-
-	rates["576i"] =			{ "50Hz": 	{ 50: "576i" } }
-
-	rates["480p"] =			{ "60Hz": 	{ 60: "480p" } }
-
-	rates["576p"] =			{ "50Hz": 	{ 50: "576p" } }
+	rates["576p"] =			{ "50Hz": 	{ 50: "576p50" } }
 
 	rates["720p"] =			{ "50Hz": 	{ 50: "720p50" },
-								"60Hz": 	{ 60: "720p" },
-								"multi": 	{ 50: "720p50", 60: "720p" } }
+					  "60Hz": 	{ 60: "720p60" } }
 
-	rates["1080i"] =		{ "50Hz":		{ 50: "1080i50" },
-								"60Hz":		{ 60: "1080i" },
-								"multi":	{ 50: "1080i50", 60: "1080i" } }
+	rates["1080i"] =		{ "50Hz":	{ 50: "1080i50" },
+					  "60Hz":	{ 60: "1080i60" } }
+
+	rates["1080p"] =		{ "23Hz":	{ 50: "1080p23" },
+					  "24Hz":	{ 60: "1080p24" },
+					  "25Hz":	{ 60: "1080p25" },
+					  "29Hz":	{ 60: "1080p29" },
+					  "30Hz":	{ 60: "1080p30" } }
 
 	rates["PC"] = { 
-		"1024x768": { 60: "1024x768" }, # not possible on DM7025
-		"800x600" : { 60: "800x600" },  # also not possible
-		"720x480" : { 60: "720x480" },
-		"720x576" : { 60: "720x576" },
-		"1280x720": { 60: "1280x720" },
-		"1280x720 multi": { 50: "1280x720_50", 60: "1280x720" },
-		"1920x1080": { 60: "1920x1080"},
-		"1920x1080 multi": { 50: "1920x1080", 60: "1920x1080_50" },
-		"1280x1024" : { 60: "1280x1024"},
-		"1366x768" : { 60: "1366x768"},
-		"1366x768 multi" : { 50: "1366x768", 60: "1366x768_50" },
-		"1280x768": { 60: "1280x768" },
-		"640x480" : { 60: "640x480" }
+		"1024x768": 		{ 60: "1024x768_60", 70: "1024x768_70", 75: "1024x768_75", 90: "1024x768_90", 100: "1024x768_100" }, #43 60 70 72 75 90 100
+		"1280x1024" : 		{ 60: "1280x1024_60", 70: "1280x1024_70", 75: "1280x1024_75" }, #43 47 60 70 74 75
+		"1600x1200": 		{ 60: "1600x1200_60" }, #60 66 76
+
 	}
 
-	modes["Scart"] = ["PAL", "NTSC", "Multi"]
-	modes["YPbPr"] = ["720p", "1080i", "576p", "480p", "576i", "480i"]
-	modes["DVI"] = ["720p", "1080i", "576p", "480p", "576i", "480i"]
-	modes["DVI-PC"] = ["PC"]
 
-	widescreen_modes = set(["720p", "1080i"])
+	modes["Scart"] = ["PAL"]
+	modes["Component"] = ["576i", "576p", "720p", "1080i", "1080p"]
+	modes["HDMI"]  = ["576i", "576p", "720p", "1080i", "1080p"]
+	modes["HDMI-PC"] = ["PC"]
 
-	def getOutputAspect(self):
-		ret = (16,9)
-		port = config.av.videoport.value
-		if port not in config.av.videomode:
-			print "current port not available in getOutputAspect!!! force 16:9"
-		else:
-			mode = config.av.videomode[port].value
-			force_widescreen = self.isWidescreenMode(port, mode)
-			is_widescreen = force_widescreen or config.av.aspect.value in ("16_9", "16_10")
-			is_auto = config.av.aspect.value == "auto"
-			if is_widescreen:
-				if force_widescreen:
-					pass
-				else:
-					aspect = {"16_9": "16:9", "16_10": "16:10"}[config.av.aspect.value]
-					if aspect == "16:10":
-						ret = (16,10)
-			elif is_auto:
-				try:
-					aspect_str = open("/proc/stb/vmpeg/0/aspect", "r").read()
-					if aspect_str == "1": # 4:3
-						ret = (4,3)
-				except IOError:
-					pass
-			else:  # 4:3
-				ret = (4,3)
-		return ret
+	widescreen_modes = set(["576i", "576p", "720p", "1080i", "1080p"])
 
 	def __init__(self):
 		self.last_modes_preferred =  [ ]
 		self.on_hotplug = CList()
+		self.standby = False
 		self.current_mode = None
 		self.current_port = None
 
 		self.readAvailableModes()
 
-		if self.modes.has_key("DVI-PC") and not self.getModeList("DVI-PC"):
-			print "remove DVI-PC because of not existing modes"
-			del self.modes["DVI-PC"]
-
 		self.createConfig()
 #		self.on_hotplug.append(self.createConfig)
 
@@ -108,11 +62,20 @@
 		# take over old AVSwitch component :)
 		from Components.AVSwitch import AVSwitch
 #		config.av.colorformat.notifiers = [ ] 
+
 		config.av.aspectratio.notifiers = [ ]
 		config.av.tvsystem.notifiers = [ ]
 		config.av.wss.notifiers = [ ]
-		AVSwitch.getOutputAspect = self.getOutputAspect
+		AVSwitch.setInput = self.AVSwitchSetInput
 
+		config.av.colorformat_hdmi = ConfigSelection(choices = {"hdmi_rgb": _("RGB"), "hdmi_yuv": _("YUV"), "hdmi_422": _("422")}, default="hdmi_rgb")
+		config.av.colorformat_yuv = ConfigSelection(choices = {"yuv": _("YUV")}, default="yuv")
+#		config.av.hdmi_audio_source = ConfigSelection(choices = {"pcm": _("PCM"), "spdif": _("SPDIF"), "8ch": _("8Ch"), "none": _("None")}, default="pcm")
+		config.av.hdmi_audio_source = ConfigSelection(choices = {"pcm": _("PCM"), "spdif": _("SPDIF")}, default="pcm")
+
+		config.av.colorformat_hdmi.addNotifier(self.setHDMIColor)
+		config.av.colorformat_yuv.addNotifier(self.setYUVColor)
+		config.av.hdmi_audio_source.addNotifier(self.setHDMIAudioSource)
 		config.av.aspect.addNotifier(self.updateAspect)
 		config.av.wss.addNotifier(self.updateAspect)
 		config.av.policy_169.addNotifier(self.updateAspect)
@@ -123,6 +86,12 @@
 #		self.timer.callback.append(self.readPreferredModes)
 #		self.timer.start(1000)
 
+		config.av.colorformat.addNotifier(self.updateFastblank) 
+
+	def AVSwitchSetInput(self, mode):
+		self.standby = mode == "SCART"
+		self.updateStandby()
+
 	def readAvailableModes(self):
 		try:
 			modes = open("/proc/stb/video/videomode_choices").read()[:-1]
@@ -131,6 +100,7 @@
 			self.modes_available = [ ]
 			return
 		self.modes_available = modes.split(' ')
+		print self.modes_available
 
 	def readPreferredModes(self):
 		try:
@@ -142,20 +112,23 @@
 
 		if self.modes_preferred != self.last_modes_preferred:
 			self.last_modes_preferred = self.modes_preferred
-			print "hotplug on dvi"
-			self.on_hotplug("DVI") # must be DVI
+			print "hotplug on hdmi"
+			self.on_hotplug("HDMI") # must be DVI
 
 	# check if a high-level mode with a given rate is available.
 	def isModeAvailable(self, port, mode, rate):
 		rate = self.rates[mode][rate]
 		for mode in rate.values():
 			# DVI modes must be in "modes_preferred"
-#			if port == "DVI":
+			if port == "HDMI-PC":
+				return True
 #				if mode not in self.modes_preferred and not config.av.edid_override.value:
 #					print "no, not preferred"
 #					return False
 			if mode not in self.modes_available:
+				#print "isModeAvailable", mode, "false"
 				return False
+		#print "isModeAvailable", mode, "true"
 		return True
 
 	def isWidescreenMode(self, port, mode):
@@ -189,8 +162,11 @@
 			open("/etc/videomode", "w").write(mode_50) # use 50Hz mode (if available) for booting
 		except IOError:
 			print "writing initial videomode to /etc/videomode failed."
-
+		#call setResolution() with -1,-1 to read the new scrren dimesions without changing the framebuffer resolution
+		from enigma import gFBDC
+		gFBDC.getInstance().setResolution(-1, -1)
 		self.updateAspect(None)
+		self.updateColor(port)
 
 	def saveMode(self, port, mode, rate):
 		print "saveMode", port, mode, rate
@@ -206,7 +182,7 @@
 		return True
 
 	def isPortUsed(self, port):
-		if port == "DVI":
+		if port == "HDMI":
 			self.readPreferredModes()
 			return len(self.modes_preferred) != 0
 		else:
@@ -229,29 +205,20 @@
 		return res
 
 	def createConfig(self, *args):
-		hw_type = HardwareInfo().get_device_name()
-		lst = []
+		# create list of output ports
+		portlist = self.getPortList()
 
+		# create list of available modes
+		config.av.videoport = ConfigSelection(choices = [(port, _(port)) for port in portlist])
 		config.av.videomode = ConfigSubDict()
 		config.av.videorate = ConfigSubDict()
 
-		# create list of output ports
-		portlist = self.getPortList()
 		for port in portlist:
-			descr = port
-			if descr == 'DVI' and hw_type == 'dm500hd':
-				descr = 'HDMI'
-			elif descr == 'DVI-PC' and hw_type == 'dm500hd':
-				descr = 'HDMI-PC'
-			lst.append((port, descr))
-
-			# create list of available modes
 			modes = self.getModeList(port)
 			if len(modes):
 				config.av.videomode[port] = ConfigSelection(choices = [mode for (mode, rates) in modes])
 			for (mode, rates) in modes:
 				config.av.videorate[mode] = ConfigSelection(choices = rates)
-		config.av.videoport = ConfigSelection(choices = lst)
 
 	def setConfiguredMode(self):
 		port = config.av.videoport.value
@@ -297,17 +264,15 @@
 
 		force_widescreen = self.isWidescreenMode(port, mode)
 
-		is_widescreen = force_widescreen or config.av.aspect.value in ("16_9", "16_10")
+		is_widescreen = force_widescreen or config.av.aspect.value in ["16_9", "16_10"]
 		is_auto = config.av.aspect.value == "auto"
-		policy2 = "policy" # use main policy
 
 		if is_widescreen:
 			if force_widescreen:
 				aspect = "16:9"
 			else:
 				aspect = {"16_9": "16:9", "16_10": "16:10"}[config.av.aspect.value]
-			policy = {"pillarbox": "panscan", "panscan": "letterbox", "nonlinear": "nonlinear", "scale": "bestfit"}[config.av.policy_43.value]
-			policy2 = {"letterbox": "letterbox", "panscan": "panscan", "scale": "bestfit"}[config.av.policy_169.value]
+			policy = {"pillarbox": "letterbox", "panscan": "panscan", "nonlinear": "nonlinear", "scale": "bestfit"}[config.av.policy_43.value]
 		elif is_auto:
 			aspect = "any"
 			policy = "bestfit"
@@ -320,14 +285,70 @@
 		else:
 			wss = "auto"
 
-		print "-> setting aspect, policy, policy2, wss", aspect, policy, policy2, wss
+		print "-> setting aspect, policy, wss", aspect, policy, wss
 		open("/proc/stb/video/aspect", "w").write(aspect)
 		open("/proc/stb/video/policy", "w").write(policy)
 		open("/proc/stb/denc/0/wss", "w").write(wss)
-		try:
-			open("/proc/stb/video/policy2", "w").write(policy2)
-		except IOError:
-			pass
+		self.updateSlowblank()
+		self.updateFastblank()
+
+	def updateSlowblank(self):
+		if self.standby:
+			from Components.SystemInfo import SystemInfo
+			if SystemInfo["ScartSwitch"]:
+				input = "scart"
+				sb = "vcr"
+			else:
+				input = "off"
+				sb = "0"
+		else:
+			input = "encoder"
+			sb = "auto"
+
+		open("/proc/stb/avs/0/sb", "w").write(sb)
+		open("/proc/stb/avs/0/input", "w").write(input)
+
+	def updateStandby(self):
+		self.updateSlowblank()
+		self.updateFastblank()
+
+	def updateFastblank(self, *args):
+		if self.standby:
+			from Components.SystemInfo import SystemInfo
+			if SystemInfo["ScartSwitch"]:
+				fb = "vcr"
+			else:
+				fb = "low"
+		else:
+			if self.current_port == "Scart" and config.av.colorformat.value == "rgb":
+				fb = "high"
+			else:
+				fb = "low"
+		open("/proc/stb/avs/0/fb", "w").write(fb)
+
+	def setHDMIColor(self, configElement):
+		map = {"hdmi_rgb": 0, "hdmi_yuv": 1, "hdmi_422": 2}
+		open("/proc/stb/avs/0/colorformat", "w").write(configElement.value)
+
+	def setYUVColor(self, configElement):
+		map = {"yuv": 0}
+		open("/proc/stb/avs/0/colorformat", "w").write(configElement.value)
+
+	def setHDMIAudioSource(self, configElement):
+		open("/proc/stb/hdmi/audio_source", "w").write(configElement.value)
+
+
+	def updateColor(self, port):
+		print "updateColor: ", port
+		if port == "HDMI":
+			self.setHDMIColor(config.av.colorformat_hdmi)
+		elif port == "Component":
+			self.setYUVColor(config.av.colorformat_yuv)
+		elif port == "Scart":
+			map = {"cvbs": 0, "rgb": 1, "svideo": 2, "yuv": 3}
+			from enigma import eAVSwitch
+			eAVSwitch.getInstance().setColorFormat(map[config.av.colorformat.value])
+
 
 config.av.edid_override = ConfigYesNo(default = False)
 video_hw = VideoHardware()
diff -Nur enigma2-nightly/lib/python/Screens/DefaultWizard.py enigma2-nightly.spark/lib/python/Screens/DefaultWizard.py
--- enigma2-nightly/lib/python/Screens/DefaultWizard.py	2010-08-11 18:16:49.738093077 +0800
+++ enigma2-nightly.spark/lib/python/Screens/DefaultWizard.py	2010-08-11 18:12:24.836463284 +0800
@@ -25,8 +25,13 @@
 		self["arrowup2"] = MovingPixmap()
 	
 	def setDirectory(self):
-		os_system("mount %s %s" % (resolveFilename(SCOPE_DEFAULTPARTITION), resolveFilename(SCOPE_DEFAULTPARTITIONMOUNTDIR)))
-		self.directory = resolveFilename(SCOPE_DEFAULTPARTITIONMOUNTDIR)
+#--->
+#-		os_system("mount %s %s" % (resolveFilename(SCOPE_DEFAULTPARTITION), resolveFilename(SCOPE_DEFAULTPARTITIONMOUNTDIR)))
+#-		self.directory = resolveFilename(SCOPE_DEFAULTPARTITIONMOUNTDIR)
+#---<
+#+++>
+		self.directory = resolveFilename(SCOPE_DEFAULTDIR)
+#+++<
 		self.xmlfile = "defaultwizard.xml"
         
 	def markDone(self):
diff -Nur enigma2-nightly/lib/python/Screens/EventView.py enigma2-nightly.spark/lib/python/Screens/EventView.py
--- enigma2-nightly/lib/python/Screens/EventView.py	2010-08-11 18:16:49.738781632 +0800
+++ enigma2-nightly.spark/lib/python/Screens/EventView.py	2010-08-11 18:12:24.902529942 +0800
@@ -146,6 +146,7 @@
 
 		self.setTitle(event.getEventName())
 		self["epg_description"].setText(text)
+		self["EventInfo"].setText(text)
 		self["datetime"].setText(event.getBeginTimeString())
 		self["duration"].setText(_("%d min")%(event.getDuration()/60))
 		self["key_red"].setText("")
diff -Nur enigma2-nightly/lib/python/Screens/InfoBarGenerics.py enigma2-nightly.spark/lib/python/Screens/InfoBarGenerics.py
--- enigma2-nightly/lib/python/Screens/InfoBarGenerics.py	2010-08-11 18:16:49.740753941 +0800
+++ enigma2-nightly.spark/lib/python/Screens/InfoBarGenerics.py	2010-08-11 18:12:24.859887129 +0800
@@ -44,6 +44,10 @@
 # hack alert!
 from Menu import MainMenu, mdom
 
+#+++>
+txtIsStarting = False
+#+++<
+
 class InfoBarDish:
 	def __init__(self):
 		self.dishDialog = self.session.instantiateDialog(Dish)
@@ -88,6 +92,9 @@
 	STATE_HIDING = 1
 	STATE_SHOWING = 2
 	STATE_SHOWN = 3
+#+++>
+	STATE_EPG = 4
+#+++<
 
 	def __init__(self):
 		self["ShowHideActions"] = ActionMap( ["InfobarShowHideActions"] ,
@@ -138,12 +145,34 @@
 		if self.__state == self.STATE_SHOWN:
 			self.hide()
 
+#+++>
+	def epg(self): 
+		self.__state = self.STATE_EPG 
+		self.hide() 
+		self.hideTimer.stop() 
+		self.openEventView() 
+#+++<
+
 	def toggleShow(self):
-		if self.__state == self.STATE_SHOWN:
-			self.hide()
-			self.hideTimer.stop()
-		elif self.__state == self.STATE_HIDDEN:
-			self.show()
+#--->
+#-		if self.__state == self.STATE_SHOWN:
+#-			self.hide()
+#-			self.hideTimer.stop()
+#-		elif self.__state == self.STATE_HIDDEN:
+#-			self.show()
+#---<
+#+++>
+		if self.__state == self.STATE_SHOWN: 
+			print "self.STATE_SHOWN" 
+			self.epg() 
+		elif self.__state == self.STATE_HIDDEN: 
+			print "self.STATE_HIDDEN" 
+			self.show() 
+		elif self.__state == self.STATE_EPG: 
+			print "self.STATE_EPG" 
+			self.hide() 
+			self.hideTimer.stop() 
+#+++<
 
 	def lockShow(self):
 		self.__locked = self.__locked + 1
@@ -1326,7 +1355,12 @@
 
 	def updateExtensions(self):
 		self.extensionsList = []
-		self.availableKeys = [ "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "red", "green", "yellow", "blue" ]
+#--->
+#-		self.availableKeys = [ "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "red", "green", "yellow", "blue" ]
+#---<
+#+++>
+		self.availableKeys = [ "red", "green", "yellow", "blue", "1", "2", "3", "4", "5", "6", "7", "8", "9", "0" ]
+#+++<
 		self.extensionKeys = {}
 		for x in self.list:
 			if x[0] == self.EXTENSION_SINGLE:
@@ -1403,6 +1437,18 @@
 		job_manager.in_background = in_background
 
 # depends on InfoBarExtensions
+
+class InfoBarSleepTimer:
+	def __init__(self):
+		self.addExtension((self.getSleepTimerName, self.showSleepTimerSetup, lambda: True), "1")
+
+	def getSleepTimerName(self):
+		return _("Sleep Timer")
+
+	def showSleepTimerSetup(self):
+		from Screens.SleepTimerEdit import SleepTimerEdit
+		self.session.open(SleepTimerEdit)
+
 class InfoBarPiP:
 	def __init__(self):
 		try:
@@ -1793,6 +1839,153 @@
 			self.audioChannel.selectChannel(mode[1])
 		del self.audioChannel
 
+#+++>
+class InfoBarExtendedAudioSelection:
+	STATE_HIDDEN = 0 
+	STATE_AUDIO = 1 
+	STATE_SUBSERVICE = 2 
+
+	def __init__(self):
+		self["ExtendedAudioSelectionAction"] = HelpableActionMap(self, "InfobarExtendedAudioSelectionActions",
+			{
+				"audioSelection": (self.EXtoggleYellow, _("Audio Options...")),
+			})
+		self.__state = self.STATE_HIDDEN 
+
+	def EXdoAudio(self): 
+		self.__state = self.STATE_AUDIO 
+		self.EXaudioSelection() 
+
+	def EXdoSubService(self): 
+		self.__state = self.STATE_SUBSERVICE 
+		self.subserviceSelection() 
+
+	def EXdoHide(self): 
+		self.__state = self.STATE_HIDDEN 
+
+	def EXtoggleYellow(self, arg=""): 
+		print self.__state 
+		if self.__state == self.STATE_HIDDEN: 
+			print "self.STATE_HIDDEN" 
+			self.EXdoAudio() 
+		elif self.__state == self.STATE_AUDIO: 
+			print "self.STATE_AUDIO" 
+			self.EXdoSubService() 
+		elif self.__state == self.STATE_SUBSERVICE: 
+			print "self.STATE_SUBSERVICE" 
+			self.EXdoHide() 
+
+	def EXaudioSelection(self):
+		service = self.session.nav.getCurrentService()
+		self.audioTracks = audio = service and service.audioTracks()
+		n = audio and audio.getNumberOfTracks() or 0
+		tlist = []
+		if n > 0:
+			self.audioChannel = service.audioChannel()
+
+			for x in range(n):
+				i = audio.getTrackInfo(x)
+				language = i.getLanguage()
+				description = i.getDescription()
+
+				if LanguageCodes.has_key(language):
+					language = LanguageCodes[language][0]
+
+				if len(description):
+					description += " (" + language + ")"
+				else:
+					description = language
+
+				tlist.append((description, x))
+
+			tlist.sort(key=lambda x: x[0])
+
+			selectedAudio = self.audioTracks.getCurrentTrack()
+
+			selection = 0
+
+			for x in tlist:
+				if x[1] != selectedAudio:
+					selection += 1
+				else:
+					break
+
+			if SystemInfo["CanDownmixAC3"]:
+				tlist = [(_("AC3 downmix") + " - " +[_("Off"), _("On")][config.av.downmix_ac3.value and 1 or 0], "CALLFUNC", self.EXchangeAC3Downmix),
+					([_("Left"), _("Stereo"), _("Right")][self.audioChannel.getCurrentChannel()], "mode"),
+					(_("Subservice"), "subservice"),#"CALLFUNC", self.toggleYellow), 
+					("--", "")] + tlist
+				keys = [ "red", "green", "yellow", "", "1", "2", "3", "4", "5", "6", "7", "8", "9", "0"] + [""]*n
+				selection += 4
+			else:
+				tlist = [([_("Left"), _("Stereo"), _("Right")][self.audioChannel.getCurrentChannel()], "mode"), (_("Subservice"), "subservice"), ("--", "")] + tlist
+				keys = [ "red", "yellow", "", "1", "2", "3", "4", "5", "6", "7", "8", "9", "0"] + [""]*n
+				selection += 3
+			self.session.openWithCallback(self.EXaudioSelected, ChoiceBox, title=_("Select audio track"), list = tlist, selection = selection, keys = keys)
+		else:
+			del self.audioTracks
+
+	def EXchangeAC3Downmix(self, arg):
+		choicelist = self.session.current_dialog["list"]
+		list = choicelist.list
+		t = list[0][1]
+		list[0][1]=(t[0], t[1], t[2], t[3], t[4], t[5], t[6],
+			_("AC3 downmix") + " - " +[_("On"), _("Off")][config.av.downmix_ac3.value and 1 or 0])
+		choicelist.setList(list)
+		if config.av.downmix_ac3.value:
+			config.av.downmix_ac3.value = False
+		else:
+			config.av.downmix_ac3.value = True
+		config.av.downmix_ac3.save()
+
+	def EXaudioSelected(self, audio):
+		if audio is not None:
+			if isinstance(audio[1], str):
+				if audio[1] == "subservice":
+					service = self.session.nav.getCurrentService()
+					#subservices = service and service.subServices()
+					try:
+						del self.audioChannel
+					except AttributeError:
+						print "no such Attribute"
+					try:
+						del self.audioTracks
+					except AttributeError:
+						print "no such Attribute"
+					if service.subServices().getNumberOfSubservices() > 0:
+						#del self.audioChannel
+						#del self.audioTracks
+						self.EXtoggleYellow()
+
+				elif audio[1] == "mode":
+					keys = ["red", "green", "yellow"]
+					selection = self.audioChannel.getCurrentChannel()
+					tlist = [(_("left"), 0), (_("stereo"), 1), (_("right"), 2)]
+					self.session.openWithCallback(self.EXmodeSelected, ChoiceBox, title=_("Select audio mode"), list = tlist, selection = selection, keys = keys)
+					
+			else: #if isinstance(audio[1], str):
+				del self.audioChannel
+				if self.session.nav.getCurrentService().audioTracks().getNumberOfTracks() > audio[1]:
+					self.audioTracks.selectTrack(audio[1])
+
+		else:
+			try:
+				del self.audioChannel
+			except AttributeError:
+				print "no such Attribute"
+		try:
+			del self.audioTracks
+		except AttributeError:
+			print "no such Attribute"
+			
+		self.EXdoHide() 
+
+	def EXmodeSelected(self, mode):
+		if mode is not None:
+			self.audioChannel.selectChannel(mode[1])
+		del self.audioChannel
+#+++<
+
 class InfoBarSubserviceSelection:
 	def __init__(self):
 		self["SubserviceSelectionAction"] = HelpableActionMap(self, "InfobarSubserviceSelectionActions",
@@ -1869,16 +2062,43 @@
 				idx += 1
 
 			if self.bouquets and len(self.bouquets):
-				keys = ["red", "blue", "",  "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ] + [""] * n
+#--->
+#-				keys = ["red", "blue", "",  "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ] + [""] * n
+#---<
+#+++>
+				keys = ["red", "blue", "yellow", "",  "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ] + [""] * n
+#+++<
 				if config.usage.multibouquet.value:
-					tlist = [(_("Quickzap"), "quickzap", service.subServices()), (_("Add to bouquet"), "CALLFUNC", self.addSubserviceToBouquetCallback), ("--", "")] + tlist
+#--->
+#-					tlist = [(_("Quickzap"), "quickzap", service.subServices()), (_("Add to bouquet"), "CALLFUNC", self.addSubserviceToBouquetCallback), ("--", "")] + tlist
+#---<
+#+++>
+					tlist = [(_("Quickzap"), "quickzap", service.subServices()), (_("Add to bouquet"), "CALLFUNC", self.addSubserviceToBouquetCallback), ("Exit", "exit"), ("--", "")] + tlist
+#+++<
 				else:
-					tlist = [(_("Quickzap"), "quickzap", service.subServices()), (_("Add to favourites"), "CALLFUNC", self.addSubserviceToBouquetCallback), ("--", "")] + tlist
+#--->
+#-					tlist = [(_("Quickzap"), "quickzap", service.subServices()), (_("Add to favourites"), "CALLFUNC", self.addSubserviceToBouquetCallback), ("--", "")] + tlist
+#---<
+#+++>
+					tlist = [(_("Quickzap"), "quickzap", service.subServices()), (_("Add to favourites"), "CALLFUNC", self.addSubserviceToBouquetCallback), ("Exit", "exit"), ("--", "")] + tlist
+#+++<
+#--->
+#-				selection += 3
+#---<
+#+++>
+				selection += 4
+#+++<
+			else:
+#--->
+#-				tlist = [(_("Quickzap"), "quickzap", service.subServices()), ("--", "")] + tlist
+#-				keys = ["red", "",  "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ] + [""] * n
+#-				selection += 2
+#---<
+#+++>
+				tlist = [(_("Quickzap"), "quickzap", service.subServices()), ("Exit", "exit"), ("--", "")] + tlist
+				keys = ["red", "yellow", "",  "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ] + [""] * n
 				selection += 3
-			else:
-				tlist = [(_("Quickzap"), "quickzap", service.subServices()), ("--", "")] + tlist
-				keys = ["red", "",  "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ] + [""] * n
-				selection += 2
+#+++<
 
 			self.session.openWithCallback(self.subserviceSelected, ChoiceBox, title=_("Please select a subservice..."), list = tlist, selection = selection, keys = keys, skin_name = "SubserviceSelection")
 
@@ -1919,6 +2139,129 @@
 		else:
 			del self.selectedSubservice
 
+#+++>
+class InfoBarAspectSelection: 
+	STATE_HIDDEN = 0 
+	STATE_ASPECT = 1 
+	STATE_RESOLUTION = 2 
+	def __init__(self): 
+		self["AspectSelectionAction"] = HelpableActionMap(self, "InfobarAspectSelectionActions", 
+			{ 
+				"aspectSelection": (self.ExGreen_toggleGreen, _("Aspect list...")), 
+			}) 
+
+		self.__ExGreen_state = self.STATE_HIDDEN 
+
+	def ExGreen_doAspect(self): 
+		self.__ExGreen_state = self.STATE_ASPECT 
+		self.aspectSelection() 
+
+	def ExGreen_doResolution(self): 
+		self.__ExGreen_state = self.STATE_RESOLUTION 
+		self.resolutionSelection() 
+
+	def ExGreen_doHide(self): 
+		self.__ExGreen_state = self.STATE_HIDDEN 
+
+	def ExGreen_toggleGreen(self, arg=""): 
+		print self.__ExGreen_state 
+		if self.__ExGreen_state == self.STATE_HIDDEN: 
+			print "self.STATE_HIDDEN" 
+			self.ExGreen_doAspect() 
+		elif self.__ExGreen_state == self.STATE_ASPECT: 
+			print "self.STATE_ASPECT" 
+			self.ExGreen_doResolution() 
+		elif self.__ExGreen_state == self.STATE_RESOLUTION: 
+			print "self.STATE_RESOLUTION" 
+			self.ExGreen_doHide() 
+
+	def aspectSelection(self): 
+		selection = 0 
+		tlist = [] 
+		tlist.append((_("Resolution"), "resolution")) 
+		tlist.append(("", "")) 
+		tlist.append(("Letterbox", "letterbox")) 
+		tlist.append(("PanScan", "panscan")) 
+		tlist.append(("Non Linear", "non")) 
+		tlist.append(("Bestfit", "bestfit")) 
+
+		mode = open("/proc/stb/video/policy").read()[:-1] 
+		print mode 
+		for x in range(len(tlist)): 
+			if tlist[x][1] == mode: 
+				selection = x 
+
+		keys = ["green", "",  "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ] 
+
+
+		self.session.openWithCallback(self.aspectSelected, ChoiceBox, title=_("Please select an aspect ratio..."), list = tlist, selection = selection, keys = keys) 
+	def aspectSelected(self, aspect): 
+		if not aspect is None: 
+			if isinstance(aspect[1], str): 
+				if aspect[1] == "resolution":
+					self.ExGreen_toggleGreen()
+				else:
+					open("/proc/stb/video/policy", "w").write(aspect[1]) 
+					self.ExGreen_doHide()
+		return 
+
+class InfoBarResolutionSelection: 
+	def __init__(self): 
+		return
+
+	def resolutionSelection(self): 
+
+		xresString = open("/proc/stb/vmpeg/0/xres", "r").read()
+		yresString = open("/proc/stb/vmpeg/0/yres", "r").read()
+		fpsString = open("/proc/stb/vmpeg/0/framerate", "r").read()
+		xres = int(xresString, 16)
+		yres = int(yresString, 16)
+		fps = int(fpsString, 16)
+		fpsFloat = float(fps)
+		fpsFloat = fpsFloat/1000
+
+
+		selection = 0 
+		tlist = [] 
+		tlist.append((_("Exit"), "exit")) 
+		tlist.append((_("Auto(not available)"), "auto")) 
+		tlist.append(("Video: " + str(xres) + "x" + str(yres) + "@" + str(fpsFloat) + "hz", "")) 
+		tlist.append(("--", "")) 
+		tlist.append(("576i", "576i50")) 
+		tlist.append(("576p", "576p50")) 
+		tlist.append(("720p", "720p50")) 
+		tlist.append(("1080i", "1080i50")) 
+		tlist.append(("1080p@23.976hz", "1080p23")) 
+		tlist.append(("1080p@24hz", "1080p24")) 
+		tlist.append(("1080p@25hz", "1080p25")) 
+		
+
+		keys = ["green", "yellow", "blue", "", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ] 
+
+		mode = open("/proc/stb/video/videomode").read()[:-1] 
+		print mode 
+		for x in range(len(tlist)): 
+			if tlist[x][1] == mode: 
+				selection = x 
+
+		self.session.openWithCallback(self.ResolutionSelected, ChoiceBox, title=_("Please select a resolution..."), list = tlist, selection = selection, keys = keys) 
+
+	def ResolutionSelected(self, Resolution): 
+		if not Resolution is None: 
+			if isinstance(Resolution[1], str): 
+				if Resolution[1] == "exit":
+					self.ExGreen_toggleGreen()
+				elif Resolution[1] != "auto":
+					open("/proc/stb/video/videomode", "w").write(Resolution[1]) 
+					from enigma import gFBDC
+					gFBDC.getInstance().setResolution(-1, -1)
+					self.ExGreen_toggleGreen()
+		return 
+
+
+
+#+++<
+
 class InfoBarAdditionalInfo:
 	def __init__(self):
 
@@ -2245,7 +2588,22 @@
 			print "no teletext plugin found!"
 
 	def startTeletext(self):
-		self.teletext_plugin(session=self.session, service=self.session.nav.getCurrentService())
+#--->
+#		self.teletext_plugin(session=self.session, service=self.session.nav.getCurrentService())
+#---<
+#+++>
+		global txtIsStarting
+		if txtIsStarting is False:
+			self.teletext_plugin(session=self.session, service=self.session.nav.getCurrentService())
+			txtIsStarting = True
+			self.txtIsStartingTimer = eTimer()
+			self.txtIsStartingTimer.callback.append(self.txtIsStartingEnd)
+			self.txtIsStartingTimer.start(10000, True)
+
+	def txtIsStartingEnd(self):
+		global txtIsStarting
+		txtIsStarting = False
+#+++<
 
 class InfoBarSubtitleSupport(object):
 	def __init__(self):
diff -Nur enigma2-nightly/lib/python/Screens/InfoBar.py enigma2-nightly.spark/lib/python/Screens/InfoBar.py
--- enigma2-nightly/lib/python/Screens/InfoBar.py	2010-08-11 18:16:49.739888996 +0800
+++ enigma2-nightly.spark/lib/python/Screens/InfoBar.py	2010-08-11 18:12:24.854601355 +0800
@@ -6,17 +6,33 @@
 from Screen import Screen
 
 profile("LOAD:enigma")
-from enigma import iPlayableService
+#--->
+#-from enigma import iPlayableService
+#---<
+#+++>
+from enigma import iServiceInformation, iPlayableService 
+#+++<
 
 profile("LOAD:InfoBarGenerics")
+
+#-from Screens.InfoBarGenerics import InfoBarShowHide, \
+#-	InfoBarNumberZap, InfoBarChannelSelection, InfoBarMenu, InfoBarRdsDecoder, \
+#-	InfoBarEPG, InfoBarSeek, InfoBarInstantRecord, \
+#-	InfoBarAudioSelection, InfoBarAdditionalInfo, InfoBarNotifications, InfoBarDish, \
+#-	InfoBarSubserviceSelection, InfoBarShowMovies, InfoBarTimeshift,  \
+#-	InfoBarServiceNotifications, InfoBarPVRState, InfoBarCueSheetSupport, InfoBarSimpleEventView, \
+#-	InfoBarSummarySupport, InfoBarMoviePlayerSummarySupport, InfoBarTimeshiftState, InfoBarTeletextPlugin, InfoBarExtensions, \
+#-	InfoBarSubtitleSupport, InfoBarPiP, InfoBarPlugins, InfoBarServiceErrorPopupSupport, InfoBarJobman
+#+++>
 from Screens.InfoBarGenerics import InfoBarShowHide, \
 	InfoBarNumberZap, InfoBarChannelSelection, InfoBarMenu, InfoBarRdsDecoder, \
 	InfoBarEPG, InfoBarSeek, InfoBarInstantRecord, \
-	InfoBarAudioSelection, InfoBarAdditionalInfo, InfoBarNotifications, InfoBarDish, InfoBarUnhandledKey, \
-	InfoBarSubserviceSelection, InfoBarShowMovies, InfoBarTimeshift,  \
+	InfoBarAudioSelection, InfoBarExtendedAudioSelection, InfoBarAdditionalInfo, InfoBarNotifications, InfoBarDish, \
+	InfoBarAspectSelection, InfoBarResolutionSelection, InfoBarSubserviceSelection, InfoBarShowMovies, InfoBarTimeshift,  \
 	InfoBarServiceNotifications, InfoBarPVRState, InfoBarCueSheetSupport, InfoBarSimpleEventView, \
 	InfoBarSummarySupport, InfoBarMoviePlayerSummarySupport, InfoBarTimeshiftState, InfoBarTeletextPlugin, InfoBarExtensions, \
-	InfoBarSubtitleSupport, InfoBarPiP, InfoBarPlugins, InfoBarServiceErrorPopupSupport, InfoBarJobman
+	InfoBarSleepTimer, InfoBarSubtitleSupport, InfoBarPiP, InfoBarPlugins, InfoBarServiceErrorPopupSupport, InfoBarUnhandledKey, InfoBarJobman
+#+++<
 
 profile("LOAD:InitBar_Components")
 from Components.ActionMap import HelpableActionMap
@@ -28,9 +44,19 @@
 
 class InfoBar(InfoBarBase, InfoBarShowHide,
 	InfoBarNumberZap, InfoBarChannelSelection, InfoBarMenu, InfoBarEPG, InfoBarRdsDecoder,
-	InfoBarInstantRecord, InfoBarAudioSelection, 
+#--->
+#-	InfoBarInstantRecord, InfoBarAudioSelection, 
+#---<
+#+++>
+	InfoBarInstantRecord, InfoBarAudioSelection, InfoBarExtendedAudioSelection, 
+#+++<
 	HelpableScreen, InfoBarAdditionalInfo, InfoBarNotifications, InfoBarDish, InfoBarUnhandledKey,
-	InfoBarSubserviceSelection, InfoBarTimeshift, InfoBarSeek,
+#--->
+#-	InfoBarSubserviceSelection, InfoBarTimeshift, InfoBarSeek,
+#---<
+#+++>
+	InfoBarSleepTimer, InfoBarAspectSelection, InfoBarResolutionSelection, InfoBarSubserviceSelection, InfoBarTimeshift, InfoBarSeek,
+#+++<
 	InfoBarSummarySupport, InfoBarTimeshiftState, InfoBarTeletextPlugin, InfoBarExtensions,
 	InfoBarPiP, InfoBarPlugins, InfoBarSubtitleSupport, InfoBarServiceErrorPopupSupport, InfoBarJobman,
 	Screen):
@@ -45,18 +71,34 @@
 				"showMovies": (self.showMovies, _("Play recorded movies...")),
 				"showRadio": (self.showRadio, _("Show the radio player...")),
 				"showTv": (self.showTv, _("Show the tv player...")),
+#+++>
+				"toogleTvRadio": (self.toogleTvRadio, _("toggels betwenn tv and radio...")), 
+				"volumeUp": (self._volUp, _("...")), 
+				"volumeDown": (self._volDown, _("...")), 
+#+++<
 			}, prio=2)
 		
 		self.allowPiP = True
-		
+#--->
+#-		for x in HelpableScreen, \
+#-				InfoBarBase, InfoBarShowHide, \
+#-				InfoBarNumberZap, InfoBarChannelSelection, InfoBarMenu, InfoBarEPG, InfoBarRdsDecoder, \
+#-				InfoBarInstantRecord, InfoBarAudioSelection, \
+#-				InfoBarAdditionalInfo, InfoBarNotifications, InfoBarDish, InfoBarSubserviceSelection, \
+#-				InfoBarTimeshift, InfoBarSeek, InfoBarSummarySupport, InfoBarTimeshiftState, \
+#-				InfoBarTeletextPlugin, InfoBarExtensions, InfoBarPiP, InfoBarSubtitleSupport, InfoBarJobman, \
+#-				InfoBarPlugins, InfoBarServiceErrorPopupSupport:
+#---<
+#+++>
 		for x in HelpableScreen, \
 				InfoBarBase, InfoBarShowHide, \
 				InfoBarNumberZap, InfoBarChannelSelection, InfoBarMenu, InfoBarEPG, InfoBarRdsDecoder, \
-				InfoBarInstantRecord, InfoBarAudioSelection, InfoBarUnhandledKey, \
-				InfoBarAdditionalInfo, InfoBarNotifications, InfoBarDish, InfoBarSubserviceSelection, \
+				InfoBarInstantRecord, InfoBarAudioSelection, InfoBarExtendedAudioSelection, \
+				InfoBarAdditionalInfo, InfoBarNotifications, InfoBarDish, InfoBarAspectSelection, InfoBarResolutionSelection, InfoBarSubserviceSelection, \
 				InfoBarTimeshift, InfoBarSeek, InfoBarSummarySupport, InfoBarTimeshiftState, \
 				InfoBarTeletextPlugin, InfoBarExtensions, InfoBarPiP, InfoBarSubtitleSupport, InfoBarJobman, \
-				InfoBarPlugins, InfoBarServiceErrorPopupSupport:
+				InfoBarSleepTimer, InfoBarPlugins, InfoBarServiceErrorPopupSupport:
+#+++<		
 			x.__init__(self)
 
 		self.helpList.append((self["actions"], "InfobarActions", [("showMovies", _("view recordings..."))]))
@@ -71,6 +113,41 @@
 		assert InfoBar.instance is None, "class InfoBar is a singleton class and just one instance of this class is allowed!"
 		InfoBar.instance = self
 
+#+++>
+		# I know that this is not nice but i dont know how to directly access VolumneControl
+		from Screens.Volume import Volume
+		self.volumeDialog = session.instantiateDialog(Volume)
+		from enigma import eTimer
+		self.hideVolTimer = eTimer()
+		self.hideVolTimer.callback.append(self.volHide)
+		from Components.config import config, ConfigSubsection, ConfigInteger
+		config.audio = ConfigSubsection()
+		config.audio.volume = ConfigInteger(default = 100, limits = (0, 100))
+		
+	def volHide(self):
+		self.volumeDialog.hide()
+
+	def _volUp(self):
+		print "_volUp"
+		from enigma import eDVBVolumecontrol
+		eDVBVolumecontrol.getInstance().volumeUp()
+		self.volumeDialog.setValue(eDVBVolumecontrol.getInstance().getVolume())
+		self.volumeDialog.show()
+		self.hideVolTimer.start(3000, True)
+		config.audio.volume.value = eDVBVolumecontrol.getInstance().getVolume()
+		config.audio.volume.save()
+
+	def _volDown(self):
+		print "_volDown"
+		from enigma import eDVBVolumecontrol
+		eDVBVolumecontrol.getInstance().volumeDown()
+		self.volumeDialog.setValue(eDVBVolumecontrol.getInstance().getVolume())
+		self.volumeDialog.show()
+		self.hideVolTimer.start(3000, True)
+		config.audio.volume.value = eDVBVolumecontrol.getInstance().getVolume()
+		config.audio.volume.save()
+#+++<
+
 	def __onClose(self):
 		InfoBar.instance = None
 
@@ -89,6 +166,24 @@
 		self.__serviceStarted(True)
 		self.onExecBegin.remove(self.__checkServiceStarted)
 
+#+++>
+	def toogleTvRadio(self): 
+		service = self.session.nav.getCurrentService() 
+		info = service.info() 
+		AudioPID = info.getInfo(iServiceInformation.sAudioPID) 
+		VideoPID = info.getInfo(iServiceInformation.sVideoPID) 
+
+		print "sAudioPID", AudioPID 
+		print "sVideoPID", VideoPID 
+               
+		if VideoPID == -1: 
+			print "radio->tv" 
+			self.showTv2() 
+		else: 
+			print "tv->radio" 
+			self.showRadio2() 
+#+++<
+
 	def serviceStarted(self):  #override from InfoBarShowHide
 		new = self.servicelist.newServicePlayed()
 		if self.execing:
@@ -112,6 +207,19 @@
 			from Screens.ChannelSelection import ChannelSelectionRadio
 			self.session.openWithCallback(self.ChannelSelectionRadioClosed, ChannelSelectionRadio, self)
 
+#+++>
+	def showTv2(self):
+		self.showTvChannelList(False)
+
+	def showRadio2(self):
+		if config.usage.e1like_radio_mode.value:
+			self.showRadioChannelList(False)
+ 		else:
+ 			self.rds_display.hide() # in InfoBarRdsDecoder
+ 			from Screens.ChannelSelection import ChannelSelectionRadio
+ 			self.session.openWithCallback(self.ChannelSelectionRadioClosed, ChannelSelectionRadio, self)
+#+++<
+
 	def ChannelSelectionRadioClosed(self, *arg):
 		self.rds_display.show()  # in InfoBarRdsDecoder
 
@@ -212,12 +320,22 @@
 					return
 
 		if answer in ("quit", "quitanddeleteconfirmed"):
+#+++> 
+                        # make sure that playback is unpaused otherwise the  
+                        # player driver might stop working 
+                        self.setSeekState(self.SEEK_STATE_PLAY) 
+#+++<
 			self.close()
 		elif answer == "movielist":
 			ref = self.session.nav.getCurrentlyPlayingServiceReference()
 			self.returning = True
 			from Screens.MovieSelection import MovieSelection
 			self.session.openWithCallback(self.movieSelected, MovieSelection, ref)
+#+++> 
+                        # make sure that playback is unpaused otherwise the  
+                        # player driver might stop working 
+                        self.setSeekState(self.SEEK_STATE_PLAY) 
+#+++<
 			self.session.nav.stopService()
 		elif answer == "restart":
 			self.doSeek(0)
diff -Nur enigma2-nightly/lib/python/Screens/Wizard.py enigma2-nightly.spark/lib/python/Screens/Wizard.py
--- enigma2-nightly/lib/python/Screens/Wizard.py	2010-08-11 18:16:49.815713580 +0800
+++ enigma2-nightly.spark/lib/python/Screens/Wizard.py	2010-08-11 18:12:24.837592612 +0800
@@ -14,6 +14,9 @@
 
 from xml.sax import make_parser
 from xml.sax.handler import ContentHandler
+#+++>
+from enigma import evfd
+#+++<
 
 class WizardSummary(Screen):
 	skin = """
@@ -360,6 +363,9 @@
 				if self.updateValues in self.onShown:
 					self.onShown.remove(self.updateValues)
 
+#+++>
+		open("/proc/progress", "w").write("100")
+#+++<
 		if print_now:
 			print "Now: " + str(self.currStep)
 
@@ -448,6 +454,9 @@
 			if self.wizard[self.currStep].has_key("onselect"):
 				self.selection = self["list"].current[-1]
 				print "self.selection:", self.selection
+#+++>
+				evfd.getInstance().vfd_write_string("-> " + self.selection)
+#+++<
 				exec("self." + self.wizard[self.currStep]["onselect"] + "()")
 		
 	def resetCounter(self):
diff -Nur enigma2-nightly/lib/service/Makefile.am enigma2-nightly.spark/lib/service/Makefile.am
--- enigma2-nightly/lib/service/Makefile.am	2010-08-11 18:16:49.822905763 +0800
+++ enigma2-nightly.spark/lib/service/Makefile.am	2010-08-11 18:12:24.838726118 +0800
@@ -1,5 +1,5 @@
 INCLUDES = \
-	-I$(top_srcdir)/include
+	-I$(top_srcdir)/include -I$(top_srcdir)/../misc/tools/libeplayer2/include
 
 noinst_LIBRARIES = libenigma_service.a
 
diff -Nur enigma2-nightly/lib/service/servicedvb.cpp enigma2-nightly.spark/lib/service/servicedvb.cpp
--- enigma2-nightly/lib/service/servicedvb.cpp	2010-08-11 18:16:49.825809009 +0800
+++ enigma2-nightly.spark/lib/service/servicedvb.cpp	2010-08-11 18:12:24.840280502 +0800
@@ -534,6 +534,9 @@
 	if (sc)
 	{
 		std::list<std::string> extensions;
+#if defined(__sh__) //Topfield original recording extension
+		extensions.push_back("rec");
+#endif
 		extensions.push_back("ts");
 		extensions.push_back("trp");
 		sc->addServiceFactory(eServiceFactoryDVB::id, this, extensions);
@@ -1452,6 +1455,10 @@
 
 RESULT eDVBServicePlay::isCurrentlySeekable()
 {
+// __sh__: fix seekable problem with .ts files if .ts.meta not exists (see e2 git from 02.01.2010 10:54:57)
+#ifdef __sh__
+	return m_is_pvr || m_timeshift_active;
+#else
 	int ret = 0;
 	if (m_decoder)
 	{
@@ -1460,6 +1467,7 @@
 			ret &= ~2;
 	}
 	return ret;
+#endif
 }
 
 RESULT eDVBServicePlay::frontendInfo(ePtr<iFrontendInformation> &ptr)
diff -Nur enigma2-nightly/lib/service/servicedvbrecord.cpp enigma2-nightly.spark/lib/service/servicedvbrecord.cpp
--- enigma2-nightly/lib/service/servicedvbrecord.cpp	2010-08-11 18:16:49.827721077 +0800
+++ enigma2-nightly.spark/lib/service/servicedvbrecord.cpp	2010-08-11 18:12:24.843710737 +0800
@@ -12,6 +12,26 @@
 #error no byte order defined!
 #endif
 
+#if defined(__sh__) 
+#include <sys/vfs.h> 
+//this is not available for stlinux :-( 
+//#include <linux/magic.h> 
+ 
+/* and these i dont get included :-( 
+#include <linux/usbdevice_fs.h> 
+#include <linux/smb.h> 
+#include <linux/nfs__fs.h> 
+#include <linux/ext3_fs.h> 
+
+so hack ;-) 
+*/ 
+#define USBDEVICE_SUPER_MAGIC 0x9fa2 
+#define EXT2_SUPER_MAGIC      0xEF53 
+#define EXT3_SUPER_MAGIC      0xEF53 
+#define SMB_SUPER_MAGIC       0x517B 
+#define NFS_SUPER_MAGIC       0x6969 
+#define MSDOS_SUPER_MAGIC     0x4d44            /* MD */ 
+#endif
 DEFINE_REF(eDVBServiceRecord);
 
 eDVBServiceRecord::eDVBServiceRecord(const eServiceReferenceDVB &ref): m_ref(ref)
@@ -254,9 +274,43 @@
 	
 	if (!m_record && m_tuned && !m_streaming && !m_simulate)
 	{
+#if defined(__sh__) 
+		int flags = O_WRONLY|O_CREAT|O_LARGEFILE;
+		struct statfs sbuf;
+#endif
 		eDebug("Recording to %s...", m_filename.c_str());
 		::remove(m_filename.c_str());
+#if defined(__sh__) 
+		//we must creat a file for statfs
 		int fd = ::open(m_filename.c_str(), O_WRONLY|O_CREAT|O_LARGEFILE, 0644);
+		::close(fd);
+		if (statfs(m_filename.c_str(), &sbuf) < 0) 
+		{ 
+			eDebug("eDVBServiceRecord - can't get fs type assuming none NFS!"); 
+		} else 
+		{ 
+			if (sbuf.f_type == EXT3_SUPER_MAGIC) 
+				eDebug("eDVBServiceRecord - Ext2/3/4 Filesystem\n"); 
+			else 
+			if (sbuf.f_type == NFS_SUPER_MAGIC) 
+			{ 
+				eDebug("eDVBServiceRecord - NFS Filesystem; add O_DIRECT to flags\n"); 
+				flags |= O_DIRECT; 
+			} 
+			else 
+			if (sbuf.f_type == USBDEVICE_SUPER_MAGIC) 
+				eDebug("eDVBServiceRecord - USB Device\n"); 
+			else 
+			if (sbuf.f_type == SMB_SUPER_MAGIC) 
+				eDebug("eDVBServiceRecord - SMBs Device\n"); 
+			else 
+			if (sbuf.f_type == MSDOS_SUPER_MAGIC) 
+				eDebug("eDVBServiceRecord - MSDOS Device\n"); 
+		} 
+		fd = ::open(m_filename.c_str(), flags, 0644); 
+#else
+		int fd = ::open(m_filename.c_str(), O_WRONLY|O_CREAT|O_LARGEFILE, 0644);
+#endif
 		if (fd == -1)
 		{
 			eDebug("eDVBServiceRecord - can't open recording file!");
diff -Nur enigma2-nightly/lib/service/servicemp3.cpp enigma2-nightly.spark/lib/service/servicemp3.cpp
--- enigma2-nightly/lib/service/servicemp3.cpp	2010-08-11 18:16:49.830713852 +0800
+++ enigma2-nightly.spark/lib/service/servicemp3.cpp	2010-08-11 18:12:24.873564352 +0800
@@ -1,4 +1,6 @@
-#ifdef HAVE_GSTREAMER
+//#if not defined(__sh__)
+//#ifdef HAVE_GSTREAMER
+//#endif
 
 	/* note: this requires gstreamer 0.10.x and a big list of plugins. */
 	/* it's currently hardcoded to use a big-endian alsasink as sink. */
@@ -16,8 +18,10 @@
 
 #include <string>
 
+#if not defined(__sh__)
 #include <gst/gst.h>
 #include <gst/pbutils/missing-plugins.h>
+#endif
 #include <sys/stat.h>
 
 // eServiceFactoryMP3
@@ -25,14 +29,16 @@
 eServiceFactoryMP3::eServiceFactoryMP3()
 {
 	ePtr<eServiceCenter> sc;
-	
+
 	eServiceCenter::getPrivInstance(sc);
 	if (sc)
 	{
 		std::list<std::string> extensions;
 		extensions.push_back("mp2");
 		extensions.push_back("mp3");
+#if not defined(__sh__)
 		extensions.push_back("ogg");
+#endif
 		extensions.push_back("mpg");
 		extensions.push_back("vob");
 		extensions.push_back("wav");
@@ -42,10 +48,29 @@
 		extensions.push_back("avi");
 		extensions.push_back("divx");
 		extensions.push_back("dat");
+#if not defined(__sh__)
 		extensions.push_back("flac");
+#endif
 		extensions.push_back("mp4");
+#if not defined(__sh__)
 		extensions.push_back("mov");
+#endif
 		extensions.push_back("m4a");
+#if defined(__sh__)
+		extensions.push_back("mpeg");
+		extensions.push_back("m2ts");
+		extensions.push_back("trp");
+		extensions.push_back("vdr");
+		extensions.push_back("wma");
+		extensions.push_back("mts");
+		int fd = open("/proc/stb/info/model", O_RDONLY);
+		char tmp[255];
+		int rd = fd >= 0 ? read(fd, tmp, 255) : 0;
+		if (fd >= 0)
+			close(fd);
+		if (!strncmp(tmp, "ufs912\n", rd))
+			extensions.push_back("wmv");
+#endif
 		sc->addServiceFactory(eServiceFactoryMP3::id, this, extensions);
 	}
 
@@ -55,7 +80,7 @@
 eServiceFactoryMP3::~eServiceFactoryMP3()
 {
 	ePtr<eServiceCenter> sc;
-	
+
 	eServiceCenter::getPrivInstance(sc);
 	if (sc)
 		sc->removeServiceFactory(eServiceFactoryMP3::id);
@@ -95,7 +120,7 @@
 	eServiceReference m_ref;
 public:
 	eMP3ServiceOfflineOperations(const eServiceReference &ref);
-	
+
 	RESULT deleteFromDisk(int simulate);
 	RESULT getListOfFilenames(std::list<std::string> &);
 	RESULT reindex();
@@ -116,11 +141,11 @@
 		std::list<std::string> res;
 		if (getListOfFilenames(res))
 			return -1;
-		
+
 		eBackgroundFileEraser *eraser = eBackgroundFileEraser::getInstance();
 		if (!eraser)
 			eDebug("FATAL !! can't get background file eraser");
-		
+
 		for (std::list<std::string>::iterator i(res.begin()); i != res.end(); ++i)
 		{
 			eDebug("Removing %s...", i->c_str());
@@ -129,7 +154,7 @@
 			else
 				::unlink(i->c_str());
 		}
-		
+
 		return 0;
 	}
 }
@@ -206,7 +231,7 @@
 	}
 	return iServiceInformation::resNA;
 }
- 
+
 
 // eServiceMP3
 int eServiceMP3::ac3_delay,
@@ -217,7 +242,9 @@
 {
 	m_seekTimeout = eTimer::create(eApp);
 	m_subtitle_sync_timer = eTimer::create(eApp);
+#if not defined(__sh__)
 	m_stream_tags = 0;
+#endif
 	m_currentAudioStream = -1;
 	m_currentSubtitleStream = 0;
 	m_subtitle_widget = 0;
@@ -226,7 +253,9 @@
 	m_buffer_size = 1*1024*1024;
 	CONNECT(m_seekTimeout->timeout, eServiceMP3::seekTimeoutCB);
 	CONNECT(m_subtitle_sync_timer->timeout, eServiceMP3::pushSubtitles);
+#if not defined(__sh__)
 	CONNECT(m_pump.recv_msg, eServiceMP3::gstPoll);
+#endif
 	m_aspect = m_width = m_height = m_framerate = m_progressive = -1;
 
 	m_state = stIdle;
@@ -237,6 +266,7 @@
 	if (!ext)
 		ext = filename;
 
+#if not defined(__sh__)
 	sourceStream sourceinfo;
 	sourceinfo.is_video = FALSE;
 	sourceinfo.audiotype = atUnknown;
@@ -359,10 +389,147 @@
 	}
 
 	setBufferSize(m_buffer_size);
+#else
+    player = (Context_t*) malloc(sizeof(Context_t));
+
+    if(player) {
+	    player->playback	= &PlaybackHandler;
+	    player->output		= &OutputHandler;
+	    player->container	= &ContainerHandler;
+	    player->manager		= &ManagerHandler;
+
+    	printf("%s\n", player->output->Name);
+    }
+
+	//Registration of output devices
+    if(player && player->output) {
+	    player->output->Command(player,OUTPUT_ADD, (void*)"audio");
+	    player->output->Command(player,OUTPUT_ADD, (void*)"video");
+	    player->output->Command(player,OUTPUT_ADD, (void*)"subtitle");
+    }
+
+    //create playback path
+    char file[400] = {""};
+
+    if(!strncmp("http://", m_ref.path.c_str(), 7))
+        ;
+    else if(!strncmp("file://", m_ref.path.c_str(), 7))
+        ;
+    else
+        strcat(file, "file://");
+
+    strcat(file, m_ref.path.c_str());
+
+    //try to open file
+	if(player && player->playback && player->playback->Command(player, PLAYBACK_OPEN, file) >= 0) {
+
+        //VIDEO
+            //We dont have to register video tracks, or do we ?
+
+        //AUDIO
+        if(player && player->manager && player->manager->audio) {
+            char ** TrackList = NULL;
+		    player->manager->audio->Command(player, MANAGER_LIST, &TrackList);
+		    if (TrackList != NULL) {
+			    printf("AudioTrack List\n");
+			    int i = 0;
+			    for (i = 0; TrackList[i] != NULL; i+=2) {
+				    printf("\t%s - %s\n", TrackList[i], TrackList[i+1]);
+                    audioStream audio;
+
+                    audio.language_code = TrackList[i];
+
+                    // atUnknown, atMPEG, atMP3, atAC3, atDTS, atAAC, atPCM, atOGG, atFLAC
+                    if(     !strncmp("A_MPEG/L3",   TrackList[i+1], 9))
+                        audio.type = atMP3;
+                    else if(!strncmp("A_AC3",       TrackList[i+1], 5))
+                        audio.type = atAC3;
+                    else if(!strncmp("A_DTS",       TrackList[i+1], 5))
+                        audio.type = atDTS;
+                    else if(!strncmp("A_AAC",       TrackList[i+1], 5))
+                        audio.type = atAAC;
+                    else if(!strncmp("A_PCM",       TrackList[i+1], 5))
+                        audio.type = atPCM;
+                    else if(!strncmp("A_VORBIS",    TrackList[i+1], 8))
+                        audio.type = atOGG;
+                    else if(!strncmp("A_FLAC",      TrackList[i+1], 6))
+                        audio.type = atFLAC;
+                    else
+		                audio.type = atUnknown;
+
+		            m_audioStreams.push_back(audio);
+
+				    free(TrackList[i]);
+                    free(TrackList[i+1]);
+			    }
+			    free(TrackList);
+		    }
+        }
+
+        //SUB
+        if(player && player->manager && player->manager->subtitle) {
+            char ** TrackList = NULL;
+		    player->manager->subtitle->Command(player, MANAGER_LIST, &TrackList);
+		    if (TrackList != NULL) {
+			    printf("SubtitleTrack List\n");
+			    int i = 0;
+			    for (i = 0; TrackList[i] != NULL; i+=2) {
+				    printf("\t%s - %s\n", TrackList[i], TrackList[i+1]);
+                    subtitleStream sub;
+
+                    sub.language_code = TrackList[i];
+
+                    //  stPlainText, stSSA, stSRT
+                    if(     !strncmp("S_TEXT/SSA",  TrackList[i+1], 10) ||
+                            !strncmp("S_SSA",       TrackList[i+1], 5))
+                        sub.type = stSSA;
+                    else if(!strncmp("S_TEXT/ASS",  TrackList[i+1], 10) ||
+                            !strncmp("S_AAS",       TrackList[i+1], 5))
+                        sub.type = stSSA;
+                    else if(!strncmp("S_TEXT/SRT",  TrackList[i+1], 10) ||
+                            !strncmp("S_SRT",       TrackList[i+1], 5))
+                        sub.type = stSRT;
+                    else
+		                sub.type = stPlainText;
+
+		            m_subtitleStreams.push_back(sub);
+
+				    free(TrackList[i]);
+                    free(TrackList[i+1]);
+			    }
+			    free(TrackList);
+		    }
+        }
+
+		m_event(this, evStart);
+    } else {
+        //Creation failed, no playback support for insert file, so delete playback context
+
+        //FIXME: How to tell e2 that we failed?
+
+        if(player && player->output) {
+            player->output->Command(player,OUTPUT_DEL, (void*)"audio");
+	        player->output->Command(player,OUTPUT_DEL, (void*)"video");
+	        player->output->Command(player,OUTPUT_DEL, (void*)"subtitle");
+        }
+
+        if(player && player->playback)
+            player->playback->Command(player,PLAYBACK_CLOSE, NULL);
+
+        if(player)
+            free(player);
+        player = NULL;
+
+    }
+
+	//m_state = stRunning;
+	eDebug("eServiceMP3-<\n");
+#endif
 }
 
 eServiceMP3::~eServiceMP3()
 {
+#if not defined(__sh__)
 	// disconnect subtitle callback
 	GstElement *sink;
 	g_object_get (G_OBJECT (m_gst_playbin), "text-sink", &sink, NULL);
@@ -371,23 +538,42 @@
 		g_signal_handler_disconnect (sink, m_subs_to_pull_handler_id);
 		gst_object_unref(sink);
 	}
+	#endif
 
 	delete m_subtitle_widget;
 
+#if not defined(__sh__)
 	// disconnect sync handler callback
 	gst_bus_set_sync_handler(gst_pipeline_get_bus (GST_PIPELINE (m_gst_playbin)), NULL, NULL);
+	#endif
 
 	if (m_state == stRunning)
 		stop();
-
+#if not defined(__sh__)
 	if (m_stream_tags)
 		gst_tag_list_free(m_stream_tags);
-	
+
 	if (m_gst_playbin)
 	{
 		gst_object_unref (GST_OBJECT (m_gst_playbin));
 		eDebug("eServiceMP3::destruct!");
 	}
+#else
+//Trick
+/*    if(player && player->output) {
+        player->output->Command(player,OUTPUT_DEL, (void*)"audio");
+        player->output->Command(player,OUTPUT_DEL, (void*)"video");
+        player->output->Command(player,OUTPUT_DEL, (void*)"subtitle");
+    }
+
+    if(player && player->playback)
+        player->playback->Command(player,PLAYBACK_CLOSE, NULL);
+
+    if(player)
+        free(player);
+    player = NULL;
+*/
+#endif
 }
 
 DEFINE_REF(eServiceMP3);
@@ -395,20 +581,35 @@
 RESULT eServiceMP3::connectEvent(const Slot2<void,iPlayableService*,int> &event, ePtr<eConnection> &connection)
 {
 	connection = new eConnection((iPlayableService*)this, m_event.connect(event));
+#if defined(__sh__)
+	m_event(this, evSeekableStatusChanged);
+#endif
 	return 0;
 }
 
 RESULT eServiceMP3::start()
 {
+#if not defined(__sh__)
 	ASSERT(m_state == stIdle);
-
+#else
+	if(m_state != stIdle) {
+		eDebug("eServiceMP3::%s < m_state != stIdle", __func__);
+		return -1;
+	}
+#endif
 	m_state = stRunning;
+#if not defined(__sh__)
 	if (m_gst_playbin)
 	{
 		eDebug("eServiceMP3::starting pipeline");
 		gst_element_set_state (m_gst_playbin, GST_STATE_PLAYING);
 	}
-
+#else
+	if(player && player->output && player->playback) {
+        player->output->Command(player, OUTPUT_OPEN, NULL);
+        player->playback->Command(player, PLAYBACK_PLAY, NULL);
+    }
+#endif
 	m_event(this, evStart);
 
 	return 0;
@@ -416,13 +617,39 @@
 
 RESULT eServiceMP3::stop()
 {
+#if not defined(__sh__)
 	ASSERT(m_state != stIdle);
-
+#else
+	if(m_state == stIdle) {
+		eDebug("eServiceMP3::%s < m_state == stIdle", __func__);
+		return -1;
+	}
+#endif
 	if (m_state == stStopped)
 		return -1;
 
 	eDebug("eServiceMP3::stop %s", m_ref.path.c_str());
+#if not defined(__sh__)
 	gst_element_set_state(m_gst_playbin, GST_STATE_NULL);
+#else
+	if(player && player->playback && player->output) {
+        player->playback->Command(player, PLAYBACK_STOP, NULL);
+        player->output->Command(player, OUTPUT_CLOSE, NULL);
+    }
+	//Trick
+	if(player && player->output) {
+		player->output->Command(player,OUTPUT_DEL, (void*)"audio");
+		player->output->Command(player,OUTPUT_DEL, (void*)"video");
+		player->output->Command(player,OUTPUT_DEL, (void*)"subtitle");
+	}
+
+	if(player && player->playback)
+		player->playback->Command(player,PLAYBACK_CLOSE, NULL);
+	if(player)
+		free(player);
+	if(player != NULL)
+		player = NULL;
+#endif
 	m_state = stStopped;
 
 	return 0;
@@ -436,21 +663,50 @@
 RESULT eServiceMP3::pause(ePtr<iPauseableService> &ptr)
 {
 	ptr=this;
+#if defined(__sh__)
+	m_event((iPlayableService*)this, evSeekableStatusChanged);
+	m_event((iPlayableService*)this, evUpdatedInfo);
+#endif
 	return 0;
 }
 
 RESULT eServiceMP3::setSlowMotion(int ratio)
 {
+#if not defined(__sh__)
 	if (!ratio)
 		return 0;
 	eDebug("eServiceMP3::setSlowMotion ratio=%f",1/(float)ratio);
 	return trickSeek(1/(float)ratio);
+#else
+	if(player && player->playback) {
+		int result = 0;
+		if(ratio > 1) result = player->playback->Command(player, PLAYBACK_SLOWMOTION, (void*)&ratio);
+		if (result != 0)
+			return -1;
+	}
+	return 0;
+#endif
 }
 
 RESULT eServiceMP3::setFastForward(int ratio)
 {
+#if not defined(__sh__)
 	eDebug("eServiceMP3::setFastForward ratio=%i",ratio);
 	return trickSeek(ratio);
+#else
+	if(player && player->playback) {
+        	int result = 0;
+        	if(ratio > 1) result = player->playback->Command(player, PLAYBACK_FASTFORWARD, (void*)&ratio);
+		else if(ratio < -1) {
+			ratio = ratio * -1;
+			result = player->playback->Command(player, PLAYBACK_FASTBACKWARD, (void*)&ratio);
+		}
+    		else result = player->playback->Command(player, PLAYBACK_CONTINUE, NULL);
+        	if (result != 0)
+            		return -1;
+    	}
+	return 0;
+#endif
 }
 
 void eServiceMP3::seekTimeoutCB()
@@ -459,7 +715,7 @@
 	getPlayPosition(ppos);
 	getLength(len);
 	ppos += 90000*m_currentTrickRatio;
-	
+
 	if (ppos < 0)
 	{
 		ppos = 0;
@@ -478,21 +734,30 @@
 		// iPausableService
 RESULT eServiceMP3::pause()
 {
+#if not defined(__sh__)
 	if (!m_gst_playbin || m_state != stRunning)
 		return -1;
 
 	gst_element_set_state(m_gst_playbin, GST_STATE_PAUSED);
 
+#else
+	if(player && player->playback)
+        player->playback->Command(player, PLAYBACK_PAUSE, NULL);
+#endif
 	return 0;
 }
 
 RESULT eServiceMP3::unpause()
 {
+#if not defined(__sh__)
 	if (!m_gst_playbin || m_state != stRunning)
 		return -1;
 
 	gst_element_set_state(m_gst_playbin, GST_STATE_PLAYING);
-
+#else
+    if(player && player->playback)
+        player->playback->Command(player, PLAYBACK_CONTINUE, NULL);
+#endif
 	return 0;
 }
 
@@ -505,6 +770,7 @@
 
 RESULT eServiceMP3::getLength(pts_t &pts)
 {
+#if not defined(__sh__)
 	if (!m_gst_playbin)
 		return -1;
 
@@ -513,17 +779,29 @@
 
 	GstFormat fmt = GST_FORMAT_TIME;
 	gint64 len;
-	
+
 	if (!gst_element_query_duration(m_gst_playbin, &fmt, &len))
 		return -1;
 		/* len is in nanoseconds. we have 90 000 pts per second. */
-	
+
 	pts = len / 11111;
+#else
+    double length = 0;
+
+	if(player && player->playback)
+        player->playback->Command(player, PLAYBACK_LENGTH, &length);
+
+    if(length <= 0)
+        return -1;
+
+	pts = length * 90000;
+#endif
 	return 0;
 }
 
 RESULT eServiceMP3::seekToImpl(pts_t to)
 {
+#if not defined(__sh__)
 		/* convert pts to nanoseconds */
 	gint64 time_nanoseconds = to * 11111LL;
 	if (!gst_element_seek (m_gst_playbin, 1.0, GST_FORMAT_TIME, GST_SEEK_FLAG_FLUSH,
@@ -533,7 +811,8 @@
 		eDebug("eServiceMP3::seekTo failed");
 		return -1;
 	}
-
+#else
+#endif
 	return 0;
 }
 
@@ -541,6 +820,7 @@
 {
 	RESULT ret = -1;
 
+#if not defined(__sh__)
 	if (m_gst_playbin) {
 		eSingleLocker l(m_subs_to_pull_lock); // this is needed to dont handle incomming subtitles during seek!
 		if (!(ret = seekToImpl(to)))
@@ -550,10 +830,12 @@
 		}
 	}
 
+#else
+#endif
 	return ret;
 }
 
-
+#if not defined(__sh__)
 RESULT eServiceMP3::trickSeek(gdouble ratio)
 {
 	if (!m_gst_playbin)
@@ -594,10 +876,12 @@
 
 	return 0;
 }
+#endif
 
 
 RESULT eServiceMP3::seekRelative(int direction, pts_t to)
 {
+#if not defined(__sh__)
 	if (!m_gst_playbin)
 		return -1;
 
@@ -607,12 +891,17 @@
 	if (ppos < 0)
 		ppos = 0;
 	seekTo(ppos);
-	
+#else
+    float pos = direction*(to/90000.0);
+    if(player && player->playback)
+        player->playback->Command(player, PLAYBACK_SEEK, (void*)&pos);
+#endif
 	return 0;
 }
 
 RESULT eServiceMP3::getPlayPosition(pts_t &pts)
 {
+#if not defined(__sh__)
 	GstFormat fmt = GST_FORMAT_TIME;
 	gint64 pos;
 	GstElement *sink;
@@ -647,6 +936,24 @@
 
 	/* pos is in nanoseconds. we have 90 000 pts per second. */
 	pts = pos / 11111;
+#else
+	if (player && player->playback && !player->playback->isPlaying) {
+		eDebug("eServiceMP3::%s !!!!EOF!!!! < -1", __func__);
+        if(m_state == stRunning)
+		    m_event((iPlayableService*)this, evEOF);
+        pts = 0;
+		return -1;
+	}
+    unsigned long long int vpts = 0;
+    if(player && player->playback)
+        player->playback->Command(player, PLAYBACK_PTS, &vpts);
+
+    if(vpts<=0)return -1;
+
+	/* len is in nanoseconds. we have 90 000 pts per second. */
+	pts = vpts>0?vpts:pts;;
+
+#endif
 	return 0;
 }
 
@@ -658,6 +965,9 @@
 
 RESULT eServiceMP3::isCurrentlySeekable()
 {
+#ifdef __sh__
+	return 1;
+#else
 	int ret = 3; // seeking and fast/slow winding possible
 	GstElement *sink;
 
@@ -683,6 +993,7 @@
 	}
 
 	return ret;
+#endif
 }
 
 RESULT eServiceMP3::info(ePtr<iServiceInformation>&i)
@@ -708,7 +1019,9 @@
 
 int eServiceMP3::getInfo(int w)
 {
+#if not defined(__sh__)
 	const gchar *tag = 0;
+#endif
 
 	switch (w)
 	{
@@ -748,7 +1061,9 @@
 	case sTagKeywords:
 	case sTagChannelMode:
 	case sUser+12:
+#if not defined(__sh__)
 		return resIsString;
+#endif
 	case sTagTrackGain:
 	case sTagTrackPeak:
 	case sTagAlbumGain:
@@ -759,6 +1074,7 @@
 	case sTagPreviewImage:
 	case sTagAttachment:
 		return resIsPyObject;
+#if not defined(__sh__)
 	case sTagTrackNumber:
 		tag = GST_TAG_TRACK_NUMBER;
 		break;
@@ -792,22 +1108,25 @@
 	case sTagCRC:
 		tag = "has-crc";
 		break;
+#endif
 	default:
 		return resNA;
 	}
-
+#if not defined(__sh__)
 	if (!m_stream_tags || !tag)
 		return 0;
-	
+
 	guint value;
 	if (gst_tag_list_get_uint(m_stream_tags, tag, &value))
 		return (int) value;
+#endif
 
 	return 0;
 }
 
 std::string eServiceMP3::getInfoString(int w)
 {
+#if not defined(__sh__)
 	if ( !m_stream_tags && w < sUser && w > 26 )
 		return "";
 	const gchar *tag = 0;
@@ -836,7 +1155,7 @@
 		if (gst_tag_list_get_date(m_stream_tags, GST_TAG_DATE, &date))
 		{
 			gchar res[5];
- 			g_date_strftime (res, sizeof(res), "%Y-%M-%D", date); 
+ 			g_date_strftime (res, sizeof(res), "%Y-%M-%D", date);
 			return (std::string)res;
 		}
 		break;
@@ -920,9 +1239,56 @@
 		g_free(value);
 		return res;
 	}
+#else
+	char * tag = NULL;
+	switch (w)
+	{
+	case sTagTitle:
+		tag = strdup("Title");
+		break;
+	case sTagArtist:
+		tag = strdup("Artist");
+		break;
+	case sTagAlbum:
+		tag = strdup("Album");
+		break;
+	case sTagComment:
+		tag = strdup("Comment");
+		break;
+	case sTagTrackNumber:
+		tag = strdup("Track");
+		break;
+	case sTagGenre:
+		tag = strdup("Genre");
+		break;
+	case sTagDate:
+		tag = strdup("Year");
+		break;
+
+	case sTagVideoCodec:
+		tag = strdup("VideoType");
+		break;
+	case sTagAudioCodec:
+		tag = strdup("AudioType");
+		break;
+
+	default:
+		return "";
+	}
+
+	if (player && player->playback) {
+        player->playback->Command(player, PLAYBACK_INFO, &tag);
+
+		std::string res = tag;
+        free(tag);
+		return res;
+	}
+    free(tag);
+#endif
 	return "";
 }
 
+#if not defined(__sh__)
 PyObject *eServiceMP3::getInfoObject(int w)
 {
 	const gchar *tag = 0;
@@ -982,6 +1348,7 @@
 
 	return 0;
 }
+#endif
 
 RESULT eServiceMP3::audioChannel(ePtr<iAudioChannelSelection> &ptr)
 {
@@ -1014,8 +1381,10 @@
 
 int eServiceMP3::getCurrentTrack()
 {
+#if not defined(__sh__)
 	if (m_currentAudioStream == -1)
 		g_object_get (G_OBJECT (m_gst_playbin), "current-audio", &m_currentAudioStream, NULL);
+#endif
 	return m_currentAudioStream;
 }
 
@@ -1038,6 +1407,7 @@
 
 int eServiceMP3::selectAudioStream(int i)
 {
+#if not defined(__sh__)
 	int current_audio;
 	g_object_set (G_OBJECT (m_gst_playbin), "current-audio", i, NULL);
 	g_object_get (G_OBJECT (m_gst_playbin), "current-audio", &current_audio, NULL);
@@ -1048,6 +1418,13 @@
 		return 0;
 	}
 	return -1;
+#else
+	if(i!=m_currentAudioStream){
+		if(player && player->playback)
+            player->playback->Command(player, PLAYBACK_SWITCH_AUDIO, (void*)&i);
+		m_currentAudioStream=i;
+	}
+#endif
 }
 
 int eServiceMP3::getCurrentChannel()
@@ -1065,6 +1442,7 @@
 {
  	if (i >= m_audioStreams.size())
 		return -2;
+#if not defined(__sh__)
 		info.m_description = m_audioStreams[i].codec;
 /*	if (m_audioStreams[i].type == atMPEG)
 		info.m_description = "MPEG";
@@ -1084,11 +1462,28 @@
 		info.m_description = "FLAC";
 	else
 		info.m_description = "???";*/
+#else
+	if (m_audioStreams[i].type == atMPEG)
+		info.m_description = "MPEG";
+	else if (m_audioStreams[i].type == atMP3)
+		info.m_description = "MP3";
+	else if (m_audioStreams[i].type == atAC3)
+		info.m_description = "AC3";
+	else if (m_audioStreams[i].type == atAAC)
+		info.m_description = "AAC";
+	else if (m_audioStreams[i].type == atDTS)
+		info.m_description = "DTS";
+	else if (m_audioStreams[i].type == atPCM)
+		info.m_description = "PCM";
+	else if (m_audioStreams[i].type == atOGG)
+		info.m_description = "OGG";
+#endif
 	if (info.m_language.empty())
 		info.m_language = m_audioStreams[i].language_code;
 	return 0;
 }
 
+#if not defined(__sh__)
 void eServiceMP3::gstBusCall(GstBus *bus, GstMessage *msg)
 {
 	if (!msg)
@@ -1120,14 +1515,14 @@
 
 			GstState old_state, new_state;
 			gst_message_parse_state_changed(msg, &old_state, &new_state, NULL);
-		
+
 			if(old_state == new_state)
 				break;
-	
+
 			eDebug("eServiceMP3::state transition %s -> %s", gst_element_state_get_name(old_state), gst_element_state_get_name(new_state));
-	
+
 			GstStateChange transition = (GstStateChange)GST_STATE_TRANSITION(old_state, new_state);
-	
+
 			switch(transition)
 			{
 				case GST_STATE_CHANGE_NULL_TO_READY:
@@ -1187,7 +1582,7 @@
 		{
 			gchar *debug;
 			GError *inf;
-	
+
 			gst_message_parse_info (msg, &inf, &debug);
 			g_free (debug);
 			if ( inf->domain == GST_STREAM_ERROR && inf->code == GST_STREAM_ERROR_DECODE )
@@ -1202,7 +1597,7 @@
 		{
 			GstTagList *tags, *result;
 			gst_message_parse_tag(msg, &tags);
-	
+
 			result = gst_tag_list_merge(m_stream_tags, tags, GST_TAG_MERGE_REPLACE);
 			if (result)
 			{
@@ -1210,7 +1605,7 @@
 					gst_tag_list_free(m_stream_tags);
 				m_stream_tags = result;
 			}
-	
+
 			const GValue *gv_image = gst_tag_list_get_value_index(tags, GST_TAG_IMAGE, 0);
 			if ( gv_image )
 			{
@@ -1280,7 +1675,7 @@
 			}
 
 			for (i = 0; i < n_text; i++)
-			{	
+			{
 				gchar *g_lang;
 // 				gchar *g_type;
 // 				GstPad* pad = 0;
@@ -1406,11 +1801,11 @@
 
 void eServiceMP3::gstPoll(const int &msg)
 {
-		/* ok, we have a serious problem here. gstBusSyncHandler sends 
+		/* ok, we have a serious problem here. gstBusSyncHandler sends
 		   us the wakup signal, but likely before it was posted.
 		   the usleep, an EVIL HACK (DON'T DO THAT!!!) works around this.
-		   
-		   I need to understand the API a bit more to make this work 
+
+		   I need to understand the API a bit more to make this work
 		   proplerly. */
 	if (msg == 1)
 	{
@@ -1426,9 +1821,9 @@
 	else
 		pullSubtitle();
 }
-
+#endif
 eAutoInitPtr<eServiceFactoryMP3> init_eServiceFactoryMP3(eAutoInitNumbers::service+1, "eServiceFactoryMP3");
-
+#if not defined(__sh__)
 void eServiceMP3::gstCBsubtitleAvail(GstElement *appsink, gpointer user_data)
 {
 	eServiceMP3 *_this = (eServiceMP3*)user_data;
@@ -1475,9 +1870,30 @@
 	else
 		eDebug("no subtitle sink!");
 }
+#else
+void eServiceMP3::eplayerCBsubtitleAvail(long int duration_ms, size_t len, char * buffer, void* user_data)
+{
+	eDebug("eServiceMP3::%s >", __func__);
+	unsigned char tmp[len+1];
+	memcpy(tmp, buffer, len);
+	tmp[len] = 0;
+	eDebug("gstCBsubtitleAvail: %s", tmp);
+	eServiceMP3 *_this = (eServiceMP3*)user_data;
+	if ( _this->m_subtitle_widget )
+	{
+		ePangoSubtitlePage page;
+		gRGB rgbcol(0xD0,0xD0,0xD0);
+		page.m_elements.push_back(ePangoSubtitlePageElement(rgbcol, (const char*)tmp));
+		page.m_timeout = duration_ms;
+		(_this->m_subtitle_widget)->setPage(page);
+	}
+	eDebug("eServiceMP3::%s <", __func__);
+}
+#endif
 
 void eServiceMP3::pushSubtitles()
 {
+#if not defined(__sh__)
 	ePangoSubtitlePage page;
 	pts_t running_pts;
 	while ( !m_subtitle_pages.empty() )
@@ -1522,6 +1938,7 @@
 	}
 	if (m_subtitle_pages.empty())
 		pullSubtitle();
+#endif
 }
 
 RESULT eServiceMP3::enableSubtitles(eWidget *parent, ePyObject tuple)
@@ -1546,9 +1963,11 @@
 
 	if (m_currentSubtitleStream != pid)
 	{
+#if not defined(__sh__)
 		eSingleLocker l(m_subs_to_pull_lock);
 		g_object_set (G_OBJECT (m_gst_playbin), "current-text", pid, NULL);
 		m_currentSubtitleStream = pid;
+#endif
 		m_subs_to_pull = 0;
 		m_subtitle_pages.clear();
 	}
@@ -1557,9 +1976,14 @@
 	m_subtitle_widget = new eSubtitleWidget(parent);
 	m_subtitle_widget->resize(parent->size()); /* full size */
 
+#if not defined(__sh__)
 	g_object_get (G_OBJECT (m_gst_playbin), "current-text", &text_pid, NULL);
 
 	eDebug ("eServiceMP3::switched to subtitle stream %i", text_pid);
+#else
+	if(player && player->playback)
+       player->playback->Command(player, PLAYBACK_SWITCH_SUBTITLE, (void*)&pid);
+#endif
 
 	return 0;
 
@@ -1575,6 +1999,11 @@
 	m_subtitle_pages.clear();
 	delete m_subtitle_widget;
 	m_subtitle_widget = 0;
+#if defined(__sh__)
+    int pid = -1;
+    if(player && player->playback)
+       player->playback->Command(player, PLAYBACK_SWITCH_SUBTITLE, (void*)&pid);
+#endif
 	return 0;
 }
 
@@ -1587,6 +2016,15 @@
 PyObject *eServiceMP3::getSubtitleList()
 {
 	eDebug("eServiceMP3::getSubtitleList");
+#if defined(__sh__)
+    if( player &&
+        player->output &&
+        player->output->subtitle) {
+
+        player->output->subtitle->Command(player, (OutputCmd_t)222, (void*)eplayerCBsubtitleAvail);
+        player->output->subtitle->Command(player, (OutputCmd_t)223, (void*) this);
+    }
+#endif
 
 	ePyObject l = PyList_New(0);
 	int stream_count[sizeof(subtype_t)];
@@ -1629,7 +2067,9 @@
 int eServiceMP3::setBufferSize(int size)
 {
 	m_buffer_size = size;
+#if not defined(__sh__)
 	g_object_set (G_OBJECT (m_gst_playbin), "buffer-size", m_buffer_size, NULL);
+#endif
 	return 0;
 }
 
@@ -1645,6 +2085,7 @@
 
 void eServiceMP3::setAC3Delay(int delay)
 {
+#if not defined(__sh__)
 	ac3_delay = delay;
 	if (!m_gst_playbin || m_state != stRunning)
 		return;
@@ -1678,10 +2119,12 @@
 			gst_object_unref(sink);
 		}
 	}
+#endif
 }
 
 void eServiceMP3::setPCMDelay(int delay)
 {
+#if not defined(__sh__)
 	pcm_delay = delay;
 	if (!m_gst_playbin || m_state != stRunning)
 		return;
@@ -1722,8 +2165,9 @@
 			gst_object_unref(sink);
 		}
 	}
+#endif
 }
 
-#else
-#warning gstreamer not available, not building media player
-#endif
+//#else
+//#warning gstreamer not available, not building media player
+//#endif
diff -Nur enigma2-nightly/lib/service/servicemp3.h enigma2-nightly.spark/lib/service/servicemp3.h
--- enigma2-nightly/lib/service/servicemp3.h	2010-08-11 18:16:49.831720082 +0800
+++ enigma2-nightly.spark/lib/service/servicemp3.h	2010-08-11 18:12:24.845569797 +0800
@@ -1,13 +1,23 @@
 #ifndef __servicemp3_h
 #define __servicemp3_h
-
-#ifdef HAVE_GSTREAMER
+//#if not defined(__sh__)
+//#ifdef HAVE_GSTREAMER
+//#endif
 #include <lib/base/message.h>
 #include <lib/service/iservice.h>
 #include <lib/dvb/pmt.h>
 #include <lib/dvb/subtitle.h>
 #include <lib/dvb/teletext.h>
+#if not defined(__sh__)
 #include <gst/gst.h>
+#else
+#include <common.h>
+#define gint int
+extern OutputHandler_t		OutputHandler;
+extern PlaybackHandler_t	PlaybackHandler;
+extern ContainerHandler_t	ContainerHandler;
+extern ManagerHandler_t		ManagerHandler;
+#endif
 /* for subtitles */
 #include <lib/gui/esubtitle.h>
 
@@ -44,7 +54,9 @@
 	int getInfo(const eServiceReference &ref, int w);
 };
 
+#if not defined(__sh__)
 typedef struct _GstElement GstElement;
+#endif
 
 typedef enum { atUnknown, atMPEG, atMP3, atAC3, atDTS, atAAC, atPCM, atOGG, atFLAC } audiotype_t;
 typedef enum { stPlainText, stSSA, stSRT } subtype_t;
@@ -102,7 +114,9 @@
 	RESULT getName(std::string &name);
 	int getInfo(int w);
 	std::string getInfoString(int w);
+#if not defined(__sh__)
 	PyObject *getInfoObject(int w);
+#endif
 
 		// iAudioTrackSelection	
 	int getNumberOfTracks();
@@ -131,6 +145,7 @@
 	void setAC3Delay(int);
 	void setPCMDelay(int);
 
+#if not defined(__sh__)
 	struct audioStream
 	{
 		GstPad* pad;
@@ -163,6 +178,39 @@
 		{
 		}
 	};
+#else
+	struct audioStream
+	{
+		audiotype_t type;
+		std::string language_code; /* iso-639, if available. */
+		std::string codec; /* clear text codec description */
+		audioStream()
+			:type(atUnknown)
+		{
+		}
+	};
+	struct subtitleStream
+	{
+		subtype_t type;
+		std::string language_code; /* iso-639, if available. */
+		int id;
+		subtitleStream()
+		{
+		}
+	};
+	struct sourceStream
+	{
+		audiotype_t audiotype;
+		containertype_t containertype;
+		bool is_video;
+		bool is_streaming;
+		sourceStream()
+			:audiotype(atUnknown), containertype(ctNone), is_video(false), is_streaming(false)
+		{
+		}
+	};
+#endif
+
 	struct bufferInfo
 	{
 		int bufferPercent;
@@ -197,31 +245,42 @@
 		stIdle, stRunning, stStopped,
 	};
 	int m_state;
+#if not defined(__sh__)
 	GstElement *m_gst_playbin;
 	GstTagList *m_stream_tags;
+#else
+	Context_t * player;
+#endif
 	eFixedMessagePump<int> m_pump;
 	std::string m_error_message;
 
+#if not defined(__sh__)
 	audiotype_t gstCheckAudioPad(GstStructure* structure);
 	void gstBusCall(GstBus *bus, GstMessage *msg);
 	static GstBusSyncReply gstBusSyncHandler(GstBus *bus, GstMessage *message, gpointer user_data);
 	static void gstCBsubtitleAvail(GstElement *element, gpointer user_data);
 	GstPad* gstCreateSubtitleSink(eServiceMP3* _this, subtype_t type);
 	void gstPoll(const int&);
-
+#else
+	static void eplayerCBsubtitleAvail(long int duration_ns, size_t len, char * buffer, void* user_data);
+#endif
 	std::list<ePangoSubtitlePage> m_subtitle_pages;
 	ePtr<eTimer> m_subtitle_sync_timer;
 	void pushSubtitles();
 	void pullSubtitle();
 	int m_subs_to_pull;
 	eSingleLock m_subs_to_pull_lock;
+#if not defined(__sh__)
 	gulong m_subs_to_pull_handler_id;
-
+#endif
 	RESULT seekToImpl(pts_t to);
 
 	gint m_aspect, m_width, m_height, m_framerate, m_progressive;
+#if not defined(__sh__)
 	RESULT trickSeek(gdouble ratio);
-};
 #endif
-
+};
 #endif
+//#if not defined(__sh__)
+//#endif
+//#endif
diff -Nur enigma2-nightly/m4/progtest.m4 enigma2-nightly.spark/m4/progtest.m4
--- enigma2-nightly/m4/progtest.m4	1970-01-01 08:00:00.000000000 +0800
+++ enigma2-nightly.spark/m4/progtest.m4	2010-08-11 18:12:24.882616509 +0800
@@ -0,0 +1,92 @@
+# progtest.m4 serial 4 (gettext-0.14.2)
+dnl Copyright (C) 1996-2003, 2005 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+dnl
+dnl This file can can be used in projects which are not available under
+dnl the GNU General Public License or the GNU Library General Public
+dnl License but which still want to provide support for the GNU gettext
+dnl functionality.
+dnl Please note that the actual code of the GNU gettext library is covered
+dnl by the GNU Library General Public License, and the rest of the GNU
+dnl gettext package package is covered by the GNU General Public License.
+dnl They are *not* in the public domain.
+
+dnl Authors:
+dnl   Ulrich Drepper <drepper@cygnus.com>, 1996.
+
+AC_PREREQ(2.50)
+
+# Search path for a program which passes the given test.
+
+dnl AM_PATH_PROG_WITH_TEST(VARIABLE, PROG-TO-CHECK-FOR,
+dnl   TEST-PERFORMED-ON-FOUND_PROGRAM [, VALUE-IF-NOT-FOUND [, PATH]])
+AC_DEFUN([AM_PATH_PROG_WITH_TEST],
+[
+# Prepare PATH_SEPARATOR.
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  echo "#! /bin/sh" >conf$$.sh
+  echo  "exit 0"   >>conf$$.sh
+  chmod +x conf$$.sh
+  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
+    PATH_SEPARATOR=';'
+  else
+    PATH_SEPARATOR=:
+  fi
+  rm -f conf$$.sh
+fi
+
+# Find out how to test for executable files. Don't use a zero-byte file,
+# as systems may use methods other than mode bits to determine executability.
+cat >conf$$.file <<_ASEOF
+#! /bin/sh
+exit 0
+_ASEOF
+chmod +x conf$$.file
+if test -x conf$$.file >/dev/null 2>&1; then
+  ac_executable_p="test -x"
+else
+  ac_executable_p="test -f"
+fi
+rm -f conf$$.file
+
+# Extract the first word of "$2", so it can be a program name with args.
+set dummy $2; ac_word=[$]2
+AC_MSG_CHECKING([for $ac_word])
+AC_CACHE_VAL(ac_cv_path_$1,
+[case "[$]$1" in
+  [[\\/]]* | ?:[[\\/]]*)
+    ac_cv_path_$1="[$]$1" # Let the user override the test with a path.
+    ;;
+  *)
+    ac_save_IFS="$IFS"; IFS=$PATH_SEPARATOR
+    for ac_dir in ifelse([$5], , $PATH, [$5]); do
+      IFS="$ac_save_IFS"
+      test -z "$ac_dir" && ac_dir=.
+      for ac_exec_ext in '' $ac_executable_extensions; do
+        if $ac_executable_p "$ac_dir/$ac_word$ac_exec_ext"; then
+          echo "$as_me: trying $ac_dir/$ac_word..." >&AS_MESSAGE_LOG_FD
+          if [$3]; then
+            ac_cv_path_$1="$ac_dir/$ac_word$ac_exec_ext"
+            break 2
+          fi
+        fi
+      done
+    done
+    IFS="$ac_save_IFS"
+dnl If no 4th arg is given, leave the cache variable unset,
+dnl so AC_PATH_PROGS will keep looking.
+ifelse([$4], , , [  test -z "[$]ac_cv_path_$1" && ac_cv_path_$1="$4"
+])dnl
+    ;;
+esac])dnl
+$1="$ac_cv_path_$1"
+if test ifelse([$4], , [-n "[$]$1"], ["[$]$1" != "$4"]); then
+  AC_MSG_RESULT([$]$1)
+else
+  AC_MSG_RESULT(no)
+fi
+AC_SUBST($1)dnl
+])
diff -Nur enigma2-nightly/main/bsod.cpp enigma2-nightly.spark/main/bsod.cpp
--- enigma2-nightly/main/bsod.cpp	2010-08-11 18:16:49.832904391 +0800
+++ enigma2-nightly.spark/main/bsod.cpp	2010-08-11 18:12:24.846574001 +0800
@@ -15,7 +15,11 @@
 
 /************************************************/
 
+#if defined(__sh__)  
+#define CRASH_EMAILADDR "nobody" 
+#else 
 #define CRASH_EMAILADDR "crashlog@dream-multimedia-tv.de"
+#endif
 #define STDBUFFER_SIZE 512
 #define RINGBUFFER_SIZE 16384
 static char ringbuffer[RINGBUFFER_SIZE];
diff -Nur enigma2-nightly/main/enigma.cpp enigma2-nightly.spark/main/enigma.cpp
--- enigma2-nightly/main/enigma.cpp	2010-08-11 18:16:49.834765065 +0800
+++ enigma2-nightly.spark/main/enigma.cpp	2010-08-11 18:12:24.849552690 +0800
@@ -29,6 +29,11 @@
 #include <lib/python/connections.h>
 #include <lib/python/python.h>
 
+#if defined(__sh__)  
+#include <lib/driver/vfd.h>  
+#include "include/shmE2.h"
+char *shm = NULL;
+#endif  
 #include "bsod.h"
 
 #ifdef HAVE_GSTREAMER
@@ -127,6 +132,10 @@
 
 int main(int argc, char **argv)
 {
+#if defined(__sh__)  
+        shm = createshm();
+        system("enigma2.sh");
+#endif
 #ifdef MEMLEAK_CHECK
 	atexit(DumpUnfreed);
 #endif
@@ -235,6 +244,12 @@
 	gRC::getInstance()->setSpinnerDC(my_dc);
 
 	eRCInput::getInstance()->keyEvent.connect(slot(keyEvent));
+
+#if defined(__sh__)  
+	evfd * vfd = new evfd;  
+	vfd->init();  
+	delete vfd;  
+#endif  
 	
 	printf("executing main\n");
 	
diff -Nur enigma2-nightly/main/Makefile.am enigma2-nightly.spark/main/Makefile.am
--- enigma2-nightly/main/Makefile.am	2010-08-11 18:16:49.832904391 +0800
+++ enigma2-nightly.spark/main/Makefile.am	2010-08-11 18:12:24.851513304 +0800
@@ -68,7 +68,7 @@
 	@LIBUNGIF_LIBS@ \
 	@XML2_LIBS@ \
 	@XMLCCWRAP_LIBS@ \
-	-ldl -lpthread -lcrypt -lresolv -lrt
+	-ldl -lpthread -lcrypt -lresolv -lrt -leplayer2  
 
 enigma2$(EXEEXT): $(enigma2_OBJECTS) $(enigma2_DEPENDENCIES) $(enigma2_LDADD_WHOLE)
 #	@rm -f enigma2$(EXEEXT)
diff -Nur enigma2-nightly/Makefile.am enigma2-nightly.spark/Makefile.am
--- enigma2-nightly/Makefile.am	2010-08-11 18:16:49.427655572 +0800
+++ enigma2-nightly.spark/Makefile.am	2010-08-11 18:12:24.876889100 +0800
@@ -1,3 +1,5 @@
+ACLOCAL_AMFLAGS = -I m4
+
 SUBDIRS = include lib main data po tools
 
 installdir = $(pkglibdir)/python
diff -Nur enigma2-nightly/mytest.py enigma2-nightly.spark/mytest.py
--- enigma2-nightly/mytest.py	2010-08-11 18:16:49.835759505 +0800
+++ enigma2-nightly.spark/mytest.py	2010-08-11 18:12:24.852821956 +0800
@@ -300,6 +300,10 @@
 
 		self.pushCurrent()
 		dlg = self.current_dialog = self.instantiateDialog(screen, *arguments, **kwargs)
+#+++>
+		if dlg is None:
+			return
+#+++<
 		dlg.isTmp = True
 		dlg.callback = None
 		self.execBegin()
@@ -368,6 +372,10 @@
 		action = config.usage.on_long_powerpress.value
 		if action == "shutdown":
 			self.shutdown()
+#+++>
+		elif action == "standby":
+			self.standby()
+#+++<
 		elif action == "show_menu":
 			print "Show shutdown Menu"
 			root = mdom.getroot()
@@ -500,10 +508,17 @@
 	if wakeupList:
 		from time import strftime
 		startTime = wakeupList[0]
-		if (startTime[0] - nowTime) < 270: # no time to switch box back on
-			wptime = nowTime + 30  # so switch back on in 30 seconds
-		else:
-			wptime = startTime[0] - 240
+#+++>
+#-		if (startTime[0] - nowTime) < 270: # no time to switch box back on
+#-			wptime = nowTime + 30  # so switch back on in 30 seconds
+#-		else:
+#-			wptime = startTime[0] - 240
+
+	        if (startTime[0] - nowTime) < 330: # no time to switch box back on
+		       wptime = nowTime + 30  # so switch back on in 30 seconds
+	        else:
+		       wptime = startTime[0] - 300
+#+++<
 		if not config.misc.useTransponderTime.value:
 			print "dvb time sync disabled... so set RTC now to current linux time!", strftime("%Y/%m/%d %H:%M", localtime(nowTime))
 			setRTCtime(nowTime)
diff -Nur enigma2-nightly/RecordTimer.py enigma2-nightly.spark/RecordTimer.py
--- enigma2-nightly/RecordTimer.py	2010-08-11 18:16:49.429749129 +0800
+++ enigma2-nightly.spark/RecordTimer.py	2010-08-11 18:12:24.864592256 +0800
@@ -292,6 +292,12 @@
 						RecordTimerEntry.TryQuitMainloop() # start shutdown handling without screen
 					else:
 						Notifications.AddNotificationWithCallback(self.sendTryQuitMainloopNotification, MessageBox, _("A finished record timer wants to shut down\nyour Dreambox. Shutdown now?"), timeout = 20)
+                        elif self.afterEvent == AFTEREVENT.AUTO:
+                                if not Screens.Standby.inTryQuitMainloop: # not a shutdown messagebox is open
+                                        timerStart = open("/proc/stb/fp/was_timer_wakeup").read()
+                                        if timerStart[:1] == "1":
+						Notifications.AddNotificationWithCallback(self.sendTryQuitMainloopNotification, MessageBox, _("A finished record timer wants to shut down\nyour Dreambox. Shutdown now?"), timeout = 20) 
+
 			return True
 
 	def setAutoincreaseEnd(self, entry = None):
