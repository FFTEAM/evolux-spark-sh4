diff -Nur '--exclude-from=neutrino-hd_ignore' neutrino-hd2-exp.org/acinclude.m4 neutrino-hd2-exp/acinclude.m4
--- neutrino-hd2-exp.org/acinclude.m4	2012-08-25 22:02:02.410886888 +0200
+++ neutrino-hd2-exp/acinclude.m4	2012-08-25 22:02:02.586796676 +0200
@@ -225,10 +225,10 @@
 AC_DEFUN([_TUXBOX_APPS_LIB_PKGCONFIG],[
 AC_REQUIRE([TUXBOX_APPS_PKGCONFIG])
 AC_MSG_CHECKING(for package $2)
-if PKG_CONFIG_PATH="${prefix}/lib/pkgconfig" $PKG_CONFIG --exists "$2" ; then
+if $PKG_CONFIG --exists "$2" ; then
 	AC_MSG_RESULT(yes)
-	$1_CFLAGS=$(PKG_CONFIG_PATH="${prefix}/lib/pkgconfig" $PKG_CONFIG --cflags "$2")
-	$1_LIBS=$(PKG_CONFIG_PATH="${prefix}/lib/pkgconfig" $PKG_CONFIG --libs "$2")
+	$1_CFLAGS=$($PKG_CONFIG --cflags "$2")
+	$1_LIBS=$($PKG_CONFIG --libs "$2")
 else
 	AC_MSG_RESULT(no)
 fi
diff -Nur '--exclude-from=neutrino-hd_ignore' neutrino-hd2-exp.org/src/nhttpd/web/scripts/Makefile.am neutrino-hd2-exp/src/nhttpd/web/scripts/Makefile.am
--- neutrino-hd2-exp.org/src/nhttpd/web/scripts/Makefile.am	2012-08-25 22:01:57.585361584 +0200
+++ neutrino-hd2-exp/src/nhttpd/web/scripts/Makefile.am	2012-08-25 22:02:02.586796676 +0200
@@ -3,5 +3,5 @@
 install_DATA= api.sh _Y_Globals.sh _Y_Library.sh Y_Live.sh Y_Tools.sh
 
 install-data-hook:
-	chmod 0755 $(DATADIR)/neutrino/httpd/scripts/api.sh
-	chmod 0755 $(DATADIR)/neutrino/httpd/scripts/Y_*.sh
+	chmod 0755 $(DESTDIR)$(DATADIR)/neutrino/httpd/scripts/api.sh
+	chmod 0755 $(DESTDIR)$(DATADIR)/neutrino/httpd/scripts/Y_*.sh

--- neutrino-hd2-exp/src/neutrino.cpp	2012-09-15 11:56:48.587543661 +0200
+++ neutrino-hd2-exp/src/neutrino.cpp	2012-09-15 12:19:28.134285299 +0200
@@ -4364,15 +4364,15 @@
 		{
 			if ( msg == CRCInput::RC_plus ) 
 			{ 
-				if (g_settings.current_volume < 100 - 2)
-					g_settings.current_volume += 2;
+				if (g_settings.current_volume < 100 - 5)
+					g_settings.current_volume += 5;
 				else
 					g_settings.current_volume = 100;
 			}
 			else if ( msg == CRCInput::RC_minus ) 
 			{ 
-				if (g_settings.current_volume > 2)
-					g_settings.current_volume -= 2;
+				if (g_settings.current_volume > 5)
+					g_settings.current_volume -= 5;
 				else
 					g_settings.current_volume = 0;
 			}

--- neutrino-hd2-exp/src/neutrino_menue.cpp	2012-09-15 14:50:56.875353938 +0200
+++ neutrino-hd2-exp/src/neutrino_menue.cpp	2012-09-15 15:25:50.261734480 +0200
@@ -449,7 +449,7 @@
 1080p30 
 PC
 */
-#define VIDEOMENU_VIDEOMODE_OPTION_COUNT 11
+#define VIDEOMENU_VIDEOMODE_OPTION_COUNT 12
 const CMenuOptionChooser::keyval VIDEOMENU_VIDEOMODE_OPTIONS[VIDEOMENU_VIDEOMODE_OPTION_COUNT] =
 {
 	{ VIDEO_STD_PAL, NONEXISTANT_LOCALE, "PAL"		},
@@ -460,8 +460,9 @@
 	{ VIDEO_STD_1080I60, NONEXISTANT_LOCALE, "1080i 60Hz"	},
 	{ VIDEO_STD_720P60, NONEXISTANT_LOCALE, "720p 60Hz"	},
 	{ VIDEO_STD_1080P24, NONEXISTANT_LOCALE, "1080p 24Hz"	},
	{ VIDEO_STD_1080P25, NONEXISTANT_LOCALE, "1080p 25Hz"	},
 	{ VIDEO_STD_1080P30, NONEXISTANT_LOCALE, "1080p 30Hz"	},
+	{ VIDEO_STD_1080P50, NONEXISTANT_LOCALE, "1080p 50Hz"	},
 	{ VIDEO_STD_PC, NONEXISTANT_LOCALE, "PC"		}
 };
 #else

--- neutrino-hd2-exp/lib/libcoolstream/video_cs.h	2012-09-15 15:33:26.543997058 +0200
+++ neutrino-hd2-exp/lib/libcoolstream/video_cs.h	2012-09-15 15:41:34.622417315 +0200
@@ -85,6 +85,7 @@
 	VIDEO_STD_1080P24,
 	VIDEO_STD_1080P25,
 	VIDEO_STD_1080P30,
+	VIDEO_STD_1080P50,
 	VIDEO_STD_PC
 };
 #else

--- neutrino-hd2-exp/lib/libcoolstream/video_cs.cpp	2012-09-15 15:49:33.400791440 +0200
+++ neutrino-hd2-exp/lib/libcoolstream/video_cs.cpp	2012-09-15 16:01:09.544243442 +0200
@@ -356,6 +356,7 @@
 		{"VIDEO_STD_1080P24", "1080p24"},
 		{"VIDEO_STD_1080P25", "1080p25"},
 		{"VIDEO_STD_1080P30", "1080p30"},
+		{"VIDEO_STD_1080P50", "1080p50"},
 		{"VIDEO_STD_PC", "PC"},
 	};
 #else


--- neutrino-hd2-exp/src/gui/extra_menu.h	1970-01-01 01:00:00.000000000 +0100
+++ neutrino-hd2-exp/src/gui/extra_menu.h	2012-10-07 11:50:18.569922562 +0200
@@ -0,0 +1,119 @@
+/*
+Neutrino-GUI - DBoxII-Project
+
+Copyright (C) 2001 Steffen Hehn 'McClean'
+Homepage: http://dbox.cyberphoria.org/
+
+Kommentar:
+
+Diese GUI wurde von Grund auf neu programmiert und sollte nun vom
+Aufbau und auch den Ausbaumoeglichkeiten gut aussehen. Neutrino basiert
+auf der Client-Server Idee, diese GUI ist also von der direkten DBox-
+Steuerung getrennt. Diese wird dann von Daemons uebernommen.
+
+
+License: GPL
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#ifndef __extramenu__
+#define __extramenu__
+
+#include <string>
+#include <vector>
+
+#include <driver/framebuffer.h>
+#include <system/lastchannel.h>
+#include <system/setting_helpers.h>
+#include <configfile.h>
+
+#define EXTRA_SETTINGS_FILE CONFIGDIR "/extra.conf"
+
+class CExtraMenuSetup : public CMenuWidget
+{
+	private:
+		int width, selected;
+		int showExtraMenuSetup();
+	public:
+		CExtraMenuSetup();
+		~CExtraMenuSetup();
+		int exec(CMenuTarget* parent, const std::string & actionKey);
+};
+
+class EMU_Menu : public CMenuTarget
+{
+	private:
+		int width, selected;
+		int suspended;
+		int installed_count;
+		int update_installed();
+		int update_selected();
+	public:
+		struct emu_list
+		{
+			const char *procname;
+			const char *start_command;
+			const char *stop_command;
+			bool installed;
+			CMenuForwarderNonLocalized *cmf;
+		};
+		int get_installed_count();
+		EMU_Menu();
+		void hide();
+		int exec(CMenuTarget* parent, const std::string & actionKey);
+		void EMU_Menu_Settings();
+		void suspend();
+		void resume();
+
+};
+
+class KernelOptions_Menu : public CMenuTarget
+{
+	private:
+		int width, selected;
+		struct module {
+			std::string comment;
+			std::vector<std::pair <std::string,std::string> > moduleList;
+			int active_orig;
+			int active;
+			bool installed;
+		};
+		std::vector<module> modules;
+		void load();
+		void save();
+	public:
+		KernelOptions_Menu();
+		void hide();
+		int exec(CMenuTarget* parent, const std::string & actionKey);
+		void Settings();
+		bool isEnabled(std::string name);
+		bool Enable(std::string name, bool active);
+};
+
+class CEvoluxSoftwareUpdate : public CMenuTarget
+{
+	private:
+		int width, selected;
+	public:
+		CEvoluxSoftwareUpdate();
+		bool CheckUpdate();
+		void hide();
+		int exec(CMenuTarget* parent, const std::string & actionKey);
+		void Settings();
+};
+
+#endif //__extramenu__
+// vim:ts=4

--- neutrino-hd2-exp/src/gui/extra_menu.cpp	1970-01-01 01:00:00.000000000 +0100
+++ neutrino-hd2-exp/src/gui/extra_menu.cpp	2012-10-07 11:47:18.241028504 +0200
@@ -0,0 +1,1018 @@
+#define __USE_FILE_OFFSET64 1
+#include <gui/filebrowser.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/sysinfo.h>
+#include <sys/vfs.h>
+#include <sys/wait.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <sstream>
+#include <iostream>
+#include <fstream>
+#include <map>
+#include <string>
+#include <unistd.h>
+#include <libnet.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+
+#include <system/debug.h>
+#include <system/safe_system.h>
+#include <system/set_threadname.h>
+
+#include <global.h>
+#include <neutrino.h>
+
+#include "zapit/channel.h"
+
+#include <driver/fontrenderer.h>
+#include <driver/rcinput.h>
+#include <daemonc/remotecontrol.h>
+
+#include "widget/menue.h"
+#include "widget/messagebox.h"
+#include "widget/hintbox.h"
+#include "widget/colorchooser.h"
+#include "widget/lcdcontroler.h"
+#include "widget/keychooser.h"
+
+#include "widget/stringinput.h"
+#include "widget/stringinput_ext.h"
+
+#include "driver/screen_max.h"
+
+#include "bouquetlist.h"
+#include "color.h"
+#include "eventlist.h"
+#include "infoviewer.h"
+
+#include "extra_menu.h"
+
+#define ONOFF_OPTION_COUNT 2
+const CMenuOptionChooser::keyval ONOFF_OPTIONS[ONOFF_OPTION_COUNT] = {
+	{ 0, LOCALE_OPTIONS_OFF },
+	{ 1, LOCALE_OPTIONS_ON }
+};
+
+#define BOOT_OPTION_COUNT 5
+const CMenuOptionChooser::keyval BOOT_OPTIONS[BOOT_OPTION_COUNT] =
+{
+#define BOOT_NEUTRINO 0
+#define BOOT_E2       1
+#define BOOT_NHDTWO   2
+#define BOOT_SPARK    3
+#define BOOT_VDR      4
+
+	{ BOOT_E2, LOCALE_EXTRAMENU_BOOT_ENIGMA2 },
+	{ BOOT_NEUTRINO, LOCALE_EXTRAMENU_BOOT_UNCHANGED },
+	{ BOOT_NHDTWO, LOCALE_EXTRAMENU_BOOT_NHDTWO },
+	{ BOOT_SPARK, LOCALE_EXTRAMENU_BOOT_SPARK },
+	{ BOOT_VDR, LOCALE_EXTRAMENU_BOOT_VDR }
+};
+
+#define SWAP_OPTION_COUNT 4
+const CMenuOptionChooser::keyval SWAP_OPTIONS[SWAP_OPTION_COUNT] =
+{
+#define KEY_SWAP_SWAPOFF 0
+#define KEY_SWAP_SWAPRAM 1
+#define KEY_SWAP_SWAPPART 2
+#define KEY_SWAP_SWAPFILE 3
+	{ KEY_SWAP_SWAPOFF, LOCALE_OPTIONS_OFF },
+	{ KEY_SWAP_SWAPRAM, LOCALE_EXTRAMENU_SWAP_SWAPRAM },
+	{ KEY_SWAP_SWAPPART, LOCALE_EXTRAMENU_SWAP_SWAPPART },
+	{ KEY_SWAP_SWAPFILE, LOCALE_EXTRAMENU_SWAP_SWAPFILE }
+};
+
+static int touch(const char *filename) {
+	int fn = open(filename, O_RDWR | O_CREAT, 0644);
+	if (fn > -1) {
+		close(fn);
+		return -1;
+	}
+	return 0;
+}
+
+CExtraMenuSetup::CExtraMenuSetup(void)
+{
+	width = w_max (40, 10);
+    selected = -1;
+	CNeutrinoApp::getInstance()->EmuMenu = new EMU_Menu();
+	CNeutrinoApp::getInstance()->ExtraMenu = this;
+}
+
+CExtraMenuSetup::~CExtraMenuSetup()
+{
+}
+
+int CExtraMenuSetup::exec(CMenuTarget* parent, const std::string &actionKey)
+{
+	int   res = menu_return::RETURN_REPAINT;
+
+	if(actionKey == "tunerreset-usermenu" || actionKey == "tunerreset") {
+		CHintBox *hintBox = new CHintBox(LOCALE_EXTRAMENU_TUNERRESET, g_Locale->getText(LOCALE_EXTRAMENU_TUNERRESET_RESTARTING));
+		hintBox->paint();
+		safe_system("/usr/local/bin/pzapit -esb;sleep 2;/usr/local/bin/pzapit -lsb;sleep 2;/usr/local/bin/pzapit -rz");
+		hintBox->hide();
+		delete hintBox;
+
+		if (actionKey == "tunerreset-usermenu")
+			return menu_return::RETURN_EXIT_ALL;
+		return res;
+	}
+
+	if (parent)
+			parent->hide();
+
+	res = showExtraMenuSetup();
+
+	return res;
+}
+
+int CExtraMenuSetup::showExtraMenuSetup()
+{
+	CMenuWidget* m = new CMenuWidget(LOCALE_EXTRAMENU_SETTINGS, NEUTRINO_ICON_SETTINGS, width);
+	selected = m->getSelected();
+	int shortcut = 1;
+
+	m->addIntroItems(NONEXISTANT_LOCALE);
+
+	m->addItem(new CMenuForwarder(LOCALE_EXTRAMENU_EMU, true, NULL, 
+		CNeutrinoApp::getInstance()->EmuMenu, NULL, CRCInput::RC_red, NEUTRINO_ICON_BUTTON_RED));
+
+	m->addItem(new CMenuForwarder(LOCALE_EXTRAMENU_TUNERRESET, true, "",
+		this, "tunerreset", CRCInput::RC_red, NEUTRINO_ICON_BUTTON_GREEN));
+
+	m->addItem(new CMenuForwarder(LOCALE_EXTRAMENU_KERNELOPTIONS, true, NULL,
+		new KernelOptions_Menu(), NULL, CRCInput::convertDigitToKey(shortcut++)));
+
+// >> FritzCallMonitor support, part 1 of 2
+#define DOTFILE_FRITZCALL "/etc/.fritzcall"
+	int fritzcall = access(DOTFILE_FRITZCALL, F_OK) ? 0 : 1;
+	int old_fritzcall = fritzcall;
+	m->addItem(new CMenuOptionChooser(LOCALE_EXTRAMENU_FRITZCALL, &fritzcall,
+		ONOFF_OPTIONS, ONOFF_OPTION_COUNT, true, NULL,
+		CRCInput::convertDigitToKey(shortcut++)));
+// << FritzCallMonitor support, part 1 of 2
+
+// >> NFS-Server support, part 1 of 2
+#define DOTFILE_NFSSERVER "/etc/.nfsserver"
+	char ip[16] = {0};
+	char mask[16] = {0};
+	char broadcast[16] = {0};
+	netGetIP(g_settings.ifname, ip, mask, broadcast);
+	int nfsserver = access(DOTFILE_NFSSERVER, F_OK) ? 0 : 1;
+	int old_nfsserver = nfsserver;
+	m->addItem(new CMenuOptionChooser(LOCALE_EXTRAMENU_NFSSERVER, &nfsserver,
+		ONOFF_OPTIONS, ONOFF_OPTION_COUNT, *ip, NULL,
+		CRCInput::convertDigitToKey(shortcut++)));
+// << NFS-Server support, part 1 of 2
+
+// >> File System Check, part 1 of 2
+#define DOTFILE_FSCK_BOOT "/etc/.fsck_boot"
+#define DOTFILE_FSCK_SHUTDOWN "/etc/.fsck"
+	int fsck_boot = access(DOTFILE_FSCK_BOOT, F_OK) ? 0 : 1;
+	int fsck_shutdown = access(DOTFILE_FSCK_SHUTDOWN, F_OK) ? 0 : 1;
+	int old_fsck_boot = fsck_boot;
+	int old_fsck_shutdown = fsck_shutdown;
+	m->addItem(new CMenuOptionChooser(LOCALE_EXTRAMENU_FSCK_BOOT, &fsck_boot,
+		ONOFF_OPTIONS, ONOFF_OPTION_COUNT, true, NULL,
+		CRCInput::convertDigitToKey(shortcut++)));
+	m->addItem(new CMenuOptionChooser(LOCALE_EXTRAMENU_FSCK_SHUTDOWN, &fsck_shutdown,
+		ONOFF_OPTIONS, ONOFF_OPTION_COUNT, true, NULL,
+		CRCInput::convertDigitToKey(shortcut++)));
+// << File System Check, part 1 of 2
+
+// >> Swap support, part 1 of 2
+#define DOTFILE_SWAPON  "/etc/.swapon"
+#define DOTFILE_SWAPRAM "/etc/.swapram"
+#define DOTFILE_SWAPPART "/etc/.swappart"
+#define DOTFILE_SWAPFILE "/etc/.swapfile"
+	int swap = access(DOTFILE_SWAPON, F_OK) ? KEY_SWAP_SWAPOFF : -1;
+	if (swap != KEY_SWAP_SWAPOFF) {
+		if (!access(DOTFILE_SWAPRAM, F_OK))
+			swap = KEY_SWAP_SWAPRAM;
+		else if (!access(DOTFILE_SWAPPART, F_OK))
+			swap = KEY_SWAP_SWAPPART;
+		else if (!access(DOTFILE_SWAPFILE, F_OK))
+			swap = KEY_SWAP_SWAPFILE;
+	}
+	int old_swap = swap;
+	m->addItem(new CMenuOptionChooser(LOCALE_EXTRAMENU_SWAP_SELECT, &swap, SWAP_OPTIONS, SWAP_OPTION_COUNT, true, NULL,
+		CRCInput::convertDigitToKey(shortcut++)));
+// << Swap support, part 1 of 2
+
+// >> Boot Selection, part 1 of 2
+#define DOTFILE_BOOT_E2 "/etc/.start_enigma2"
+#define DOTFILE_BOOT_SPARK "/etc/.start_spark"
+#define DOTFILE_BOOT_NHDTWO "/etc/.nhd2"
+#define DOTFILE_BOOT_VDR "/etc/.start_vdr"
+	int boot = BOOT_NEUTRINO;
+	if (!access(DOTFILE_BOOT_SPARK, F_OK))
+		boot = BOOT_SPARK;
+	else if (!access(DOTFILE_BOOT_E2, F_OK))
+		boot = BOOT_E2;
+	else if (!access(DOTFILE_BOOT_NHDTWO, F_OK))
+		boot = BOOT_NHDTWO;
+	else if (!access(DOTFILE_BOOT_VDR, F_OK))
+		boot = BOOT_VDR;
+	int old_boot = boot;
+
+	int boot_options_start = 0;
+	int boot_option_count = BOOT_OPTION_COUNT;
+	if (access("/usr/local/bin/enigma2", X_OK))
+		boot_options_start++, boot_option_count--;;
+	if (access("/usr/local/bin/vdr", X_OK))
+		boot_option_count--;
+
+	m->addItem(new CMenuOptionChooser(LOCALE_EXTRAMENU_BOOT_HEAD, &boot,
+		&BOOT_OPTIONS[boot_options_start], boot_option_count, true, NULL,
+		CRCInput::convertDigitToKey(shortcut++)));
+// << Boot Selection, part 1 of 2
+
+	int res = m->exec (NULL, "");
+	m->hide ();
+	m->setSelected(selected);
+	delete m;
+
+	std::string hintText = "";
+
+// >> Swap support, part 2 of 2
+	if (old_swap != swap) {
+		switch (old_swap) {
+		case KEY_SWAP_SWAPFILE:
+			system("swapoff /dev/loop0 ; losetup -d /dev/loop0");
+		case KEY_SWAP_SWAPRAM:
+		case KEY_SWAP_SWAPPART:
+			system("swapoff -a");
+			if (hintText.length())
+				hintText += "\n";
+			hintText += "SWAP " + string(g_Locale->getText(SWAP_OPTIONS[old_swap].value)) + " " + string(g_Locale->getText(LOCALE_EXTRAMENU_ENABLED));
+		}
+
+		unlink(DOTFILE_SWAPON);
+		unlink(DOTFILE_SWAPRAM);
+		unlink(DOTFILE_SWAPPART);
+		unlink(DOTFILE_SWAPFILE);
+
+		switch(swap) {
+		case KEY_SWAP_SWAPRAM:
+			touch(DOTFILE_SWAPRAM);
+			break;
+		case KEY_SWAP_SWAPPART:
+			touch(DOTFILE_SWAPPART);
+			break;
+		case KEY_SWAP_SWAPFILE:
+			touch(DOTFILE_SWAPFILE);
+			break;
+		}
+		if (swap != KEY_SWAP_SWAPOFF) {
+			touch(DOTFILE_SWAPON);
+			safe_system("/etc/init.d/Swap.sh >/dev/null 2>&1 &");
+			if (hintText.length())
+				hintText += "\n";
+			hintText += "SWAP " + string(g_Locale->getText(SWAP_OPTIONS[swap].value)) + " " + string(g_Locale->getText(LOCALE_EXTRAMENU_ENABLED));
+		}
+	}
+// << Swap support, part 2 of 2
+
+// >> FritzCallMonitor support, part 2 of 2
+	if (old_fritzcall != fritzcall) {
+		if (hintText.length())
+			hintText += "\n";
+		hintText += string(g_Locale->getText(LOCALE_EXTRAMENU_FRITZCALL)) + " ";
+		if (fritzcall) {
+			touch(DOTFILE_FRITZCALL);
+			safe_system("/var/plugins/fritzcall/fb.sh start >/dev/null 2>&1 &");
+			hintText += string(g_Locale->getText(LOCALE_EXTRAMENU_ENABLED));
+		} else {
+			unlink(DOTFILE_FRITZCALL);
+			safe_system("/var/plugins/fritzcall/fb.sh stop >/dev/null 2>&1 &");
+			hintText += string(g_Locale->getText(LOCALE_EXTRAMENU_DISABLED));
+		}
+	}
+// << FritzCallMonitor support, part 2 of 2
+
+// >> NFS-Server support, part 2 of 2
+	if (old_nfsserver != nfsserver) {
+		if (hintText.length())
+			hintText += "\n";
+		hintText += string(g_Locale->getText(LOCALE_EXTRAMENU_NFSSERVER)) + " ";
+		if (nfsserver) {
+			struct sockaddr_in ip_sin;
+			struct sockaddr_in mask_sin;
+			inet_aton(ip, &ip_sin.sin_addr);
+			inet_aton(mask, &mask_sin.sin_addr);
+			ip_sin.sin_addr.s_addr &= mask_sin.sin_addr.s_addr;
+			strncpy(ip, inet_ntoa(ip_sin.sin_addr), sizeof(ip));
+			touch(DOTFILE_NFSSERVER);
+			char cmd[1024];
+			snprintf(cmd, sizeof(cmd),
+				"sed 's@/media/hdd.*@/media/hdd %s/%s(rw,async,no_root_squash)@g' -i /etc/exports;"
+				"/etc/init.d/nfs-common start;/etc/init.d/nfs-kernel-server start",
+				ip, mask);
+			safe_system(cmd);
+			hintText += string(g_Locale->getText(LOCALE_EXTRAMENU_ENABLED));
+		} else {
+			unlink(DOTFILE_NFSSERVER);
+			safe_system("/etc/init.d/nfs-kernel-server stop;/etc/init.d/nfs-common stop");
+			hintText += string(g_Locale->getText(LOCALE_EXTRAMENU_DISABLED));
+		}
+	}
+// << NFS-Server support, part 2 of 2
+
+// >> File System Check, part 2 of 2
+	if (old_fsck_boot != fsck_boot) {
+		if (hintText.length())
+			hintText += "\n";
+		hintText += string(g_Locale->getText(LOCALE_EXTRAMENU_FSCK_BOOT)) + " ";
+		if (fsck_boot) {
+			touch(DOTFILE_FSCK_BOOT);
+			hintText += string(g_Locale->getText(LOCALE_EXTRAMENU_ENABLED));
+		} else {
+			unlink(DOTFILE_FSCK_BOOT);
+			hintText += string(g_Locale->getText(LOCALE_EXTRAMENU_DISABLED));
+		}
+	}
+	if (old_fsck_shutdown != fsck_shutdown) {
+		if (hintText.length())
+			hintText += "\n";
+		hintText += string(g_Locale->getText(LOCALE_EXTRAMENU_FSCK_SHUTDOWN)) + " ";
+		if (fsck_shutdown) {
+			touch(DOTFILE_FSCK_SHUTDOWN);
+			hintText += string(g_Locale->getText(LOCALE_EXTRAMENU_ENABLED));
+		} else {
+			unlink(DOTFILE_FSCK_SHUTDOWN);
+			hintText += string(g_Locale->getText(LOCALE_EXTRAMENU_DISABLED));
+		}
+	}
+// << File System Check, part 2 of 2
+
+// >> Boot Selection, part 2 of 2
+	if (boot != old_boot)
+	{
+		char tmp[200];
+		CHintBox *hintBox;
+		switch (old_boot) {
+		case BOOT_SPARK:
+			unlink(DOTFILE_BOOT_SPARK);
+			hintBox = new CHintBox(LOCALE_EXTRAMENU_BOOT_BOOTARGS_HEAD, g_Locale->getText(LOCALE_EXTRAMENU_BOOT_BOOTARGS_TEXT));
+			hintBox->paint();
+			system("fw_setenv -s /etc/bootargs_evolux");
+			hintBox->hide();
+			delete hintBox;
+			break;
+		case BOOT_E2:
+			unlink(DOTFILE_BOOT_E2);
+			break;
+		case BOOT_NHDTWO:
+			unlink(DOTFILE_BOOT_NHDTWO);
+			break;
+		case BOOT_VDR:
+			unlink(DOTFILE_BOOT_VDR);
+			break;
+		case BOOT_NEUTRINO:
+			break;
+		}
+		FILE *f = fopen("/etc/enigma2/settings", "r");
+		switch (boot) {
+		case BOOT_E2:
+			if (f) {
+				touch(DOTFILE_BOOT_E2);
+				if (hintText.length())
+					hintText += "\n";
+				snprintf(tmp, sizeof(tmp), g_Locale->getText(LOCALE_EXTRAMENU_BOOT_CHANGED),
+					g_Locale->getText(LOCALE_EXTRAMENU_BOOT_ENIGMA2));
+				hintText += string(tmp);
+				fclose(f);
+			}
+			break;
+		case BOOT_NHDTWO:
+			touch(DOTFILE_BOOT_NHDTWO);
+			if (hintText.length())
+				hintText += "\n";
+			snprintf(tmp, sizeof(tmp), g_Locale->getText(LOCALE_EXTRAMENU_BOOT_CHANGED),
+				g_Locale->getText(LOCALE_EXTRAMENU_BOOT_NHDTWO));
+			hintText += string(tmp);
+			break;
+		case BOOT_VDR:
+			touch(DOTFILE_BOOT_VDR);
+			if (hintText.length())
+				hintText += "\n";
+			snprintf(tmp, sizeof(tmp), g_Locale->getText(LOCALE_EXTRAMENU_BOOT_CHANGED),
+				g_Locale->getText(LOCALE_EXTRAMENU_BOOT_VDR));
+			hintText += string(tmp);
+			break;
+		case BOOT_NEUTRINO:
+			if (hintText.length())
+				hintText += "\n";
+			hintText += string(g_Locale->getText(LOCALE_EXTRAMENU_BOOT_THIS));
+			break;
+		case BOOT_SPARK:
+			touch(DOTFILE_BOOT_SPARK);
+			hintBox = new CHintBox(LOCALE_EXTRAMENU_BOOT_BOOTARGS_HEAD, g_Locale->getText(LOCALE_EXTRAMENU_BOOT_BOOTARGS_TEXT));
+			hintBox->paint();
+			system("fw_setenv -s /etc/bootargs_orig");
+			hintBox->hide();
+			delete hintBox;
+			if (hintText.length())
+				hintText += "\n";
+			char tmp[200];
+			snprintf(tmp, sizeof(tmp), g_Locale->getText(LOCALE_EXTRAMENU_BOOT_CHANGED),
+					g_Locale->getText(LOCALE_EXTRAMENU_BOOT_SPARK));
+			hintText += string(tmp);
+			break;
+		}
+	}
+// << Boot Selection, part 2 of 2
+
+	if (hintText.length())
+		ShowHintUTF(LOCALE_MESSAGEBOX_INFO, hintText.c_str(), 450, 2);
+
+	return res;
+}
+
+
+static struct {
+#define EXTRA_CAM_SELECTED "cam_selected"
+        std::string	cam_selected;
+#ifdef ENABLE_GRAPHLCD
+#define GLCD_ENABLE "glcd_enable"
+        int	glcd_enable;
+#define GLCD_COLOR_FG "glcd_color_fg"
+        uint32_t	glcd_color_fg;
+#define GLCD_COLOR_BG "glcd_color_bg"
+        uint32_t	glcd_color_bg;
+#define GLCD_COLOR_BAR "glcd_color_bar"
+        uint32_t	glcd_color_bar;
+#define GLCD_FONT "glcd_font"
+        string		glcd_font;
+#define GLCD_SIZE_CHANNEL "glcd_percent_channel"
+        int		glcd_percent_channel;
+#define GLCD_SIZE_EPG "glcd_percent_epg"
+        int		glcd_percent_epg;
+#define GLCD_SIZE_BAR "glcd_percent_bar"
+        int		glcd_percent_bar;
+#define GLCD_SIZE_TIME "glcd_percent_time"
+        int		glcd_percent_time;
+#define GLCD_MIRROR_OSD "glcd_mirror_osd"
+        int		glcd_mirror_osd;
+#define GLCD_TIME_IN_STANDBY "glcd_time_in_standby"
+        int		glcd_time_in_standby;
+#endif
+} settings;
+
+CConfigFile *configfile = NULL;
+
+static bool saveSettings() {
+	if (configfile) {
+		configfile->setString(EXTRA_CAM_SELECTED, settings.cam_selected);
+		configfile->saveConfig(EXTRA_SETTINGS_FILE);
+		return true;
+	}
+	return false;
+}
+
+static bool initSettings() {
+	settings.cam_selected = "disabled";
+}
+
+static bool loadSettings() {
+	if (!configfile) {
+		initSettings();
+		configfile = new CConfigFile('=');
+		if (configfile->loadConfig(EXTRA_SETTINGS_FILE)) {
+			settings.cam_selected = configfile->getString(EXTRA_CAM_SELECTED, "disabled");
+			return true;
+		}
+	}
+	return false;
+}
+
+////////////////////////////// EMU Menu START ////////////////////////////////////
+
+#define EMU_OPTION_COUNT 7
+static EMU_Menu::emu_list EMU_list[EMU_OPTION_COUNT] =
+{
+	  { "mgcamd", "rm -f /tmp/camd.socket >/dev/null; /usr/bin/mgcamd /var/keys/mg_cfg >/dev/null 2>&1 &", "kill -9 $(pidof mgcamd)", false }
+	, { "incubusCamd", "rm -f /tmp/camd.socket 2>/dev/null ; /usr/bin/incubusCamd >/dev/null 2>&1 &", "kill -9 $(pidof incubusCamd)", false }
+	, { "camd3", "/usr/bin/camd3 /var/keys/camd3.config >/dev/null 2>&1 &", "kill -9 $(pidof camd3)", false }
+	, { "mbox", "/usr/bin/mbox /var/keys/mbox.cfg >/dev/null 2>&1 &", "kill -9 $(pidof mbox) ; rm -f /tmp/share.* /tmp/mbox.ver /tmp/*.info 2>/dev/null", false }
+	, { "oscam", "/usr/bin/oscam -b -c /var/keys >/dev/null 2>&1 &", "kill -9 $(pidof oscam)", false }
+	, { "spcs", "/usr/bin/spcs -c /var/keys >/dev/null 2>&1 &", "kill -9 $(pidof spcs)", false }
+	, { "gbox", "/usr/bin/gbox >/dev/null 2>&1 &", "touch /tmp/gbox.kill", false }
+};
+
+int EMU_Menu::get_installed_count() {
+	return installed_count;
+}
+
+int EMU_Menu::update_installed()
+{
+	installed_count = 0;
+
+	for (int i = 0; i < EMU_OPTION_COUNT; i++) {
+		string e = "/usr/bin/" + string(EMU_list[i].procname);
+		if (!access(e.c_str(), X_OK)) {
+			EMU_list[i].installed = true;
+			installed_count++;
+		}
+	}
+
+	return installed_count;
+}
+
+int EMU_Menu::update_selected()
+{
+	for (int i = 0; i < EMU_OPTION_COUNT; i++)
+		if (!settings.cam_selected.compare(EMU_list[i].procname) && EMU_list[i].installed){
+			selected = i;
+			break;
+		}
+	return selected;
+}
+
+static bool is_scrambled(void){
+	bool res = true;
+	CChannelList *channelList = CNeutrinoApp::getInstance()->channelList;
+	if (!channelList)
+		return res;
+	int curnum = channelList->getActiveChannelNumber();
+	if (curnum < -1)
+		return res;
+	CZapitChannel *channel = channelList->getChannel(curnum);
+	if (!channel)
+		return res;
+	return channel->scrambled ? true : false;
+}
+
+EMU_Menu::EMU_Menu()
+{
+	width = w_max (40, 10);
+	selected = -1;
+	suspended = false;
+
+	loadSettings();
+	update_installed();
+	update_selected();
+
+	if (selected > -1){
+		bool scrambled = false;
+		ifstream zc (CONFIGDIR "/zapit/zapit.conf");
+		string line;
+		while (zc.good() && !scrambled)
+			if (getline(zc, line) && !line.compare((line, "lastChannelTVScrambled=true")))
+					scrambled = true;
+		zc.close();
+
+		string cmd = "( sleep 2;" + string(EMU_list[selected].start_command)
+			+ ( scrambled ? "sleep 2 ; /usr/local/bin/pzapit -rz" : "" )
+			+ " >/dev/null 2>&1) &";
+		safe_system(cmd.c_str());
+	}
+	for (int i = 0; i < EMU_OPTION_COUNT; i++)
+		EMU_list[i].cmf = NULL;
+}
+
+int EMU_Menu::exec(CMenuTarget* parent, const std::string & actionKey)
+{
+	int res = menu_return::RETURN_REPAINT;
+
+	bool doReset = false;
+	int emu = EMU_OPTION_COUNT;
+
+	if(actionKey == "disable") {
+		emu = -1;
+	} else if (actionKey == "reset") {
+		doReset = true;
+		emu = selected;
+	} else if (actionKey == "reset-usermenu") {
+		doReset = true;
+		emu = selected;
+		res = menu_return::RETURN_EXIT_ALL;
+	} else
+		for (emu = 0; emu < EMU_OPTION_COUNT; emu++)
+			if (!strcmp(EMU_list[emu].procname, actionKey.c_str()))
+				break;
+
+	if (emu < EMU_OPTION_COUNT) {
+		if (selected > -1) {
+			safe_system(EMU_list[selected].stop_command);
+			string m = " " + string(EMU_list[selected].procname) + " " + g_Locale->getText(LOCALE_EXTRAMENU_DISABLED);
+			ShowHintUTF(LOCALE_MESSAGEBOX_INFO, m.c_str(), 450, 2); // UTF-8("")
+			if (EMU_list[selected].cmf)
+				EMU_list[selected].cmf->setOptionValue(g_Locale->getText(LOCALE_OPTIONS_OFF));
+		}
+		if (emu > -1 && (emu != selected || doReset)) {
+			safe_system(EMU_list[emu].start_command);
+
+			string cmd = "(" + string(EMU_list[emu].start_command);
+			if (is_scrambled())
+				safe_system("sleep 2; /usr/local/bin/pzapit -rz >/dev/null 2>&1");
+			string m = " " + string(EMU_list[emu].procname) + " " + g_Locale->getText(LOCALE_EXTRAMENU_ENABLED);
+			ShowHintUTF(LOCALE_MESSAGEBOX_INFO, m.c_str(), 450, 2); // UTF-8("")
+			if (EMU_list[emu].cmf)
+				EMU_list[emu].cmf->setOptionValue(g_Locale->getText(LOCALE_OPTIONS_ON));
+			settings.cam_selected = string(EMU_list[emu].procname);
+			selected = emu;
+		} else
+			selected = -1;
+		return res;
+	}
+
+	if (parent)
+		parent->hide();
+
+	EMU_Menu_Settings();
+
+	return res;
+}
+
+void EMU_Menu::hide()
+{
+}
+
+void EMU_Menu::EMU_Menu_Settings()
+{
+	int emu = selected;
+	int emu_old = emu;
+
+	update_installed();
+
+	CMenuWidget* menu = new CMenuWidget(LOCALE_EXTRAMENU_EMU, "settings");
+	menu->addItem(GenericMenuSeparator);
+	menu->addItem(GenericMenuBack);
+	menu->addItem(GenericMenuSeparatorLine);
+
+	int shortcut = 1;
+	for (int i = 0; i < EMU_OPTION_COUNT; i++)
+		if (EMU_list[i].installed) {
+			EMU_list[i].cmf = new CMenuForwarderNonLocalized(EMU_list[i].procname, true,
+				g_Locale->getText((i == selected) ? LOCALE_OPTIONS_ON : LOCALE_OPTIONS_OFF),
+				this, EMU_list[i].procname, CRCInput::convertDigitToKey(shortcut++));
+			menu->addItem(EMU_list[i].cmf, (i == selected));
+		}
+
+	menu->addItem(GenericMenuSeparatorLine);
+	menu->addItem(new CMenuForwarder(LOCALE_EXTRAMENU_EMU_RESTART, true, "", this, "reset",
+			CRCInput::RC_red, NEUTRINO_ICON_BUTTON_RED));
+	menu->addItem(new CMenuForwarder(LOCALE_EXTRAMENU_EMU_DISABLE, true, "", this, "disable",
+			CRCInput::RC_blue, NEUTRINO_ICON_BUTTON_BLUE));
+
+	menu->exec(NULL, "");
+        menu->hide();
+        delete menu;
+	saveSettings();
+}
+
+void EMU_Menu::suspend()
+{
+	if (selected > -1 && !suspended) {
+		safe_system(EMU_list[selected].stop_command);
+		suspended = true;
+	}
+}
+
+void EMU_Menu::resume()
+{
+	if (selected  > -1 && suspended) {
+		safe_system(EMU_list[selected].start_command);
+		if (is_scrambled())
+			safe_system("sleep 2; /usr/local/bin/pzapit -rz >/dev/null 2>&1");
+		suspended = false;
+	}
+}
+
+////////////////////////////// EMU Menu END //////////////////////////////////////
+
+KernelOptions_Menu::KernelOptions_Menu()
+{
+	width = w_max (40, 10);
+}
+
+int KernelOptions_Menu::exec(CMenuTarget* parent, const std::string & actionKey)
+{
+	int res = menu_return::RETURN_REPAINT;
+
+	if (actionKey == "reset") {
+		for (int i = 0; i < modules.size(); i++)
+			modules[i].active = modules[i].active_orig;
+		return res;
+	}
+
+	if (actionKey == "apply" || actionKey == "change") {
+		bool needs_save = false;
+		for (int i = 0; i < modules.size(); i++)
+			if (modules[i].active != modules[i].active_orig) {
+				needs_save = true;
+				for (int i = 0; i < modules.size(); i++) {
+					char buf[80];
+					if (modules[i].active)
+						for (int j = 0; j < modules[i].moduleList.size(); j++) {
+							snprintf(buf, sizeof(buf), "insmod /lib/modules/%s.ko %s",
+								modules[i].moduleList[j].first.c_str(), modules[i].moduleList[j].second.c_str());
+							system(buf);
+						}
+					else
+						for (int j = 0; j < modules[i].moduleList.size(); j++) {
+							snprintf(buf, sizeof(buf), "rmmod %s", modules[i].moduleList[j].first.c_str());
+							system(buf);
+						}
+					modules[i].active_orig = modules[i].active;
+				}
+				break;
+			}
+		if (needs_save)
+			save();
+		if (actionKey == "change")
+			return res; // whatever
+	}
+
+	if (actionKey == "apply" || actionKey == "lsmod") {
+		for (int i = 0; i < modules.size(); i++)
+			modules[i].installed = false;
+		FILE *f = fopen("/proc/modules", "r");
+		if (f) {
+			char buf[200];
+			while (fgets(buf, sizeof(buf), f)) {
+				char name[200];
+				if (1 == sscanf(buf, "%s", name))
+					for (int i = 0; i < modules.size(); i++) {
+						if (name == modules[i].moduleList.back().first) {
+							modules[i].installed = true;
+							break;
+						}
+				}
+			}
+			fclose(f);
+		}
+
+		string text = "";
+		for (int i = 0; i < modules.size(); i++) {
+			text += modules[i].comment + " (" + modules[i].moduleList.back().first + ") ";
+			// FIXME, localizations are missing (but rather not worth adding)
+			if (modules[i].active) {
+				if (modules[i].installed)
+					text += "is enabled and loaded\n";
+				else
+					text += "is enabled but not loaded\n";
+			} else {
+				if (modules[i].installed)
+					text += "is disabled but loaded\n";
+				else
+					text += "is disabled and not loaded\n";
+			}
+		}
+
+		ShowHintUTF(LOCALE_EXTRAMENU_KERNELOPTIONS_LSMOD, text.c_str());
+
+		return res;
+	}
+
+	if (parent)
+		parent->hide();
+
+	Settings();
+
+	return res;
+}
+
+void KernelOptions_Menu::hide()
+{
+}
+
+bool KernelOptions_Menu::isEnabled(string name) {
+	load();
+	for (int i = 0; i < modules.size(); i++)
+		if (name == modules[i].moduleList.back().first)
+			return modules[i].active;
+	return false;
+}
+
+bool KernelOptions_Menu::Enable(string name, bool active) {
+	load();
+	for (int i = 0; i < modules.size(); i++)
+		if (name == modules[i].moduleList.back().first) {
+				if (modules[i].active != active) {
+					modules[i].active = active;
+					exec(NULL, "change");
+				}
+				return true;
+		}
+	return false;
+}
+
+void KernelOptions_Menu::load() {
+	modules.clear();
+
+	FILE *f = fopen("/etc/modules.available", "r");
+	// Syntax:
+	//
+	// # comment
+	// module # description
+	// module module module # description
+	// module module(arguments) module # description
+	//
+
+	if (f) {
+		char buf[200];
+		while (fgets(buf, sizeof(buf), f)) {
+			if (buf[0] == '#')
+				continue;
+			char *comment = strchr(buf, '#');
+			if (!comment)
+				continue;
+			*comment++ = 0;
+			while (*comment == ' ' || *comment == '\t')
+				comment++;
+			if (strlen(comment) < 1)
+				continue;
+			module m;
+			m.active = m.active_orig = 0;
+			m.installed = false;
+			char *nl = strchr(comment, '\n');
+			if (nl)
+				*nl = 0;
+			m.comment = string(comment);
+			char *b = buf;
+			while (*b) {
+				if (*b == ' ' || *b == '\t') {
+					b++;
+					continue;
+				}
+				string args = "";
+				string mod;
+				char *e = b;
+				char *a = NULL;
+				while (*e && (a && *e != ')' || (!a && *e != ' ' && *e != '\t'))) {
+					if (*e == '(')
+						a = e;
+					e++;
+				}
+				if (a && *e == ')') {
+					*a++ = 0;
+					*e++ = 0;
+					args = string (a);
+					*a = 0;
+					mod = string(b);
+					b = e;
+				} else if (*e) {
+					*e++ = 0;
+					mod = string(b);
+					b = e;
+				} else {
+					mod = string(b);
+					b = e;
+				}
+				m.moduleList.push_back(make_pair(mod, args));
+			}
+			if (m.moduleList.size() > 0)
+				modules.push_back(m);
+		}
+		fclose(f);
+	}
+
+	f = fopen("/etc/modules.extra", "r");
+	if (f) {
+		char buf[200];
+		while (fgets(buf, sizeof(buf), f)) {
+			char *t = strchr(buf, '#');
+			if (t)
+				*t = 0;
+			char name[200];
+			if (1 == sscanf(buf, "%s", name)) {
+				int i;
+				for (i = 0; i < modules.size(); i++)
+					if (modules[i].moduleList.back().first == name) {
+						modules[i].active = modules[i].active_orig = 1;
+						break;
+					}
+			}
+		}
+		fclose(f);
+	}
+}
+
+void KernelOptions_Menu::save()
+{
+	FILE *f = fopen("/etc/modules.extra", "w");
+	if (f) {
+		chmod("/etc/modules.extra", 0644);
+		for (int i = 0; i < modules.size(); i++) {
+			if (modules[i].active) {
+				for (int j = 0; j < modules[i].moduleList.size(); j++)
+					if (modules[i].moduleList[j].second.length())
+						fprintf(f, "%s %s\n",
+							modules[i].moduleList[j].first.c_str(),
+							modules[i].moduleList[j].second.c_str());
+					else
+						fprintf(f, "%s\n",
+							modules[i].moduleList[j].first.c_str());
+			}
+		}
+		fclose(f);
+	}
+}
+
+void KernelOptions_Menu::Settings()
+{
+	CMenuWidget* menu = new CMenuWidget(LOCALE_EXTRAMENU_KERNELOPTIONS, "settings");
+	menu->addItem(GenericMenuSeparator);
+	menu->addItem(GenericMenuBack);
+	menu->addItem(new CMenuSeparator(CMenuSeparator::LINE | CMenuSeparator::STRING, LOCALE_EXTRAMENU_KERNELOPTIONS_MODULES));
+
+	load();
+
+	int shortcut = 0;
+
+	for (int i = 0; i < modules.size(); i++) {
+		menu->addItem(new CMenuOptionChooser(modules[i].comment.c_str(), &modules[i].active,
+				ONOFF_OPTIONS, ONOFF_OPTION_COUNT, true));
+	}
+
+	menu->addItem(GenericMenuSeparatorLine);
+
+	menu->addItem(new CMenuForwarder(LOCALE_EXTRAMENU_KERNELOPTIONS_RESET, true, "", this,
+		"reset", CRCInput::RC_red, NEUTRINO_ICON_BUTTON_RED));
+	menu->addItem(new CMenuForwarder(LOCALE_EXTRAMENU_KERNELOPTIONS_APPLY, true, "", this,
+		"apply", CRCInput::RC_green, NEUTRINO_ICON_BUTTON_GREEN));
+	menu->addItem(new CMenuForwarder(LOCALE_EXTRAMENU_KERNELOPTIONS_LSMOD, true, "", this,
+		"lsmod", CRCInput::RC_yellow, NEUTRINO_ICON_BUTTON_YELLOW));
+	menu->exec (NULL, "");
+	menu->hide ();
+	delete menu;
+}
+
+////////////////////////////// EVOLUXUPDATE Menu START ////////////////////////////////////
+CEvoluxSoftwareUpdate::CEvoluxSoftwareUpdate()
+{
+	width = w_max (40, 10);
+}
+
+int CEvoluxSoftwareUpdate::exec(CMenuTarget* parent, const std::string & actionKey)
+{
+	int res = menu_return::RETURN_REPAINT;
+	if(actionKey == "checkupdate") 
+	{
+		this->CheckUpdate();
+		return res;
+	}
+
+	if (parent)
+		parent->hide();
+
+	Settings();
+
+	return res;
+}
+
+void CEvoluxSoftwareUpdate::hide()
+{
+}
+
+void CEvoluxSoftwareUpdate::Settings()
+{
+	//MENU AUFBAUEN
+	CMenuWidget* menu = new CMenuWidget(LOCALE_EXTRAMENU_EVOLUXUPDATE, "settings");
+	menu->addItem(GenericMenuSeparator);
+	menu->addItem(GenericMenuBack);
+	menu->addItem(GenericMenuSeparatorLine);
+	menu->addItem(new CMenuForwarder(LOCALE_EXTRAMENU_EVOLUXUPDATE_UPDATE, true, "", this, "checkupdate", CRCInput::RC_red, NEUTRINO_ICON_BUTTON_RED));
+	menu->exec (NULL, "");
+	menu->hide ();
+	delete menu;
+}
+
+bool CEvoluxSoftwareUpdate::CheckUpdate()
+{
+	//EVOLUXUPDATE STARTEN
+	unlink("/tmp/EvoluxUpdatevailable");
+	safe_system("oVersion=`wget -q -O - http://tinyurl.com/7gz7jpo | grep version | cut -d = -f2`;"
+		   "lVersion=`grep version /etc/.version | cut -d = -f2`;"
+		   "[ \"$lVersion\" != \"$oVersion\" ] && touch /tmp/EvoluxUpdatevailable");
+	CHintBox *hintBox;
+	if(!access("/tmp/EvoluxUpdatevailable", F_OK)) {
+		hintBox = new CHintBox(LOCALE_EXTRAMENU_EVOLUXUPDATE_UPDATE, g_Locale->getText(LOCALE_EXTRAMENU_EVOLUXUPDATE_UPDATING));
+		hintBox->paint();
+		safe_system("wget -O - -q http://tinyurl.com/7fjrnm3 | tee /tmp/update.tar.gz | tar -tzf - && tar -xpzf /tmp/update.tar.gz -C /");
+		unlink("/tmp/EvoluxUpdatevailable");
+		unlink("/tmp/update.tar.gz");
+		hintBox->hide();
+		delete hintBox;
+		hintBox = new CHintBox(LOCALE_EXTRAMENU_EVOLUXUPDATE_UPDATE, g_Locale->getText(LOCALE_EXTRAMENU_EVOLUXUPDATE_DONE));
+	} else
+		hintBox = new CHintBox(LOCALE_EXTRAMENU_EVOLUXUPDATE_UPDATE, g_Locale->getText(LOCALE_EXTRAMENU_EVOLUXUPDATE_NOTFOUND));
+
+	hintBox->paint();
+	sleep(3);
+	hintBox->hide();
+	delete hintBox;
+}
+//ENDE EVOLUXUPDATE
+
+////////////////////////////// EVOLUXUPDATE Menu ENDE //////////////////////////////////////
+// vim:ts=4

--- neutrino-hd2-exp/data/locale/deutsch.locale	2012-10-06 20:57:02.446038511 +0200
+++ neutrino-hd2-exp/data/locale/deutsch.locale	2012-10-07 11:57:00.591916212 +0200
@@ -358,6 +358,44 @@
 extra.zapit_sdt_changed Kanalliste wird neu geladen.
 extra.zapit_sort_names Sortiere Kanal nach Name
 extra.zapit_write_names Schreibe Kanalname
+extramenu.boot.bootargs.head Änderung der Boot-Parameter
+extramenu.boot.bootargs.text Bitte den Receiver nicht ausschalten!
+extramenu.boot.changed %s wird bei Neustart aktiv. Bitte rebooten!
+extramenu.boot.enigma2 E2
+extramenu.boot.head Boot-Einstellungen
+extramenu.boot.nhdtwo NTRINO-HD2
+extramenu.boot.select Startsystem bei Neustart
+extramenu.boot.spark Spark
+extramenu.boot.this Kein Wechsel bei Reboot.
+extramenu.boot.unchanged Unverändert
+extramenu.boot.vdr VDR
+extramenu.disabled wurde deaktiviert.
+extramenu.emu Cam-Einstellungen
+extramenu.emu.disable CAM deaktivieren
+extramenu.emu.restart CAM neu starten
+extramenu.emu.select CAM Auswahl
+extramenu.enabled ist nun aktiv.
+extramenu.evoluxupdate Evolux Online-Update
+extramenu.evoluxupdate.done Aktualisierung ist beendet, bitte jetzt rebooten!
+extramenu.evoluxupdate.notfound Keine Updates verfügbar!
+extramenu.evoluxupdate.update Online-Update ausführen
+extramenu.evoluxupdate.updating Update gefunden, Aktualisierung wird ausgeführt.
+extramenu.fritzcall FritzCallMonitor
+extramenu.fsck.boot Filesystem-Check bei Boot
+extramenu.fsck.shutdown Filesystem-Check bei Shutdown
+extramenu.kerneloptions Kernel-Optionen
+extramenu.kerneloptions.apply Einstellungen anwenden
+extramenu.kerneloptions.lsmod Status
+extramenu.kerneloptions.modules Kernel-Module
+extramenu.kerneloptions.reset Einstellungen zurücksetzen
+extramenu.nfsserver NFS-Server
+extramenu.settings Extras
+extramenu.swap.select Swap (Speicher-Auslagerung)
+extramenu.swap.swapfile Datei
+extramenu.swap.swappart Partition
+extramenu.swap.swapram RAM
+extramenu.tunerreset Tuner neu starten
+extramenu.tunerreset.restarting Tuner wird neu gestartet
 fan_speed Lüfter-Speed (1=min, 5=max)
 favorites.addchannel Der aktuelle Kanal wird dem Bouquet \n"Meine Favoriten" hinzugefügt. \nDie Speicherung benötigt einen Moment...
 favorites.bouquetname Meine Favoriten

--- neutrino-hd2-exp/src/system/locals.h	2012-10-06 20:57:00.350028112 +0200
+++ neutrino-hd2-exp/src/system/locals.h	2012-10-07 12:00:39.181000152 +0200
@@ -1242,6 +1242,44 @@
 	LOCALE_EXTRA_LOGO,
 	LOCALE_EXTRA_SCAN_FULL,
 	LOCALE_EXTRA_SCAN_FAST,
+	LOCALE_EXTRAMENU_BOOT_BOOTARGS_HEAD,
+	LOCALE_EXTRAMENU_BOOT_BOOTARGS_TEXT,
+	LOCALE_EXTRAMENU_BOOT_CHANGED,
+	LOCALE_EXTRAMENU_BOOT_ENIGMA2,
+	LOCALE_EXTRAMENU_BOOT_HEAD,
+	LOCALE_EXTRAMENU_BOOT_NHDTWO,
+	LOCALE_EXTRAMENU_BOOT_SELECT,
+	LOCALE_EXTRAMENU_BOOT_SPARK,
+	LOCALE_EXTRAMENU_BOOT_THIS,
+	LOCALE_EXTRAMENU_BOOT_UNCHANGED,
+	LOCALE_EXTRAMENU_BOOT_VDR,
+	LOCALE_EXTRAMENU_DISABLED,
+	LOCALE_EXTRAMENU_EMU,
+	LOCALE_EXTRAMENU_EMU_DISABLE,
+	LOCALE_EXTRAMENU_EMU_RESTART,
+	LOCALE_EXTRAMENU_EMU_SELECT,
+	LOCALE_EXTRAMENU_ENABLED,
+	LOCALE_EXTRAMENU_EVOLUXUPDATE,
+	LOCALE_EXTRAMENU_EVOLUXUPDATE_DONE,
+	LOCALE_EXTRAMENU_EVOLUXUPDATE_NOTFOUND,
+	LOCALE_EXTRAMENU_EVOLUXUPDATE_UPDATE,
+	LOCALE_EXTRAMENU_EVOLUXUPDATE_UPDATING,
+	LOCALE_EXTRAMENU_FRITZCALL,
+	LOCALE_EXTRAMENU_FSCK_BOOT,
+	LOCALE_EXTRAMENU_FSCK_SHUTDOWN,
+	LOCALE_EXTRAMENU_KERNELOPTIONS,
+	LOCALE_EXTRAMENU_KERNELOPTIONS_APPLY,
+	LOCALE_EXTRAMENU_KERNELOPTIONS_LSMOD,
+	LOCALE_EXTRAMENU_KERNELOPTIONS_MODULES,
+	LOCALE_EXTRAMENU_KERNELOPTIONS_RESET,
+	LOCALE_EXTRAMENU_NFSSERVER,
+	LOCALE_EXTRAMENU_SETTINGS,
+	LOCALE_EXTRAMENU_SWAP_SELECT,
+	LOCALE_EXTRAMENU_SWAP_SWAPFILE,
+	LOCALE_EXTRAMENU_SWAP_SWAPPART,
+	LOCALE_EXTRAMENU_SWAP_SWAPRAM,
+	LOCALE_EXTRAMENU_TUNERRESET,
+	LOCALE_EXTRAMENU_TUNERRESET_RESTARTING,
 	LOCALE_HDD_SLOW,
 	LOCALE_HDD_MIDDLE,
 	LOCALE_HDD_FAST,

--- neutrino-hd2-exp/src/system/locals_intern.h	2012-10-06 20:57:00.350028112 +0200
+++ neutrino-hd2-exp/src/system/locals_intern.h	2012-10-07 12:02:58.869692831 +0200
@@ -1242,6 +1242,44 @@
 	"extra.logo",
 	"extra.scan_full",
 	"extra.scan_fast",
+	"extramenu.boot.bootargs.head",
+	"extramenu.boot.bootargs.text",
+	"extramenu.boot.changed",
+	"extramenu.boot.enigma2",
+	"extramenu.boot.head",
+	"extramenu.boot.nhdtwo",
+	"extramenu.boot.select",
+	"extramenu.boot.spark",
+	"extramenu.boot.this",
+	"extramenu.boot.unchanged",
+	"extramenu.boot.vdr",
+	"extramenu.disabled",
+	"extramenu.emu",
+	"extramenu.emu.disable",
+	"extramenu.emu.restart",
+	"extramenu.emu.select",
+	"extramenu.enabled",
+	"extramenu.evoluxupdate",
+	"extramenu.evoluxupdate.done",
+	"extramenu.evoluxupdate.notfound",
+	"extramenu.evoluxupdate.update",
+	"extramenu.evoluxupdate.updating",
+	"extramenu.fritzcall",
+	"extramenu.fsck.boot",
+	"extramenu.fsck.shutdown",
+	"extramenu.kerneloptions",
+	"extramenu.kerneloptions.apply",
+	"extramenu.kerneloptions.lsmod",
+	"extramenu.kerneloptions.modules",
+	"extramenu.kerneloptions.reset",
+	"extramenu.nfsserver",
+	"extramenu.settings",
+	"extramenu.swap.select",
+	"extramenu.swap.swapfile",
+	"extramenu.swap.swappart",
+	"extramenu.swap.swapram",
+	"extramenu.tunerreset",
+	"extramenu.tunerreset.restarting",
 	"hdd_slow",
 	"hdd_middle",
 	"hdd_fast",

--- neutrino-hd2-exp/src/neutrino_menue.cpp	2012-10-06 20:57:07.898065541 +0200
+++ neutrino-hd2-exp/src/neutrino_menue.cpp	2012-10-07 12:19:19.154553800 +0200
@@ -93,6 +93,7 @@
 #include "gui/infoviewer.h"
 #include "gui/epgview.h"
 #include "gui/epg_menu.h"
+#include "gui/extra_menu.h"
 #include "gui/update.h"
 #include "gui/scan.h"
 #include "gui/favorites.h"
@@ -202,7 +203,7 @@
 };
 
 // Init Main Menu
-void CNeutrinoApp::InitMainMenu(CMenuWidget &mainMenu, CMenuWidget &mainSettings, CMenuWidget &videoSettings, CMenuWidget &audioSettings, CMenuWidget &parentallockSettings, CMenuWidget &networkSettings, CMenuWidget &recordingSettings, CMenuWidget &colorSettings, CMenuWidget &lcdSettings, CMenuWidget &keySettings, CMenuWidget &languageSettings, CMenuWidget &miscSettings, CMenuWidget &service, CMenuWidget &audioplayerSettings, CMenuWidget &PicViewerSettings, CMenuWidget &streamingSettings, CMenuWidget &MediaPlayer)
+void CNeutrinoApp::InitMainMenu(CMenuWidget &mainMenu, CMenuWidget &mainSettings, CMenuWidget &videoSettings, CMenuWidget &audioSettings, CMenuWidget &parentallockSettings, CMenuWidget &networkSettings, CMenuWidget &recordingSettings, CMenuWidget &colorSettings, CMenuWidget &lcdSettings, CMenuWidget &keySettings, CMenuWidget &languageSettings, CMenuWidget &miscSettings, CMenuWidget &service, CMenuWidget &audioplayerSettings, CMenuWidget &PicViewerSettings, CMenuWidget &streamingSettings, CMenuWidget &MediaPlayer, CMenuWidget &ExtraMenu)
 {
 	int shortcut = 1;
 
@@ -269,6 +270,8 @@
 	//Service
 	mainMenu.addItem(new CMenuForwarderItemMenuIcon(LOCALE_MAINMENU_SERVICE, true, "", &service, NULL,CRCInput::convertDigitToKey(shortcut++), NULL, "service", LOCALE_HELPTEXT_SERVICE ));
 
+	mainMenu.addItem(new CMenuForwarder(LOCALE_MAINMENU_EXTRAMENU, true, NULL, &ExtraMenu, NULL, CRCInput::convertDigitToKey(shortcut++)));
+
 	//sleep timer
 	mainMenu.addItem( new CMenuSeparatorItemMenuIcon(CMenuSeparatorItemMenuIcon::LINE) );
 
--- neutrino-hd2-exp/src/neutrino.h	2012-10-07 12:27:39.581035280 +0200
+++ neutrino-hd2-exp/src/neutrino.h	2012-10-07 12:33:16.830707609 +0200
@@ -224,6 +224,7 @@
                         	  CMenuWidget &audioplayerSettings, 
 				  CMenuWidget &PicViewerSettings, 
 				  CMenuWidget &streamingSettings, 
+				  CMenuWidget &ExtraMenu, 
 				  CMenuWidget &MediaPlayer);
 
 		void SetupFrameBuffer();

--- neutrino-hd2-exp/src/gui/Makefile.am	2012-10-07 12:27:37.381024367 +0200
+++ neutrino-hd2-exp/src/gui/Makefile.am	2012-10-07 12:38:12.552174011 +0200
@@ -43,7 +43,7 @@
 	filebrowser.cpp audioplayer.cpp nfs.cpp pictureviewer.cpp \
 	movieplayer.cpp rc_lock.cpp \
 	timeosd.cpp epgplus.cpp epg_menu.cpp \
-	streaminfo2.cpp dboxinfo.cpp \
+	streaminfo2.cpp dboxinfo.cpp extra_menu.cpp \
 	plugins.cpp imageinfo.cpp audio_select.cpp moviebrowser.cpp movieinfo.cpp \
 	scan_setup.cpp zapit_setup.cpp proxyserver_setup.cpp
 

