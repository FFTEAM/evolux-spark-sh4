*** a/drivers/mtd/chips/cfi_probe.c	2011-01-02 21:05:30.000000000 +0100
--- b/cfi_probe.c	2011-01-05 20:38:36.087467593 +0100
***************
*** 255,260 ****
--- 255,276 ----
  	for (i=0; i<cfi->cfiq->NumEraseRegions; i++) {
  		cfi->cfiq->EraseRegionInfo[i] = le32_to_cpu(cfi->cfiq->EraseRegionInfo[i]);
  
+ 	/* kdhong */
+ 	printk( "CFI MFR = %x DEV = %x\n", cfi->mfr, cfi->id );
+ 
+ 	if( cfi->mfr == 0x00c2 && cfi->id == 0x227e )
+ 	{
+ 		int devsize = (1 << cfi->cfiq->DevSize) * cfi->interleave;
+ 
+ 		printk( "devsize = %x\n", devsize );
+ 
+ 		if( devsize == 0x400000 )
+ 		{
+ 			cfi->cfiq->EraseRegionInfo[i] = 0x100003f;
+ 		}
+ 	}
+ 	/* kdhong */
+ 
  #ifdef DEBUG_CFI
  		printk("  Erase Region #%d: BlockSize 0x%4.4X bytes, %d blocks\n",
  		       i, (cfi->cfiq->EraseRegionInfo[i] >> 8) & ~0xff,
--- a/arch/sh/boards/mach-mb618/setup.c	2011-04-28 22:11:27.000000000 +0200
+++ b/setup.c.patched	2011-05-01 16:33:35.000000000 +0200
@@ -26,21 +26,52 @@
 #include <linux/stm/pci-synopsys.h>
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/nand.h>
+#include <linux/stm/nand.h>
 #include <linux/mtd/physmap.h>
 #include <linux/mtd/partitions.h>
 #include <asm/irq-ilc.h>
 #include <asm/irl.h>
 #include <sound/stm.h>
 #include <mach/common.h>
+#include <linux/bpa2.h>
 
 
+const char *LMI_IO_partalias[] = { "v4l2-coded-video-buffers", "BPA2_Region1", "v4l2-video-buffers" ,
+                                    "coredisplay-video", "gfx-memory", "BPA2_Region0", "LMI_VID", NULL };
+ 
+/*
+0x40000000 - 0x403FFFFF - cocpu 1 ram (4mb)
+0x40400000 - 0x407FFFFF - cocpu 2 ram (4mb)
+0x40800000 - 0x47FFFFFF - linux   (120mb) 
+0x48000000 - 0x49FFFFFF - bigphys ( 32mb)
+0x4A000000 - 0x4FFFFFFF - lmi_io  ( 96mb)
+*/
+static struct bpa2_partition_desc bpa2_parts_table[] = {
+    {
+ 	    .name  = "bigphysarea",
+ 	    .start = 0x48000000,
+ 	    .size  = 0x02000000, /* 32 Mb */
+ 	    .flags = 0,
+ 	    .aka   = NULL
+    }, 
+    {
+ 	    .name  = "LMI_IO",
+ 	    .start = 0x4A000000,
+
+ 	    .size  = 0x05f00000, /*  95 Mb */
+//not sure why but someone inhibits us for
+//allocating complete area :( :(
+// 	    .size  = 0x06000000, /* 96 Mb */
+ 	    .flags = 0,
+ 	    .aka   = LMI_IO_partalias
+    }, 
+ };
 
 /* Whether the hardware supports NOR or NAND Flash depends on J34.
  * In position 1-2 CSA selects NAND, in position 2-3 is selects NOR.
  * Note that J30A must be in position 2-3 to select the on board Flash
  * (both NOR and NAND).
  */
-#define FLASH_NOR
 #define MB618_PIO_FLASH_VPP stm_gpio(3, 4)
 
 
@@ -51,12 +82,16 @@
 
 	stx7111_early_device_init();
 
-	stx7111_configure_asc(2, &(struct stx7111_asc_config) {
+	stx7111_configure_asc(1, &(struct stx7111_asc_config) {
 			.hw_flow_control = 1,
 			.is_console = 1, });
+
+/*
 	stx7111_configure_asc(3, &(struct stx7111_asc_config) {
 			.hw_flow_control = 1,
 			.is_console = 0, });
+*/
+  	bpa2_init(bpa2_parts_table, ARRAY_SIZE(bpa2_parts_table));
 }
 
 
@@ -115,41 +150,86 @@
 
 static void mb618_nor_set_vpp(struct map_info *info, int enable)
 {
-	gpio_set_value(MB618_PIO_FLASH_VPP, enable);
+//	gpio_set_value(MB618_PIO_FLASH_VPP, enable);
 }
 
+static struct mtd_partition mtd_parts_table[] = {
+	{
+		.name = "NOR U-BOOT :    0xA000.0000-0xA007.FFFF (512KB)",
+		.size = 0x00080000,
+		.offset = 0x00000000,
+	}, {
+		.name = "NOR ROOT :      0xA008.0000-0xA03F.FFFF (3,5MB)",
+		.size = MTDPART_SIZ_FULL,
+		.offset = 0x00080000,
+	}
+};
+
 static struct platform_device mb618_nor_flash = {
 	.name		= "physmap-flash",
 	.id		= -1,
 	.num_resources	= 1,
 	.resource	= (struct resource[]) {
-		STM_PLAT_RESOURCE_MEM(0, 32*1024*1024),
+		STM_PLAT_RESOURCE_MEM(0, 4*1024*1024),
 	},
 	.dev.platform_data = &(struct physmap_flash_data) {
 		.width		= 2,
 		.set_vpp	= mb618_nor_set_vpp,
+	    .nr_parts	= ARRAY_SIZE(mtd_parts_table),
+	    .parts		= mtd_parts_table
 	},
 };
 
 /* J34 must be in the 1-2 position to enable NOR Flash */
-static struct mtd_partition mb618_nand_flash_partitions[] = {
-	{
-		.name	= "NAND root",
-		.offset	= 0,
-		.size 	= 0x00800000
-	}, {
-		.name	= "NAND home",
-		.offset	= MTDPART_OFS_APPEND,
-		.size	= MTDPART_SIZ_FULL
-	},
+static struct mtd_partition nand_parts[] = {
+#ifdef ORIGINAL_MTD
+	 {
+	 .name = "NAND KERNEL :          0x0000.0000-0x002F.FFFF",
+	 .size = 0x300000,
+	 .offset = 0,
+	 },
+	 {
+	 .name = "NAND ROOT :            0x0030.0000-0x027F.FFFF",
+	 .size = 0x2500000,
+	 .offset = 0x300000,
+	 },
+	 {
+	 .name = "NAND CONFIG :          0x0280.0000-0x04FF.FFFF",
+	 .size = 0x2800000,
+	 .offset = 0x2800000,
+	 },
+	 {
+	 .name = "NAND DATA :            0x0500.0000-0x07FF.FFFF",
+	 .size = MTDPART_SIZ_FULL,	/* will expand to the end of the flash */
+	 .offset = 0x05000000,
+	 },
+#else
+	 {
+	 .name = "NAND KERNEL :   0x0000.0000-0x003F.FFFF (  4MB)",
+	 .size = 0x400000,
+	 .offset = 0,
+	 }, {
+	 .name = "NAND FW :       0x0040.0000-0x00BF.FFFF ( 8MB)",
+	 .size = 0x800000,
+	 .offset = 0x400000,
+	 }, {
+	 .name = "NAND ROOT :     0x00C0.0000-0x04BF.FFFF ( 64MB)",
+	 .size = 0x4000000,
+	 .offset = 0xC00000,
+	 }, {
+	 .name = "NAND DATA :     0x04C0.0000-0x07FF.FFFF ( 52MB)",
+	 .size = MTDPART_SIZ_FULL,	/* will expand to the end of the flash */
+	 .offset = 0x04C00000,
+	 },
+#endif
 };
 
-struct stm_nand_bank_data nand_bank_data = {
-	.csn		= 0,
-	.nr_partitions	= ARRAY_SIZE(mb618_nand_flash_partitions),
-	.partitions	= mb618_nand_flash_partitions,
+static struct stm_nand_bank_data nand_bank_data = {
+	.csn		= 1,
+	.nr_partitions	= ARRAY_SIZE(nand_parts),
+	.partitions	= nand_parts,
 	.options	= NAND_NO_AUTOINCR | NAND_USE_FLASH_BBT,
-	.timing_data	= &(struct stm_nand_timing_data) {
+	.timing_data = &(struct stm_nand_timing_data) {
 		.sig_setup	= 50,		/* times in ns */
 		.sig_hold	= 50,
 		.CE_deassert	= 0,
@@ -158,10 +238,17 @@
 		.wr_off		= 40,
 		.rd_on		= 10,
 		.rd_off		= 40,
-		.chip_delay	= 30,		/* in us */
+		.chip_delay	= 40,		/* in us */
 	},
+};
 
-	.emi_withinbankoffset	= 0,
+static struct platform_device nand_device = {
+	.name		= "stm-nand-emi",
+	.dev.platform_data = &(struct stm_plat_nand_emi_data){
+		.nr_banks	= 1,
+		.banks		= &nand_bank_data,
+		.emi_rbn_gpio	= -1,
+	},
 };
 
 static int mb618_phy_reset(void *bus)
@@ -178,7 +265,7 @@
 static struct plat_stmmacphy_data mb618_phy_private_data = {
 	/* SMSC LAN 8700 */
 	.bus_id = 0,
-	.phy_addr = -1,
+	.phy_addr = 3,
 	.phy_mask = 0,
 	.interface = PHY_INTERFACE_MODE_MII,
 	.phy_reset = &mb618_phy_reset,
@@ -249,13 +336,12 @@
 }
 
 static struct platform_device *mb618_devices[] __initdata = {
-	&mb618_leds,
+//	&mb618_leds,
 	&epld_device,
-#ifdef FLASH_NOR
 	&mb618_nor_flash,
-#endif
 	&mb618_phy_device,
-	&mb618_button_device,
+//	&mb618_button_device,
+	&nand_device,
 };
 
 /* SCART switch simple control */
@@ -294,13 +380,13 @@
 {
 	int peripherals_i2c_bus;
 
-	stx7111_configure_pci(&mb618_pci_config);
+//	stx7111_configure_pci(&mb618_pci_config);
 
-	stx7111_configure_pwm(&(struct stx7111_pwm_config) {
+/*	stx7111_configure_pwm(&(struct stx7111_pwm_config) {
 			.out0_enabled = 1,
 			.out1_enabled = 0, });
-
-	stx7111_configure_ssc_spi(0, NULL);
+*/
+	stx7111_configure_ssc_i2c(0);
 	stx7111_configure_ssc_i2c(1); /* J12=1-2, J16=1-2 */
 	peripherals_i2c_bus = stx7111_configure_ssc_i2c(2);
 	stx7111_configure_ssc_i2c(3);
@@ -313,22 +399,21 @@
 			.ext_clk = 0,
 			.phy_bus = 0, });
 
+/*
 	stx7111_configure_lirc(&(struct stx7111_lirc_config) {
 			.rx_mode = stx7111_lirc_rx_mode_ir,
 			.tx_enabled = 1,
 			.tx_od_enabled = 0, });
-
-	gpio_request(MB618_PIO_FLASH_VPP, "Flash VPP");
+*/
+/*	gpio_request(MB618_PIO_FLASH_VPP, "Flash VPP");
 	gpio_direction_output(MB618_PIO_FLASH_VPP, 0);
+*/
+//	i2c_register_board_info(peripherals_i2c_bus, &mb618_scart_audio, 1);
 
-	i2c_register_board_info(peripherals_i2c_bus, &mb618_scart_audio, 1);
-
-#ifndef FLASH_NOR
 	stx7111_configure_nand_flex(1, &nand_bank_data, 0);
 	/* The MTD NAND code doesn't understand the concept of VPP,
 	 * (or hardware write protect) so permanently enable it. */
-	gpio_direction_output(MB618_PIO_FLASH_VPP, 1);
-#endif
+//	gpio_direction_output(MB618_PIO_FLASH_VPP, 1);
 
 	return platform_add_devices(mb618_devices, ARRAY_SIZE(mb618_devices));
 }

--- stx7111_comms.c	2011-04-28 22:11:29.000000000 +0200
+++ stx7111_comms.c.patched	2011-06-14 14:28:37.000000000 +0200
@@ -350,7 +350,7 @@
 	BUG_ON(stx7111_ssc_configured[ssc]);
 	stx7111_ssc_configured[ssc] = 1;
 
-	stx7111_ssc_devices[ssc].name = "i2c-stm";
+	stx7100_ssc_devices[ssc].name = "i2c-st40";
 	stx7111_ssc_devices[ssc].id = i2c_busnum;
 
 	/* The SSC3 is an internal I2C link and is hard-wired -