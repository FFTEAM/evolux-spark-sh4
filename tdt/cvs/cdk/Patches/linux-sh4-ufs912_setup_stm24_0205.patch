*** a/arch/sh/boards/mach-mb618/setup.c	2011-02-02 20:35:28.000000000 +0100
--- b/setup.c	2011-02-11 15:57:48.183119172 +0100
***************
*** 32,39 ****
--- 32,70 ----
  #include <asm/irl.h>
  #include <sound/stm.h>
  #include <mach/common.h>
+ #include <linux/bpa2.h>
  
  
+ const char *LMI_IO_partalias[] = { "v4l2-coded-video-buffers", "BPA2_Region1", "v4l2-video-buffers" ,
+                                     "coredisplay-video", "gfx-memory", "BPA2_Region0", "LMI_VID", NULL };
+  
+ /*
+ 0x40000000 - 0x403FFFFF - cocpu 1 ram (4mb)
+ 0x40400000 - 0x407FFFFF - cocpu 2 ram (4mb)
+ 0x40800000 - 0x47FFFFFF - linux   (120mb) 
+ 0x48000000 - 0x49FFFFFF - bigphys ( 32mb)
+ 0x4A000000 - 0x4FFFFFFF - lmi_io  ( 96mb)
+ */
+ static struct bpa2_partition_desc bpa2_parts_table[] = {
+     {
+  	    .name  = "bigphysarea",
+  	    .start = 0x48000000,
+  	    .size  = 0x02000000, /* 32 Mb */
+  	    .flags = 0,
+  	    .aka   = NULL
+     }, 
+     {
+  	    .name  = "LMI_IO",
+  	    .start = 0x4A000000,
+ 
+  	    .size  = 0x05f00000, /*  95 Mb */
+ //not sure why but someone inhibits us for
+ //allocating complete area :( :(
+ // 	    .size  = 0x06000000, /* 96 Mb */
+  	    .flags = 0,
+  	    .aka   = LMI_IO_partalias
+     }, 
+  };
  
  /* Whether the hardware supports NOR or NAND Flash depends on J34.
   * In position 1-2 CSA selects NAND, in position 2-3 is selects NOR.
***************
*** 51,62 ****
  
  	stx7111_early_device_init();
  
! 	stx7111_configure_asc(2, &(struct stx7111_asc_config) {
  			.hw_flow_control = 1,
  			.is_console = 1, });
  	stx7111_configure_asc(3, &(struct stx7111_asc_config) {
  			.hw_flow_control = 1,
  			.is_console = 0, });
  }
  
  
--- 82,97 ----
  
  	stx7111_early_device_init();
  
! 	stx7111_configure_asc(1, &(struct stx7111_asc_config) {
  			.hw_flow_control = 1,
  			.is_console = 1, });
+ 
+ /*
  	stx7111_configure_asc(3, &(struct stx7111_asc_config) {
  			.hw_flow_control = 1,
  			.is_console = 0, });
+ */
+   	bpa2_init(bpa2_parts_table, ARRAY_SIZE(bpa2_parts_table));
  }
  
  
***************
*** 178,184 ****
  static struct plat_stmmacphy_data mb618_phy_private_data = {
  	/* SMSC LAN 8700 */
  	.bus_id = 0,
! 	.phy_addr = -1,
  	.phy_mask = 0,
  	.interface = PHY_INTERFACE_MODE_MII,
  	.phy_reset = &mb618_phy_reset,
--- 213,219 ----
  static struct plat_stmmacphy_data mb618_phy_private_data = {
  	/* SMSC LAN 8700 */
  	.bus_id = 0,
! 	.phy_addr = 3,
  	.phy_mask = 0,
  	.interface = PHY_INTERFACE_MODE_MII,
  	.phy_reset = &mb618_phy_reset,
***************
*** 249,261 ****
  }
  
  static struct platform_device *mb618_devices[] __initdata = {
! 	&mb618_leds,
  	&epld_device,
  #ifdef FLASH_NOR
  	&mb618_nor_flash,
  #endif
  	&mb618_phy_device,
! 	&mb618_button_device,
  };
  
  /* SCART switch simple control */
--- 284,296 ----
  }
  
  static struct platform_device *mb618_devices[] __initdata = {
! //	&mb618_leds,
  	&epld_device,
  #ifdef FLASH_NOR
  	&mb618_nor_flash,
  #endif
  	&mb618_phy_device,
! //	&mb618_button_device,
  };
  
  /* SCART switch simple control */
***************
*** 294,306 ****
  {
  	int peripherals_i2c_bus;
  
! 	stx7111_configure_pci(&mb618_pci_config);
  
! 	stx7111_configure_pwm(&(struct stx7111_pwm_config) {
  			.out0_enabled = 1,
  			.out1_enabled = 0, });
! 
! 	stx7111_configure_ssc_spi(0, NULL);
  	stx7111_configure_ssc_i2c(1); /* J12=1-2, J16=1-2 */
  	peripherals_i2c_bus = stx7111_configure_ssc_i2c(2);
  	stx7111_configure_ssc_i2c(3);
--- 329,341 ----
  {
  	int peripherals_i2c_bus;
  
! //	stx7111_configure_pci(&mb618_pci_config);
  
! /*	stx7111_configure_pwm(&(struct stx7111_pwm_config) {
  			.out0_enabled = 1,
  			.out1_enabled = 0, });
! */
! 	stx7111_configure_ssc_i2c(0);
  	stx7111_configure_ssc_i2c(1); /* J12=1-2, J16=1-2 */
  	peripherals_i2c_bus = stx7111_configure_ssc_i2c(2);
  	stx7111_configure_ssc_i2c(3);
***************
*** 313,333 ****
  			.ext_clk = 0,
  			.phy_bus = 0, });
  
  	stx7111_configure_lirc(&(struct stx7111_lirc_config) {
  			.rx_mode = stx7111_lirc_rx_mode_ir,
  			.tx_enabled = 1,
  			.tx_od_enabled = 0, });
! 
! 	gpio_request(MB618_PIO_FLASH_VPP, "Flash VPP");
  	gpio_direction_output(MB618_PIO_FLASH_VPP, 0);
! 
! 	i2c_register_board_info(peripherals_i2c_bus, &mb618_scart_audio, 1);
  
  #ifndef FLASH_NOR
  	stx7111_configure_nand_flex(1, &nand_bank_data, 0);
  	/* The MTD NAND code doesn't understand the concept of VPP,
  	 * (or hardware write protect) so permanently enable it. */
! 	gpio_direction_output(MB618_PIO_FLASH_VPP, 1);
  #endif
  
  	return platform_add_devices(mb618_devices, ARRAY_SIZE(mb618_devices));
--- 348,369 ----
  			.ext_clk = 0,
  			.phy_bus = 0, });
  
+ /*
  	stx7111_configure_lirc(&(struct stx7111_lirc_config) {
  			.rx_mode = stx7111_lirc_rx_mode_ir,
  			.tx_enabled = 1,
  			.tx_od_enabled = 0, });
! */
! /*	gpio_request(MB618_PIO_FLASH_VPP, "Flash VPP");
  	gpio_direction_output(MB618_PIO_FLASH_VPP, 0);
! */
! //	i2c_register_board_info(peripherals_i2c_bus, &mb618_scart_audio, 1);
  
  #ifndef FLASH_NOR
  	stx7111_configure_nand_flex(1, &nand_bank_data, 0);
  	/* The MTD NAND code doesn't understand the concept of VPP,
  	 * (or hardware write protect) so permanently enable it. */
! //	gpio_direction_output(MB618_PIO_FLASH_VPP, 1);
  #endif
  
  	return platform_add_devices(mb618_devices, ARRAY_SIZE(mb618_devices));
