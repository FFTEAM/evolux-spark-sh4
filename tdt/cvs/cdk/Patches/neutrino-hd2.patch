--- neutrino-hd2/acinclude.m4	2012-06-27 00:39:53.873863788 +0200
+++ neutrino-hd2/acinclude.m4	2012-07-04 17:41:36.962219923 +0200
@@ -225,10 +225,10 @@
 AC_DEFUN([_TUXBOX_APPS_LIB_PKGCONFIG],[
 AC_REQUIRE([TUXBOX_APPS_PKGCONFIG])
 AC_MSG_CHECKING(for package $2)
-if PKG_CONFIG_PATH="${prefix}/lib/pkgconfig" $PKG_CONFIG --exists "$2" ; then
+if $PKG_CONFIG --exists "$2" ; then
 	AC_MSG_RESULT(yes)
-	$1_CFLAGS=$(PKG_CONFIG_PATH="${prefix}/lib/pkgconfig" $PKG_CONFIG --cflags "$2")
-	$1_LIBS=$(PKG_CONFIG_PATH="${prefix}/lib/pkgconfig" $PKG_CONFIG --libs "$2")
+	$1_CFLAGS=$($PKG_CONFIG --cflags "$2")
+	$1_LIBS=$($PKG_CONFIG --libs "$2")
 else
 	AC_MSG_RESULT(no)
 fi

--- neutrino-hd2/src/driver/framebuffer.h	2012-06-27 00:39:47.345831415 +0200
+++ neutrino-hd2/src/driver/framebuffer.h	2012-07-04 17:43:38.998825070 +0200
@@ -36,7 +36,7 @@
 
 // stmfb
 #ifdef __sh__
-#include <stgfb/stmfb/linux/video/stmfb.h>
+#include <stgfb/stmfb/linux/drivers/video/stmfb.h>
 #endif
 
 // 32 bit

--- neutrino-hd2/src/gui/update.cpp	2012-06-27 00:39:45.889824195 +0200
+++ neutrino-hd2/src/gui/update.cpp	2012-07-04 17:45:45.999454820 +0200
@@ -55,7 +55,6 @@
 #define SQUASHFS
 
 #include <curl/curl.h>
-#include <curl/types.h>
 #include <curl/easy.h>
 
 #include <stdio.h>

--- neutrino-hd2/src/gui/filebrowser.cpp	2012-06-27 00:39:45.889824195 +0200
+++ neutrino-hd2/src/gui/filebrowser.cpp	2012-07-04 17:47:11.939880985 +0200
@@ -59,7 +59,6 @@
 #include <sys/stat.h>
 
 #include <curl/curl.h>
-#include <curl/types.h>
 #include <curl/easy.h>
 
 #include <driver/encoding.h>

--- neutrino-hd2/src/gui/audioplayer.cpp	2012-06-27 00:39:45.889824195 +0200
+++ neutrino-hd2/src/gui/audioplayer.cpp	2012-07-04 17:48:24.444240515 +0200
@@ -126,7 +126,6 @@
 }
 
 #include <curl/curl.h>
-#include <curl/types.h>
 #include <curl/easy.h>
 
 struct MemoryStruct {

--- neutrino-hd2/src/system/httptool.cpp	2012-06-27 00:39:46.077825130 +0200
+++ neutrino-hd2/src/system/httptool.cpp	2012-07-04 17:50:11.572771736 +0200
@@ -22,7 +22,6 @@
 #include <system/httptool.h>
 
 #include <curl/curl.h>
-#include <curl/types.h>
 #include <curl/easy.h>
 
 #include <global.h>

--- neutrino-hd2/src/nhttpd/web/scripts/Makefile.am	2012-06-27 00:39:43.873814196 +0200
+++ neutrino-hd2/src/nhttpd/web/scripts/Makefile.am	2012-07-04 17:52:15.901388252 +0200
@@ -1,7 +1,9 @@
-installdir =  $(DATADIR)/neutrino/httpd/scripts
+installdir = $(DATADIR)/neutrino/httpd/scripts
+
+install_DATA = api.sh \
+		_Y_Globals.sh \
+		_Y_Library.sh \
+		Y_Live.sh \
+		Y_Tools.sh
 
-install_DATA= api.sh _Y_Globals.sh _Y_Library.sh Y_Live.sh Y_Tools.sh
 
-install-data-hook:
-	chmod 0755 $(DATADIR)/neutrino/httpd/scripts/api.sh
-	chmod 0755 $(DATADIR)/neutrino/httpd/scripts/Y_*.sh

--- neutrino-hd2/src/driver/rcinput.h	2012-07-12 19:37:55.000000000 +0200
+++ neutrino-hd2/src/driver/rcinput.h	2012-07-12 19:40:48.433191052 +0200
@@ -32,12 +32,15 @@
 #ifndef __MOD_rcinput__
 #define __MOD_rcinput__
 
+#include <config.h>
 #include <linux/input.h>
+#include <stdint.h>
 #include <sys/types.h>
 #include <string>
 #include <vector>
-#include <stdint.h>
-
+#ifdef HAVE_COOLSTREAM_NEVIS_IR_H
+#include <coolstream/nevis_ir.h>
+#endif
 
 #ifndef KEY_OK
 #define KEY_OK           0x160
@@ -59,7 +62,11 @@
 #define KEY_BLUE         0x191
 #endif
 
+#ifndef KEY_GAMES
+#define KEY_GAMES        0x1a1   /* Media Select Games */
+#endif
 /* SAGEM remote controls have the following additional keys */
+
 #ifndef KEY_TOPLEFT
 #define KEY_TOPLEFT      0x1a2
 #endif
@@ -76,58 +83,29 @@
 #define KEY_BOTTOMRIGHT  0x1a5
 #endif
 
-#ifndef KEY_GAMES
-#define KEY_GAMES        0x1a1
-#endif
-
-/* this values are token from cuberevo3000hd */
-#ifndef KEY_PIP	
-#define KEY_PIP		0x041
-#endif
-
-#ifndef KEY_PIPPOS	
-#define KEY_PIPPOS	0x0BE
-#endif
-
-#ifndef KEY_PIPSWAP 
-#define KEY_PIPSWAP	0x0BF
-#endif
-
-#ifndef __KEY_PIPSUBCH	
-#define KEY_PIPSUBCH	0x0C0
-#endif
-
-#ifndef KEY_BOOKMARK	
-#define	KEY_BOOKMARK	0x03f
-#endif
-
-#ifndef KEY_MUSIC	
-#define KEY_MUSIC	0x0c1
-#endif
-
-#ifndef KEY_PICTURE	
-#define KEY_PICTURE	0x03e
-#endif
-
-#ifndef KEY_REPEAT	
-#define	KEY_REPEAT	0x040
-#endif
-
-#ifndef KEY_SLOW	
-#define KEY_SLOW	0x199
-#endif
-
-#ifndef KEY_MULTFEED	
-#define KEY_MULTIFEED	0x0bd
-#endif
-
-#ifndef KEY_DVBSUB	
-#define KEY_DVBSUB	0x172
-#endif
-
-#ifndef KEY_NET
-#define KEY_NET		0x096
-#endif
+#define KEY_POWERON	KEY_FN_F1
+#define KEY_POWEROFF	KEY_FN_F2
+#define KEY_STANDBYON	KEY_FN_F3
+#define KEY_STANDBYOFF	KEY_FN_F4
+#define KEY_MUTEON	KEY_FN_F5
+#define KEY_MUTEOFF	KEY_FN_F6
+#define KEY_ANALOGON	KEY_FN_F7
+#define KEY_ANALOGOFF	KEY_FN_F8
+
+#define KEY_TTTV	KEY_FN_1
+#define KEY_TTZOOM	KEY_FN_2
+#define KEY_REVEAL	KEY_FN_D
+/* only defined in newer kernels / headers... */
+#ifndef KEY_ZOOMIN
+#define KEY_ZOOMIN	KEY_FN_E
+#endif
+#ifndef KEY_ZOOMOUT
+#define KEY_ZOOMOUT	KEY_FN_F
+#endif
+/* still available, even in 2.6.12:
+	#define KEY_FN_S
+	#define KEY_FN_B
+*/
 
 /* VFD */
 #define VFD_UP		0x042
@@ -139,8 +117,6 @@
 #define VFD_EXIT	0x0b7
 #define VFD_OK		0x058
 
-
-
 typedef uint32_t neutrino_msg_t;
 typedef uint32_t neutrino_msg_data_t;
 
@@ -159,36 +135,42 @@
 		struct timer
 		{
 			uint			id;
-			unsigned long long	interval;
-			unsigned long long	times_out;
+			uint64_t		interval;
+			uint64_t		times_out;
 			bool			correct_time;
 		};
 
 		uint32_t               timerid;
 		std::vector<timer> timers;
 
+
+		uint32_t	*repeatkeys;
+
 		int 		fd_pipe_high_priority[2];
 		int 		fd_pipe_low_priority[2];
 		int         	fd_gamerc;
 
-#define NUMBER_OF_EVENT_DEVICES 4
+#define NUMBER_OF_EVENT_DEVICES 1
 
 		int         	fd_rc[NUMBER_OF_EVENT_DEVICES];
 		int		fd_keyb;
 		int		fd_event;
-
 		int		fd_max;
+		int		clickfd;
 		__u16 rc_last_key;
 		void set_dsp();
 
-		void open();
+		void open(int dev = -1);
 		void close();
 		int translate(int code, int num);
-
 		void calculateMaxFd(void);
-
 		int checkTimers();
 
+		bool mayRepeat(uint32_t key);
+
+#ifdef HAVE_COOLSTREAM_NEVIS_IR_H
+		void set_rc_hw(ir_protocol_t ir_protocol, unsigned int ir_address);
+#endif
 	public:
 		//rc-code definitions
 		static const neutrino_msg_t RC_Repeat   = 0x0400;
@@ -198,163 +180,108 @@
 		static const neutrino_msg_t RC_Events   = 0x80000000;
 		static const neutrino_msg_t RC_Messages = 0x90000000;
 		static const neutrino_msg_t RC_WithData = 0xA0000000;
-
 		enum
 		{
-			RC_0		= KEY_0,	    /* /include/linux/input.h: #define KEY_0			 0xb   */
-			RC_1		= KEY_1,	    /* /include/linux/input.h: #define KEY_1			  0x2   */
-			RC_2		= KEY_2,	    /* /include/linux/input.h: #define KEY_2			  0x3   */
-			RC_3		= KEY_3,	    /* /include/linux/input.h: #define KEY_3			  0x4   */
-			RC_4		= KEY_4,	    /* /include/linux/input.h: #define KEY_4			  0x5   */
-			RC_5		= KEY_5,	    /* /include/linux/input.h: #define KEY_5			  0x6   */
-			RC_6		= KEY_6,	    /* /include/linux/input.h: #define KEY_6			  0x7   */
-			RC_7		= KEY_7,	    /* /include/linux/input.h: #define KEY_7			  0x8   */
-			RC_8		= KEY_8,	    /* /include/linux/input.h: #define KEY_8			  0x9   */
-			RC_9		= KEY_9,	    /* /include/linux/input.h: #define KEY_9			 0xa   */
-			
-			RC_backspace	= KEY_BACKSPACE,    /* /include/linux/input.h: #define KEY_BACKSPACE		 0xe   */
-			
-			RC_up		= KEY_UP,	    /* /include/linux/input.h: #define KEY_UP			0x67   */
-			RC_left		= KEY_LEFT,	    /* /include/linux/input.h: #define KEY_LEFT			0x69   */
-			RC_right	= KEY_RIGHT,	    /* /include/linux/input.h: #define KEY_RIGHT		0x6a   */
-			RC_down		= KEY_DOWN,	    /* /include/linux/input.h: #define KEY_DOWN			0x6c   */
-			
-			RC_spkr		= KEY_MUTE,	    /* /include/linux/input.h: #define KEY_MUTE			0x71   */
-			
-#if defined (PLATFORM_CUBEREVO) || defined (PLATFORM_CUBEREVO_MINI) || defined (PLATFORM_CUBEREVO_MINI2) || defined (PLATFORM_CUBEREVO_MINI_FTA) || defined (PLATFORM_CUBEREVO_250HD) || defined (PLATFORM_CUBEREVO_2000HD) || defined (PLATFORM_CUBEREVO_9500HD)			
-			RC_minus	= 0xBC,
-			RC_plus		= 0xBB,
-#else			
-			RC_minus        = KEY_VOLUMEDOWN,   /* /include/linux/input.h: #define KEY_VOLUMEDOWN          114   */
-			RC_plus         = KEY_VOLUMEUP,     /* /include/linux/input.h: #define KEY_VOLUMEUP            115   */
-#endif			
-
-			RC_standby	= KEY_POWER,	    /* /include/linux/input.h: #define KEY_POWER		0x74   */			
-			
-#if defined (PLATFORM_GIGABLUE)
-			RC_home         = 0xAE,
-#elif defined (PLATFORM_CUBEREVO) || defined (PLATFORM_CUBEREVO_MINI) || defined (PLATFORM_CUBEREVO_MINI2) || defined (PLATFORM_CUBEREVO_MINI_FTA) || defined (PLATFORM_CUBEREVO_250HD) || defined (PLATFORM_CUBEREVO_2000HD) || defined (PLATFORM_CUBEREVO_9500HD)			
-			RC_home		= 0x9E,
-#else
-			RC_home         = KEY_HOME,         /* /include/linux/input.h: #define KEY_HOME                	0x66   */
-#endif			
-
-#if defined (PLATFORM_CUBEREVO) || defined (PLATFORM_CUBEREVO_MINI) || defined (PLATFORM_CUBEREVO_MINI2) || defined (PLATFORM_CUBEREVO_MINI_FTA) || defined (PLATFORM_CUBEREVO_250HD) || defined (PLATFORM_CUBEREVO_2000HD) || defined (PLATFORM_CUBEREVO_9500HD)
-			RC_setup	= 0x8B,
-#else
-			RC_setup	= KEY_MENU,	    /* /include/linux/input.h: #define KEY_SETUP		0x8d   */
-#endif				
-			
-#if defined (PLATFORM_GIGABLUE)
-			RC_page_up	= 0x192,
-			RC_page_down	= 0x193,
-#else
-			RC_page_up	= KEY_PAGEUP,	    /* /include/linux/input.h: #define KEY_PAGEUP		0x68   */
-			RC_page_down	= KEY_PAGEDOWN,	    /* /include/linux/input.h: #define KEY_PAGEDOWN		0x6d   */
-#endif			
-			
+			RC_0		= KEY_0,	    /* /include/linux/input.h: #define KEY_0			 11   */
+			RC_1		= KEY_1,	    /* /include/linux/input.h: #define KEY_1			  2   */
+			RC_2		= KEY_2,	    /* /include/linux/input.h: #define KEY_2			  3   */
+			RC_3		= KEY_3,	    /* /include/linux/input.h: #define KEY_3			  4   */
+			RC_4		= KEY_4,	    /* /include/linux/input.h: #define KEY_4			  5   */
+			RC_5		= KEY_5,	    /* /include/linux/input.h: #define KEY_5			  6   */
+			RC_6		= KEY_6,	    /* /include/linux/input.h: #define KEY_6			  7   */
+			RC_7		= KEY_7,	    /* /include/linux/input.h: #define KEY_7			  8   */
+			RC_8		= KEY_8,	    /* /include/linux/input.h: #define KEY_8			  9   */
+			RC_9		= KEY_9,	    /* /include/linux/input.h: #define KEY_9			 10   */
+			RC_backspace	= KEY_BACKSPACE,    /* /include/linux/input.h: #define KEY_BACKSPACE		 14   */
+			RC_up		= KEY_UP,	    /* /include/linux/input.h: #define KEY_UP			103   */
+			RC_left		= KEY_LEFT,	    /* /include/linux/input.h: #define KEY_LEFT			105   */
+			RC_right	= KEY_RIGHT,	    /* /include/linux/input.h: #define KEY_RIGHT		106   */
+			RC_down		= KEY_DOWN,	    /* /include/linux/input.h: #define KEY_DOWN			108   */
+			RC_spkr		= KEY_MUTE,	    /* /include/linux/input.h: #define KEY_MUTE			113   */
+			RC_minus	= KEY_VOLUMEDOWN,   /* /include/linux/input.h: #define KEY_VOLUMEDOWN		114   */
+			RC_plus		= KEY_VOLUMEUP,     /* /include/linux/input.h: #define KEY_VOLUMEUP		115   */
+			RC_standby	= KEY_POWER,	    /* /include/linux/input.h: #define KEY_POWER		116   */
+			RC_help		= KEY_HELP,	    /* /include/linux/input.h: #define KEY_HELP			138   */
+			RC_home		= KEY_EXIT,	    /* /include/linux/input.h: #define KEY_HOME			102   */
+			RC_setup	= KEY_MENU,	    /* /include/linux/input.h: #define KEY_SETUP		141   */
+			RC_topleft	= KEY_TOPLEFT,	
+			RC_topright	= KEY_TOPRIGHT,	
+			RC_page_up	= KEY_PAGEUP,	    /* /include/linux/input.h: #define KEY_PAGEUP		104   */
+			RC_page_down	= KEY_PAGEDOWN,	    /* /include/linux/input.h: #define KEY_PAGEDOWN		109   */
 			RC_ok		= KEY_OK,	    /* /include/linux/input.h: #define KEY_OK			0x160 */ /* in patched input.h */
-			
 			RC_red		= KEY_RED,	    /* /include/linux/input.h: #define KEY_RED			0x18e */ /* in patched input.h */
 			RC_green	= KEY_GREEN,	    /* /include/linux/input.h: #define KEY_GREEN		0x18f */ /* in patched input.h */
 			RC_yellow	= KEY_YELLOW,	    /* /include/linux/input.h: #define KEY_YELLOW		0x190 */ /* in patched input.h */
 			RC_blue		= KEY_BLUE,	    /* /include/linux/input.h: #define KEY_BLUE			0x191 */ /* in patched input.h */
+			RC_top_left	= KEY_TOPLEFT,	    /* /include/linux/input.h: #define KEY_TOPLEFT		0x1a2 */ /* in patched input.h */
+			RC_top_right	= KEY_TOPRIGHT,	    /* /include/linux/input.h: #define KEY_TOPRIGHT		0x1a3 */ /* in patched input.h */
+			RC_bottom_left	= KEY_BOTTOMLEFT,   /* /include/linux/input.h: #define KEY_BOTTOMLEFT		0x1a4 */ /* in patched input.h */
+			RC_bottom_right	= KEY_BOTTOMRIGHT,  /* /include/linux/input.h: #define KEY_BOTTOMRIGHT		0x1a5 */ /* in patched input.h */
+
+			RC_audio	= KEY_AUDIO,
+			RC_video	= KEY_VIDEO,
+			RC_tv		= KEY_TV,
+			RC_radio	= KEY_RADIO,
+			RC_text		= KEY_TEXT,
+			RC_info		= KEY_INFO,
+			RC_epg		= KEY_EPG,
+			RC_recall	= KEY_LAST,
+			RC_favorites	= KEY_FAVORITES,
+			RC_sat		= KEY_SAT,
+			RC_sat2		= KEY_SAT2,
+			RC_record	= KEY_RECORD,
+			RC_play		= KEY_PLAY,
+			RC_pause	= KEY_PAUSE,
+			RC_forward	= KEY_FORWARD,
+			RC_rewind	= KEY_REWIND,
+			RC_stop		= KEY_STOP,
+
+			RC_timeshift	= KEY_T,
+
+			RC_mode		= KEY_MODE,
+			RC_games	= KEY_GAMES,
+			RC_next		= KEY_NEXT,
+			RC_prev		= KEY_PREVIOUS,
+			RC_www		= KEY_WWW,
+
+			RC_power_on	= KEY_POWERON,
+			RC_power_off	= KEY_POWEROFF,
+			RC_standby_on	= KEY_STANDBYON,
+			RC_standby_off	= KEY_STANDBYOFF,
+			RC_mute_on	= KEY_MUTEON,
+			RC_mute_off	= KEY_MUTEOFF,
+			RC_analog_on	= KEY_ANALOGON,
+			RC_analog_off	= KEY_ANALOGOFF,
+
+			/* tripledragon keys */
+			RC_eject	= KEY_EJECTCD,
+			RC_aux		= KEY_AUX,          /* 0x186 */
+			RC_timer	= KEY_TIME,
+			RC_tttv		= KEY_TTTV,
+			RC_ttzoom	= KEY_TTZOOM,
+			RC_ttreveal	= KEY_REVEAL,
+			RC_zoomin	= KEY_ZOOMIN,
+			RC_zoomout	= KEY_ZOOMOUT,
+
+			RC_multifeed	= 0x165,
 
-#if defined (PLATFORM_CUBEREVO) || defined (PLATFORM_CUBEREVO_MINI) || defined (PLATFORM_CUBEREVO_MINI2) || defined (PLATFORM_CUBEREVO_MINI_FTA) || defined (PLATFORM_CUBEREVO_250HD) || defined (PLATFORM_CUBEREVO_2000HD) || defined (PLATFORM_CUBEREVO_9500HD)
-			RC_audio	= 0x3D,
-			RC_video	= 0x90,
-			
-			RC_text		= 0x173,
-#else
-			RC_audio	= KEY_AUDIO,		/* 0x188 */
-			RC_video	= KEY_VIDEO,		/* 0x189 */
-			
-			RC_text		= KEY_TEXT,		/* 0x184 */
-#endif
-
-#if defined (PLATFORM_DUCKBOX)
-			RC_info		= 0x8A,
-#else
-			RC_info		= KEY_INFO,		/* 0x166 */
-#endif			
-			
-#if defined (PLATFORM_GIGABLUE)			
-			RC_epg		= 0x8A,
-#else			
-			RC_epg		= KEY_EPG,		/* 0x16d */
-#endif			
-
-#if defined (PLATFORM_CUBEREVO) || defined (PLATFORM_CUBEREVO_MINI) || defined (PLATFORM_CUBEREVO_MINI2) || defined (PLATFORM_CUBEREVO_MINI_FTA) || defined (PLATFORM_CUBEREVO_250HD) || defined (PLATFORM_CUBEREVO_2000HD) || defined (PLATFORM_CUBEREVO_9500HD)
-			RC_recall	= 0x3C,
-#else
-			RC_recall 	= KEY_BACK,		/* 0x9E */
-#endif			
-
-			RC_favorites	= KEY_FAVORITES,	/* 0x16c */
-
-			RC_sat		= KEY_SAT,		/* 0x17d */
-			//RC_sat2	= KEY_SAT2,		/* 0x17e */
-			
-			RC_record	= KEY_RECORD,		/* 0xA7 */
-			RC_play		= KEY_PLAY,		/* 0xCF */
-			RC_pause	= KEY_PAUSE,		/* 0x77 */
-			RC_forward	= KEY_FASTFORWARD,	/* 0xD0 */
-			RC_rewind	= KEY_REWIND,		/* 0xA8 */
-			RC_stop		= KEY_STOP,		/* 0x80 */
-			
-			RC_timeshift	= KEY_TIME,		/* 0x167 */
-			
-#if defined (PLATFORM_GIGABLUE)
-			RC_mode		= 0x181,
-#elif defined (PLATFORM_CUBEREVO) || defined (PLATFORM_CUBEREVO_MINI) || defined (PLATFORM_CUBEREVO_MINI2) || defined (PLATFORM_CUBEREVO_MINI_FTA) || defined (PLATFORM_CUBEREVO_250HD) || defined (PLATFORM_CUBEREVO_2000HD) || defined (PLATFORM_CUBEREVO_9500HD)
-			RC_mode		= 0x3B,
-#else			
-			RC_mode		= KEY_MODE,		/* 0x175 */
-#endif			
-			//RC_games	= KEY_GAMES,
-
-#if defined (PLATFORM_GIGABLUE)
-			RC_next		= 0x197,
-			RC_prev		= 0x19C,
-#else
-			RC_next		= 0xFFFFFFF0,
-			RC_prev		= 0xFFFFFFF1,
-#endif			
-
-			/* added from cuberevo3000hd so fix it please */
-#if defined (PLATFORM_CUBEREVO) || defined (PLATFORM_CUBEREVO_MINI) || defined (PLATFORM_CUBEREVO_MINI2) || defined (PLATFORM_CUBEREVO_MINI_FTA) || defined (PLATFORM_CUBEREVO_250HD) || defined (PLATFORM_CUBEREVO_2000HD) || defined (PLATFORM_CUBEREVO_9500HD)
-			RC_music	= KEY_MUSIC,
-			RC_picture	= KEY_PICTURE,			
-			
-			RC_repeat	= KEY_REPEAT,
+			/* SPARK keys */
+			RC_find		= KEY_FIND,
+			RC_pip		= KEY_PRESENTATION,
+			RC_archive	= KEY_ARCHIVE,
+			RC_fastforward	= KEY_FASTFORWARD,
 			RC_slow		= KEY_SLOW,
-			
-			RC_dvbsub	= KEY_DVBSUB,
+			RC_playmode	= KEY_P,
+			RC_usb		= KEY_CLOSE,
+			RC_f1		= KEY_F1,
+			RC_f2		= KEY_F2,
+			RC_f3		= KEY_F3,
+			RC_f4		= KEY_F4,
+			RC_prog1	= KEY_PROG1,
+			RC_prog2	= KEY_PROG2,
+			RC_prog3	= KEY_PROG3,
+			RC_prog4	= KEY_PROG4,
 
-			RC_pip		= KEY_PIP,
-			RC_pippos	= KEY_PIPPOS,
-			RC_pipswap	= KEY_PIPSWAP,
-			RC_pipsubch	= KEY_PIPSUBCH,
-
-			RC_net		= KEY_NET,
-			
-			RC_bookmark	= KEY_BOOKMARK,
-#endif
-
-#if defined (PLATFORM_CUBEREVO) || defined (PLATFORM_CUBEREVO_MINI) || defined (PLATFORM_CUBEREVO_MINI2) || defined (PLATFORM_CUBEREVO_MINI_FTA) || defined (PLATFORM_CUBEREVO_250HD) || defined (PLATFORM_CUBEREVO_2000HD) || defined (PLATFORM_CUBEREVO_9500HD)
-			RC_multifeed	= KEY_MULTIFEED,
-#else
-			RC_multifeed	= 0x165,
-#endif
-			
-#if defined (PLATFORM_GIGABLUE)			
-			RC_f1		= 0x3B,
-			RC_f2		= 0x3C,
-			RC_f3		= 0x3D,
-			RC_f4		= 0x3E,
-			RC_aspect	= 0x40,
-#endif			
-			
 			RC_vfdup	= VFD_UP,
 			RC_vfddown	= VFD_DOWN,
 			RC_vfdright	= VFD_RIGHT,
@@ -368,23 +295,25 @@
 			RC_nokey	= 0xFFFFFFFE
 		};
 
+		//rc-hardware definitions
+		enum
+		{
+			RC_HW_COOLSTREAM	= 0,
+			RC_HW_DBOX		= 1,
+			RC_HW_PHILIPS		= 2,
+			RC_HW_TRIPLEDRAGON	= 3,
+		};
+		void set_rc_hw(void);
+
 		inline int getFileHandle(void) /* used for plugins (i.e. games) only */
 		{
-#if HAVE_DVB_API_VERSION == 1
-			return fd_gamerc;
-#else
-			for (int i = 0; i < NUMBER_OF_EVENT_DEVICES; i++)
-			{
-				return fd_rc[i];
-			}
-#endif
+			return fd_rc[0];
 		}
-		
 		void stopInput();
 		void restartInput();
 
-		unsigned long long repeat_block;
-		unsigned long long repeat_block_generic;
+		uint64_t repeat_block;
+		uint64_t repeat_block_generic;
 		CRCInput();      //constructor - opens rc-device and starts needed threads
 		~CRCInput();     //destructor - closes rc-device
 
@@ -394,26 +323,33 @@
 		static unsigned int convertDigitToKey(const unsigned int digit);
 		static int getUnicodeValue(const neutrino_msg_t key);
 
+		uint32_t *setAllowRepeat(uint32_t *);
+
+
 		static const char * getSpecialKeyName(const unsigned int key);
 		static std::string getKeyName(const unsigned int key);
 
-		int addTimer(unsigned long long Interval, bool oneshot= true, bool correct_time= true );
+		int addTimer(uint64_t Interval, bool oneshot= true, bool correct_time= true );
 		int addTimer(struct timeval Timeout);
 		int addTimer(const time_t *Timeout);
 
-		void killTimer(uint32_t id);
+		void killTimer(uint32_t &id);
 
-		static long long calcTimeoutEnd_MS(const int timeout_in_milliseconds);
-		static long long calcTimeoutEnd(const int timeout_in_seconds);
+		static int64_t calcTimeoutEnd_MS(const int timeout_in_milliseconds);
+		static int64_t calcTimeoutEnd(const int timeout_in_seconds);
 
-		void getMsgAbsoluteTimeout(neutrino_msg_t * msg, neutrino_msg_data_t * data, unsigned long long *TimeoutEnd, bool bAllowRepeatLR = false);
-		void getMsg(neutrino_msg_t * msg, neutrino_msg_data_t * data, int Timeout, bool bAllowRepeatLR= false);                  //get message, timeout in 1/10 secs :)
-		void getMsg_ms(neutrino_msg_t * msg, neutrino_msg_data_t * data, int Timeout, bool bAllowRepeatLR= false);               //get message, timeout in msecs :)
-		void getMsg_us(neutrino_msg_t * msg, neutrino_msg_data_t * data, unsigned long long Timeout, bool bAllowRepeatLR= false);//get message, timeout in �secs :)
-		void postMsg(const neutrino_msg_t msg, const neutrino_msg_data_t data, const bool Priority = true);  // push message back into buffer
+		void getMsgAbsoluteTimeout(neutrino_msg_t * msg, neutrino_msg_data_t * data, uint64_t *TimeoutEnd, bool bAllowRepeatLR= false);
+		void getMsg(neutrino_msg_t * msg, neutrino_msg_data_t * data, int Timeout, bool bAllowRepeatLR= false);        //get message, timeout in 1/10 secs :)
+		void getMsg_ms(neutrino_msg_t * msg, neutrino_msg_data_t * data, int Timeout, bool bAllowRepeatLR= false);     //get message, timeout in msecs :)
+		void getMsg_us(neutrino_msg_t * msg, neutrino_msg_data_t * data, uint64_t Timeout, bool bAllowRepeatLR= false);//get message, timeout in µsecs :)
+		void postMsg(const neutrino_msg_t msg, const neutrino_msg_data_t data, const bool Priority = true);            // push message back into buffer
 		void clearRCMsg();
 
 		int messageLoop( bool anyKeyCancels = false, int timeout= -1 );
+		void open_click();
+		void close_click();
+		void play_click();
+		void reset_dsp(int rate);
 };
 
 

--- neutrino-hd2/src/driver/rcinput.cpp	2012-07-09 11:16:57.269527559 +0200
+++ neutrino-hd2/src/driver/rcinput.cpp	2012-07-12 18:51:36.946555447 +0200
@@ -28,7 +28,7 @@
 	along with this program; if not, write to the Free Software
 	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
-
+#define EVOLUX
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
@@ -49,6 +49,7 @@
 #endif /* KEYBOARD_INSTEAD_OF_REMOTE_CONTROL */
 #include <unistd.h>
 #include <fcntl.h>
+#include <errno.h>
 
 #include <sys/un.h>
 #include <sys/socket.h>
@@ -57,31 +58,32 @@
 #include <eventserver.h>
 
 #include <global.h>
+#include <driver/shutdown_count.h>
 #include <neutrino.h>
 
-#include <system/debug.h>
-
-
-const char * const RC_EVENT_DEVICE[NUMBER_OF_EVENT_DEVICES] = {
-	"/dev/input/event0", 
-	"/dev/input/event1", 
-	"/dev/input/event2", 
-	"/dev/input/event3"
-};
+const char * const RC_EVENT_DEVICE[NUMBER_OF_EVENT_DEVICES] = {"/dev/input/event1"};
 
 typedef struct input_event t_input_event;
 
 #ifdef KEYBOARD_INSTEAD_OF_REMOTE_CONTROL
 static struct termio orig_termio;
-static bool saved_orig_termio = false;
+static bool          saved_orig_termio = false;
 #endif /* KEYBOARD_INSTEAD_OF_REMOTE_CONTROL */
+static bool input_stopped = false;
 
-
+/*********************************************************************************
+*	Constructor - opens rc-input device, selects rc-hardware and starts threads
+*
+*********************************************************************************/
 CRCInput::CRCInput()
 {
 	timerid= 1;
 
+	repeatkeys = NULL;
+
+
 	// pipe for internal event-queue
+	// -----------------------------
 	if (pipe(fd_pipe_high_priority) < 0)
 	{
 		perror("fd_pipe_high_priority");
@@ -102,9 +104,10 @@
 
 
 	// open event-library
+	// -----------------------------
 	fd_event = 0;
 
-	// network-setup (neutrino.sock )
+	//network-setup
 	struct sockaddr_un servaddr;
 	int    clilen;
 	memset(&servaddr, 0, sizeof(struct sockaddr_un));
@@ -113,66 +116,78 @@
 	clilen = sizeof(servaddr.sun_family) + strlen(servaddr.sun_path);
 	unlink(NEUTRINO_UDS_NAME);
 
+	//network-setup
 	if ((fd_event = socket(AF_UNIX, SOCK_STREAM, 0)) < 0)
 	{
-		perror("CRCInput::CRCInput socket\n");
+		perror("[neutrino] socket\n");
 	}
 
 	if ( bind(fd_event, (struct sockaddr*) &servaddr, clilen) <0 )
 	{
-		perror("CRCInput::CRCInput bind failed...\n");
+		perror("[neutrino] bind failed...\n");
 		exit(-1);
 	}
 
+
 	if (listen(fd_event, 15) !=0)
 	{
-		perror("CRCInput::CRCInput listen failed...\n");
+		perror("[neutrino] listen failed...\n");
 		exit( -1 );
 	}
 
-	// open rc
 	for (int i = 0; i < NUMBER_OF_EVENT_DEVICES; i++)
 	{
 		fd_rc[i] = -1;
 	}
-	
+	clickfd = -1;
 	repeat_block = repeat_block_generic = 0;
-	
 	open();
-	
 	rc_last_key =  KEY_MAX;
+
+	//select and setup remote control hardware
+	set_rc_hw();
 }
 
-void CRCInput::open()
+/* if dev is given, open device with index <dev>, if not (re)open all */
+void CRCInput::open(int dev)
 {
-	close();
+	if (dev == -1)
+		close();
 
 	for (int i = 0; i < NUMBER_OF_EVENT_DEVICES; i++)
 	{
-		if ((fd_rc[i] = ::open(RC_EVENT_DEVICE[i], O_RDONLY)) == -1)
-			perror(RC_EVENT_DEVICE[i]);
+		if (dev != -1) {
+			if (i != dev || fd_rc[i] != -1)
+				continue;
+		}
+		if ((fd_rc[i] = ::open(RC_EVENT_DEVICE[i], O_RDWR)) == -1)
+
+			while(0);
+
 		else
 		{
 			fcntl(fd_rc[i], F_SETFL, O_NONBLOCK);
 		}
-				
-		dprintf(DEBUG_DEBUG, "CRCInput::open: %s fd %d\n", RC_EVENT_DEVICE[i], fd_rc[i]);		
+
+		if (fd_rc[i] > -1)
+
+		printf("CRCInput::open: %s fd %d\n", RC_EVENT_DEVICE[i], fd_rc[i]);
 	}
 
+	//+++++++++++++++++++++++++++++++++++++++
 #ifdef KEYBOARD_INSTEAD_OF_REMOTE_CONTROL
 	fd_keyb = STDIN_FILENO;
 #else
 	fd_keyb = 0;
 #endif /* KEYBOARD_INSTEAD_OF_REMOTE_CONTROL */
-
-	 /*::open("/dev/dbox/rc0", O_RDONLY);
-	if (fd_keyb<0)
-	{
-		perror("/dev/stdin");
-		exit(-1);
-	}
-	*/
-	 
+	/*
+	   ::open("/dev/dbox/rc0", O_RDONLY);
+	   if (fd_keyb<0)
+	   {
+	   perror("/dev/stdin");
+	   exit(-1);
+	   }
+	   */
 #ifdef KEYBOARD_INSTEAD_OF_REMOTE_CONTROL
 	::fcntl(fd_keyb, F_SETFL, O_NONBLOCK);
 
@@ -184,7 +199,7 @@
 
 	new_termio             = orig_termio;
 	new_termio.c_lflag    &= ~ICANON;
-	//new_termio.c_lflag    &= ~(ICANON|ECHO);
+	//	new_termio.c_lflag    &= ~(ICANON|ECHO);
 	new_termio.c_cc[VMIN ] = 1;
 	new_termio.c_cc[VTIME] = 0;
 
@@ -195,16 +210,15 @@
 
 	//+++++++++++++++++++++++++++++++++++++++
 #endif /* KEYBOARD_INSTEAD_OF_REMOTE_CONTROL */
-	
+
+	open_click();
 	calculateMaxFd();
 }
 
 void CRCInput::close()
 {
-	for (int i = 0; i < NUMBER_OF_EVENT_DEVICES; i++) 
-	{
-		if (fd_rc[i] != -1) 
-		{
+	for (int i = 0; i < NUMBER_OF_EVENT_DEVICES; i++) {
+		if (fd_rc[i] != -1) {
 			::close(fd_rc[i]);
 			fd_rc[i] = -1;
 		}
@@ -213,8 +227,7 @@
 	if (saved_orig_termio)
 	{
 		::ioctl(STDIN_FILENO, TCSETA, &orig_termio);
-				
-		dprintf(DEBUG_DEBUG, "Original terminal settings restored.\n");	
+		printf("Original terminal settings restored.\n");
 	}
 #else
 /*
@@ -224,7 +237,6 @@
 	}
 */
 #endif /* KEYBOARD_INSTEAD_OF_REMOTE_CONTROL */
-
 	calculateMaxFd();
 }
 
@@ -235,54 +247,57 @@
 	for (int i = 0; i < NUMBER_OF_EVENT_DEVICES; i++)
 		if (fd_rc[i] > fd_max)
 			fd_max = fd_rc[i];
-	
+
 	if(fd_pipe_high_priority[0] > fd_max)
 		fd_max = fd_pipe_high_priority[0];
-	
 	if(fd_pipe_low_priority[0] > fd_max)
 		fd_max = fd_pipe_low_priority[0];
 }
 
+/**************************************************************************
+*	Destructor - close the input-device
+*
+**************************************************************************/
 CRCInput::~CRCInput()
 {
 	close();
 
 	if(fd_pipe_high_priority[0])
 		::close(fd_pipe_high_priority[0]);
-	
 	if(fd_pipe_high_priority[1])
 		::close(fd_pipe_high_priority[1]);
 
 	if(fd_pipe_low_priority[0])
 		::close(fd_pipe_low_priority[0]);
-	
 	if(fd_pipe_low_priority[1])
 		::close(fd_pipe_low_priority[1]);
 
 	if(fd_event)
 		::close(fd_event);
+	close_click();
 }
 
-/*
-* stopInput - stop reading rcin for plugins
-*/
+/**************************************************************************
+*	stopInput - stop reading rcin for plugins
+*
+**************************************************************************/
 void CRCInput::stopInput()
 {
+	input_stopped = true;
 	close();
 }
 
-/*
+/**************************************************************************
 *	restartInput - restart reading rcin after calling plugins
-*/
+*
+**************************************************************************/
 void CRCInput::restartInput()
 {
 	close();
 	open();
+	input_stopped = false;
 }
 
-/*
-* msg loop
-*/
 int CRCInput::messageLoop( bool anyKeyCancels, int timeout )
 {
 	neutrino_msg_t      msg;
@@ -295,18 +310,17 @@
 	if ( timeout == -1 )
 		timeout = g_settings.timing[SNeutrinoSettings::TIMING_MENU];
 
-	unsigned long long timeoutEnd = CRCInput::calcTimeoutEnd( timeout == 0 ? 0xFFFF : timeout);
+	uint64_t timeoutEnd = CRCInput::calcTimeoutEnd( timeout == 0 ? 0xFFFF : timeout);
 
 	while (doLoop)
 	{
 		g_RCInput->getMsgAbsoluteTimeout( &msg, &data, &timeoutEnd );
 
-		if ( ( msg == CRCInput::RC_timeout ) || ( msg == CRCInput::RC_home ) || ( msg == CRCInput::RC_ok ) )
-		{
+	if ( ( msg == CRCInput::RC_timeout ) ||
+		( msg == CRCInput::RC_home ) ||
+		( msg == CRCInput::RC_ok ) )
 			doLoop = false;
-		}
-		else if((msg == CRCInput::RC_sat) || (msg == CRCInput::RC_favorites))
-		{
+		else if((msg == CRCInput::RC_sat) || (msg == CRCInput::RC_favorites)) {
 		}
 		else
 		{
@@ -319,7 +333,8 @@
 			}
 			else if ( mr & messages_return::unhandled )
 			{
-				if ( (msg <= CRCInput::RC_MaxRC) && (data == 0) )                     /* <- button pressed */
+				if ((msg <= CRCInput::RC_MaxRC) &&
+				    (data == 0))                     /* <- button pressed */
 				{
 					if ( anyKeyCancels )
 						doLoop = false;
@@ -328,17 +343,19 @@
 				}
 			}
 		}
-	}
 
+
+	}
 	return res;
 }
 
-int CRCInput::addTimer(unsigned long long Interval, bool oneshot, bool correct_time )
+
+int CRCInput::addTimer(uint64_t Interval, bool oneshot, bool correct_time )
 {
 	struct timeval tv;
 
 	gettimeofday( &tv, NULL );
-	unsigned long long timeNow = (unsigned long long) tv.tv_usec + (unsigned long long)((unsigned long long) tv.tv_sec * (unsigned long long) 1000000);
+	uint64_t timeNow = (uint64_t) tv.tv_usec + (uint64_t)((uint64_t) tv.tv_sec * (uint64_t) 1000000);
 
 	timer _newtimer;
 	if (!oneshot)
@@ -354,43 +371,42 @@
 
 	_newtimer.correct_time = correct_time;
 
-	//dprintf(DEBUG_DEBUG, "adding timer %d (0x%llx, 0x%llx)\n", _newtimer.id, _newtimer.times_out, Interval);
+//printf("adding timer %d (0x%llx, 0x%llx)\n", _newtimer.id, _newtimer.times_out, Interval);
 
 	std::vector<timer>::iterator e;
 	for ( e= timers.begin(); e!= timers.end(); ++e )
-		if ( e->times_out > _newtimer.times_out )
+		if ( e->times_out> _newtimer.times_out )
 			break;
 
 	timers.insert(e, _newtimer);
-
 	return _newtimer.id;
 }
 
 int CRCInput::addTimer(struct timeval Timeout)
 {
-	unsigned long long timesout = (unsigned long long) Timeout.tv_usec + (unsigned long long)((unsigned long long) Timeout.tv_sec * (unsigned long long) 1000000);
-
+	uint64_t timesout = (uint64_t) Timeout.tv_usec + (uint64_t)((uint64_t) Timeout.tv_sec * (uint64_t) 1000000);
 	return addTimer( timesout, true, false );
 }
 
 int CRCInput::addTimer(const time_t *Timeout)
 {
-	return addTimer( (unsigned long long)*Timeout* (unsigned long long) 1000000, true, false );
+	return addTimer( (uint64_t)*Timeout* (uint64_t) 1000000, true, false );
 }
 
-void CRCInput::killTimer(uint32_t id)
+void CRCInput::killTimer(uint32_t &id)
 {
-	dprintf(DEBUG_DEBUG, "killing timer %d\n", id);
-	
+//printf("killing timer %d\n", id);
+	if(id == 0)
+		return;
+
 	std::vector<timer>::iterator e;
 	for ( e= timers.begin(); e!= timers.end(); ++e )
-	{
 		if ( e->id == id )
 		{
 			timers.erase(e);
 			break;
 		}
-	}
+	id = 0;
 }
 
 int CRCInput::checkTimers()
@@ -399,16 +415,14 @@
 	int _id = 0;
 
 	gettimeofday( &tv, NULL );
-	unsigned long long timeNow = (unsigned long long) tv.tv_usec + (unsigned long long)((unsigned long long) tv.tv_sec * (unsigned long long) 1000000);
+	uint64_t timeNow = (uint64_t) tv.tv_usec + (uint64_t)((uint64_t) tv.tv_sec * (uint64_t) 1000000);
 
 
 	std::vector<timer>::iterator e;
 	for ( e= timers.begin(); e!= timers.end(); ++e )
-	{
 		if ( e->times_out< timeNow+ 2000 )
 		{
-			dprintf(DEBUG_DEBUG, "timeout timer %d %llx %llx\n",e->id,e->times_out,timeNow );
-			
+//printf("timeout timer %d %llx %llx\n",e->id,e->times_out,timeNow );
 			_id = e->id;
 			if ( e->interval != 0 )
 			{
@@ -423,10 +437,8 @@
 
 		            	timers.erase(e);
 				for ( e= timers.begin(); e!= timers.end(); ++e )
-				{
-					if ( e->times_out > _newtimer.times_out )
+					if ( e->times_out> _newtimer.times_out )
 						break;
-				}
 
 				timers.insert(e, _newtimer);
 			}
@@ -434,86 +446,108 @@
 				timers.erase(e);
 
 			break;
-		}
-	}
-	//else
-		//printf("skipped timer %d %llx %llx\n",e->id,e->times_out, timeNow );
-
-	dprintf(DEBUG_DEBUG, "checkTimers: return %d\n", _id);
-
+        }
+//        else
+//    		printf("skipped timer %d %llx %llx\n",e->id,e->times_out, timeNow );
+//printf("checkTimers: return %d\n", _id);
 	return _id;
 }
 
-long long CRCInput::calcTimeoutEnd(const int timeout_in_seconds)
+
+
+int64_t CRCInput::calcTimeoutEnd(const int timeout_in_seconds)
 {
 	struct timeval tv;
 
 	gettimeofday(&tv, NULL);
 
-	return (unsigned long long) tv.tv_usec + (unsigned long long)((unsigned long long) tv.tv_sec + (unsigned long long)timeout_in_seconds) * (unsigned long long) 1000000;
+	return (uint64_t) tv.tv_usec + (uint64_t)((uint64_t) tv.tv_sec + (uint64_t)timeout_in_seconds) * (uint64_t) 1000000;
 }
 
-long long CRCInput::calcTimeoutEnd_MS(const int timeout_in_milliseconds)
+int64_t CRCInput::calcTimeoutEnd_MS(const int timeout_in_milliseconds)
 {
 	struct timeval tv;
 
 	gettimeofday(&tv, NULL);
 
-	unsigned long long timeNow = (unsigned long long) tv.tv_usec + (unsigned long long)((unsigned long long) tv.tv_sec * (unsigned long long) 1000000);
+	uint64_t timeNow = (uint64_t) tv.tv_usec + (uint64_t)((uint64_t) tv.tv_sec * (uint64_t) 1000000);
 
 	return ( timeNow + timeout_in_milliseconds * 1000 );
 }
 
-void CRCInput::getMsgAbsoluteTimeout(neutrino_msg_t * msg, neutrino_msg_data_t * data, unsigned long long *TimeoutEnd, bool bAllowRepeatLR)
+
+void CRCInput::getMsgAbsoluteTimeout(neutrino_msg_t * msg, neutrino_msg_data_t * data, uint64_t *TimeoutEnd, bool bAllowRepeatLR)
 {
 	struct timeval tv;
 
 	gettimeofday( &tv, NULL );
-	unsigned long long timeNow = (unsigned long long) tv.tv_usec + (unsigned long long)((unsigned long long) tv.tv_sec * (unsigned long long) 1000000);
+	uint64_t timeNow = (uint64_t) tv.tv_usec + (uint64_t)((uint64_t) tv.tv_sec * (uint64_t) 1000000);
 
-	unsigned long long diff;
+	uint64_t diff;
 
 	if ( *TimeoutEnd < timeNow+ 100 )
 		diff = 100;  // Minimum Differenz...
 	else
 		diff = ( *TimeoutEnd - timeNow );
-
-	dprintf(DEBUG_DEBUG, "CRCInput::getMsgAbsoluteTimeout diff %llx TimeoutEnd %llx now %llx\n", diff, *TimeoutEnd, timeNow);
-	
+//printf("CRCInput::getMsgAbsoluteTimeout diff %llx TimeoutEnd %llx now %llx\n", diff, *TimeoutEnd, timeNow);
 	getMsg_us( msg, data, diff, bAllowRepeatLR );
 
 	if ( *msg == NeutrinoMessages::EVT_TIMESET )
 	{
 		// recalculate timeout....
-		//unsigned long long ta= *TimeoutEnd;
-		*TimeoutEnd= *TimeoutEnd + *(long long*) *data;
+		//uint64_t ta= *TimeoutEnd;
+		*TimeoutEnd= *TimeoutEnd + *(int64_t*) *data;
 
-		dprintf(DEBUG_DEBUG, "[getMsgAbsoluteTimeout]: EVT_TIMESET - recalculate timeout\n%llx/%llx - %llx\n", timeNow, *(long long*) *data, *TimeoutEnd);
+		//printf("[getMsgAbsoluteTimeout]: EVT_TIMESET - recalculate timeout\n%llx/%llx - %llx/%llx\n", timeNow, *(int64_t*) *data, *TimeoutEnd, ta );
 	}
 }
 
 void CRCInput::getMsg(neutrino_msg_t * msg, neutrino_msg_data_t * data, int Timeout, bool bAllowRepeatLR)
 {
-	getMsg_us(msg, data, (unsigned long long) Timeout * 100 * 1000, bAllowRepeatLR);
+	getMsg_us(msg, data, (uint64_t) Timeout * 100 * 1000, bAllowRepeatLR);
 }
 
 void CRCInput::getMsg_ms(neutrino_msg_t * msg, neutrino_msg_data_t * data, int Timeout, bool bAllowRepeatLR)
 {
-	getMsg_us(msg, data, (unsigned long long) Timeout * 1000, bAllowRepeatLR);
+	getMsg_us(msg, data, (uint64_t) Timeout * 1000, bAllowRepeatLR);
+}
+
+
+static bool firstKey = true;
+
+uint32_t *CRCInput::setAllowRepeat(uint32_t *rk) {
+	uint32_t *r = repeatkeys;
+	repeatkeys = rk;
+	return r;
+}
+
+bool CRCInput::mayRepeat(uint32_t key)
+{
+	if (repeatkeys) {
+		uint32_t *k = repeatkeys;
+		while (*k != RC_nokey) {
+			if (*k == key) {
+				return true;
+			}
+			k++;
+		}
+	}
+	return false;
 }
 
+
 #define ENABLE_REPEAT_CHECK
-void CRCInput::getMsg_us(neutrino_msg_t * msg, neutrino_msg_data_t * data, unsigned long long Timeout, bool bAllowRepeatLR)
+void CRCInput::getMsg_us(neutrino_msg_t * msg, neutrino_msg_data_t * data, uint64_t Timeout, bool bAllowRepeatLR)
 {
-	static unsigned long long last_keypress = 0ULL;
-	unsigned long long getKeyBegin;
+	static uint64_t last_keypress = 0ULL;
+	uint64_t getKeyBegin;
 
 	//static __u16 rc_last_key =  KEY_MAX;
 	static __u16 rc_last_repeat_key =  KEY_MAX;
 
 	struct timeval tv, tvselect;
-	unsigned long long InitialTimeout = Timeout;
-	long long targetTimeout;
+	uint64_t InitialTimeout = Timeout;
+	int64_t targetTimeout;
 
 	int timer_id;
 	fd_set rfds;
@@ -521,18 +555,20 @@
 
 	*data = 0;
 
+
 	// wiederholung reinmachen - dass wirklich die ganze zeit bis timeout gewartet wird!
 	gettimeofday( &tv, NULL );
-	getKeyBegin = (unsigned long long) tv.tv_usec + (unsigned long long)((unsigned long long) tv.tv_sec * (unsigned long long) 1000000);
+	getKeyBegin = (uint64_t) tv.tv_usec + (uint64_t)((uint64_t) tv.tv_sec * (uint64_t) 1000000);
 
-	while(1) 
-	{
+	while(1) {
+		/* we later check for ev.type = EV_SYN which is 0x00, so set something invalid here... */
+		memset(&ev, 0, sizeof(ev));
+		ev.type = EV_MAX;
 		timer_id = 0;
-
 		if ( timers.size()> 0 )
 		{
 			gettimeofday( &tv, NULL );
-			unsigned long long t_n= (unsigned long long) tv.tv_usec + (unsigned long long)((unsigned long long) tv.tv_sec * (unsigned long long) 1000000);
+			uint64_t t_n= (uint64_t) tv.tv_usec + (uint64_t)((uint64_t) tv.tv_sec * (uint64_t) 1000000);
 			if ( timers[0].times_out< t_n )
 			{
 				timer_id = checkTimers();
@@ -543,7 +579,7 @@
 			else
 			{
 				targetTimeout = timers[0].times_out - t_n;
-				if ( (unsigned long long) targetTimeout> Timeout)
+				if ( (uint64_t) targetTimeout> Timeout)
 					targetTimeout= Timeout;
 				else
 					timer_id = timers[0].id;
@@ -564,9 +600,9 @@
 #ifdef KEYBOARD_INSTEAD_OF_REMOTE_CONTROL
 		if (true)
 #else
-		if (fd_keyb> 0)
+			if (fd_keyb> 0)
 #endif /* KEYBOARD_INSTEAD_OF_REMOTE_CONTROL */
-		FD_SET(fd_keyb, &rfds);
+				FD_SET(fd_keyb, &rfds);
 
 		FD_SET(fd_event, &rfds);
 		FD_SET(fd_pipe_high_priority[0], &rfds);
@@ -613,11 +649,12 @@
 			*msg  = buf.msg;
 			*data = buf.data;
 
-			dprintf(DEBUG_DEBUG, "got event from high-pri pipe %x %x\n", *msg, *data );
+			// printf("got event from high-pri pipe %x %x\n", *msg, *data );
 
 			return;
 		}
 
+
 #ifdef KEYBOARD_INSTEAD_OF_REMOTE_CONTROL
 		if (FD_ISSET(fd_keyb, &rfds))
 		{
@@ -727,75 +764,87 @@
 		}
 #else
 		/*
-		if(FD_ISSET(fd_keyb, &rfds))
-		{
-			char key = 0;
-			read(fd_keyb, &key, sizeof(key));
-			printf("keyboard: %d\n", rc_key);
-		}
-		*/
+		   if(FD_ISSET(fd_keyb, &rfds))
+		   {
+		   char key = 0;
+		   read(fd_keyb, &key, sizeof(key));
+		   printf("keyboard: %d\n", rc_key);
+		   }
+		   */
 #endif /* KEYBOARD_INSTEAD_OF_REMOTE_CONTROL */
 
-		if(FD_ISSET(fd_event, &rfds)) 
-		{
-			dprintf(DEBUG_DEBUG, "CRCInput::getMsg_us: event - accept!\n");
-			
+		if(FD_ISSET(fd_event, &rfds)) {
+			//printf("[neutrino] event - accept!\n");
 			socklen_t          clilen;
 			struct sockaddr_in cliaddr;
 			clilen = sizeof(cliaddr);
 			int fd_eventclient = accept(fd_event, (struct sockaddr *) &cliaddr, &clilen);
 
 			*msg = RC_nokey;
-			
-			dprintf(DEBUG_DEBUG, "CRCInput::getMsg_us: network event - read!\n");
-			
+			//printf("[neutrino] network event - read!\n");
 			CEventServer::eventHead emsg;
 			int read_bytes= recv(fd_eventclient, &emsg, sizeof(emsg), MSG_WAITALL);
-						
-			dprintf(DEBUG_DEBUG, "CRCInput::getMsg_us: event read %d bytes - following %d bytes\n", read_bytes, emsg.dataSize );			
-
-			if ( read_bytes == sizeof(emsg) ) 
-			{
+			//printf("[neutrino] event read %d bytes - following %d bytes\n", read_bytes, emsg.dataSize );
+			if ( read_bytes == sizeof(emsg) ) {
 				bool dont_delete_p = false;
 
 				unsigned char* p;
 				p= new unsigned char[ emsg.dataSize + 1 ];
-
 				if ( p!=NULL )
 				{
 					read_bytes= recv(fd_eventclient, p, emsg.dataSize, MSG_WAITALL);
-					
-					dprintf(DEBUG_DEBUG, "CRCInput::getMsg_us: eventbody read %d bytes - initiator %x\n", read_bytes, emsg.initiatorID );
+					//printf("[neutrino] eventbody read %d bytes - initiator %x\n", read_bytes, emsg.initiatorID );
 
-					/* nhttp event msg */
+#if 0
+					if ( emsg.initiatorID == CEventServer::INITID_CONTROLD )
+					{
+						switch(emsg.eventID)
+						{
+							case CControldClient::EVT_VOLUMECHANGED :
+								*msg = NeutrinoMessages::EVT_VOLCHANGED;
+								*data = 0;
+								break;
+							case CControldClient::EVT_MUTECHANGED :
+								*msg = NeutrinoMessages::EVT_MUTECHANGED;
+								*data = (unsigned) p;
+								dont_delete_p = true;
+								break;
+							case CControldClient::EVT_VCRCHANGED :
+								*msg = NeutrinoMessages::EVT_VCRCHANGED;
+								*data = *(int*) p;
+								break;
+							case CControldClient::EVT_MODECHANGED :
+								*msg = NeutrinoMessages::EVT_MODECHANGED;
+								*data = *(int*) p;
+								break;
+							default:
+								printf("[neutrino] event INITID_CONTROLD - unknown eventID 0x%x\n",  emsg.eventID );
+						}
+					}
+					else 
+#endif
 					if ( emsg.initiatorID == CEventServer::INITID_HTTPD )
-					{					  
-						dprintf(DEBUG_DEBUG, "CRCInput::getMsg_us: event - from NHTTPD %x %x\n", emsg.eventID, *(unsigned*) p);					
-						
+					{
 						switch(emsg.eventID)
 						{
 							case NeutrinoMessages::SHUTDOWN :
 								*msg = NeutrinoMessages::SHUTDOWN;
 								*data = 0;
 								break;
-								
 							case NeutrinoMessages::EVT_POPUP :
 								*msg = NeutrinoMessages::EVT_POPUP;
 								*data = (unsigned) p;
 								dont_delete_p = true;
 								break;
-								
 							case NeutrinoMessages::EVT_EXTMSG :
 								*msg = NeutrinoMessages::EVT_EXTMSG;
 								*data = (unsigned) p;
 								dont_delete_p = true;
 								break;
-								
 							case NeutrinoMessages::CHANGEMODE :	// Change
 								*msg = NeutrinoMessages::CHANGEMODE;
 								*data = *(unsigned*) p;
 								break;
-								
 							case NeutrinoMessages::STANDBY_TOGGLE :
 								*msg = NeutrinoMessages::STANDBY_TOGGLE;
 								*data = 0;
@@ -804,154 +853,142 @@
 								*msg = NeutrinoMessages::STANDBY_ON;
 								*data = 0;
 								break;
-								
 							case NeutrinoMessages::STANDBY_OFF :
 								*msg = NeutrinoMessages::STANDBY_OFF;
 								*data = 0;
 								break;
-								
 							case NeutrinoMessages::EVT_START_PLUGIN :
 								*msg = NeutrinoMessages::EVT_START_PLUGIN;
 								*data = (unsigned) p;
 								dont_delete_p = true;
 								break;
-								
 							case NeutrinoMessages::LOCK_RC :
 								*msg = NeutrinoMessages::LOCK_RC;
 								*data = 0;
 								break;
-								
 							case NeutrinoMessages::UNLOCK_RC :
 								*msg = NeutrinoMessages::UNLOCK_RC;
 								*data = 0;
 								break;
-								
 							default:
-								printf("CRCInput::getMsg_us: event INITID_HTTPD - unknown eventID 0x%x\n",  emsg.eventID );
+								printf("[neutrino] event INITID_HTTPD - unknown eventID 0x%x\n",  emsg.eventID );
 						}
 					}
 					else if ( emsg.initiatorID == CEventServer::INITID_SECTIONSD )
-					{					  
-						dprintf(DEBUG_DEBUG, "CRCInput::getMsg_us: event - from SECTIONSD %x %x\n", emsg.eventID, *(unsigned*) p);						
-
+					{
+						//printf("[neutrino] event - from SECTIONSD %x %x\n", emsg.eventID, *(unsigned*) p);
 						switch(emsg.eventID)
 						{
 							case CSectionsdClient::EVT_TIMESET:
-								{
-									struct timeval tv;
-									gettimeofday( &tv, NULL );
-									long long timeOld = (long long) tv.tv_usec + (long long)((long long) tv.tv_sec * (long long) 1000000);
-
-									//printf("[neutrino] event TIMESET from SECTIONSD %x %x\n", emsg.eventID, *(unsigned*) p);
-									//g_Sectionsd->registerEvent(CSectionsdClient::EVT_TIMESET, 222, NEUTRINO_UDS_NAME);
-
-									stime((time_t*) p);
-
-									gettimeofday( &tv, NULL );
-									long long timeNew = (long long) tv.tv_usec + (long long)((long long) tv.tv_sec * (long long) 1000000);
-
-									delete[] p;//new [] delete []
-									p= new unsigned char[ sizeof(long long) ];
-									*(long long*) p = timeNew - timeOld;
-
-									if ((long long)last_keypress > *(long long*)p)
-										last_keypress += *(long long *)p;
-
-									// Timer anpassen
-									for(std::vector<timer>::iterator e = timers.begin(); e != timers.end(); ++e)
-										if (e->correct_time)
-											e->times_out+= *(long long*) p;
-
-									*msg          = NeutrinoMessages::EVT_TIMESET;
-									*data         = (neutrino_msg_data_t) p;
-									dont_delete_p = true;
+							{
+								struct timeval ltv;
+								gettimeofday(&ltv, NULL);
+								int64_t timeOld = ltv.tv_usec + ltv.tv_sec * (int64_t)1000000;
+								time_t dvbtime = *((time_t*)p);
+								if (dvbtime) {
+									printf("[neutrino] timeset event. ");
+									time_t difftime = dvbtime - ltv.tv_sec;
+									if (abs(difftime) > 120) {
+										printf("difference is %ld s, stepping...\n", difftime);
+										if (stime(&dvbtime))
+											perror("stime");
+									} else if (difftime != 0) {
+										struct timeval oldd;
+										ltv.tv_sec = difftime;
+										ltv.tv_usec = 0;
+										if (adjtime(&ltv, &oldd))
+											perror("adjtime");
+										int64_t t = oldd.tv_sec * 1000000LL + oldd.tv_usec;
+										printf("difference is %ld s, using adjtime(). oldd: %lld us\n", difftime, t);
+									} else
+										printf("difference is 0 s, nothing to do...\n");
 								}
+								gettimeofday( &ltv, NULL );
+								int64_t timeNew = ltv.tv_usec + ltv.tv_sec * (int64_t)1000000;
+
+								delete[] p;//new [] delete []
+								p = new unsigned char[sizeof(int64_t)];
+								*(int64_t*) p = timeNew - timeOld;
+
+								if ((int64_t)last_keypress > *(int64_t*)p)
+								last_keypress += *(int64_t *)p;
+
+								// Timer anpassen
+								for(std::vector<timer>::iterator e = timers.begin(); e != timers.end(); ++e)
+									if (e->correct_time)
+										e->times_out+= *(int64_t*) p;
+								*msg          = NeutrinoMessages::EVT_TIMESET;
+								*data         = (neutrino_msg_data_t) p;
+								dont_delete_p = true;
 								break;
-								
+							}
 							case CSectionsdClient::EVT_GOT_CN_EPG:
-								//printf("CRCInput::getMsg_us: CSectionsdClient::EVT_GOT_CN_EPG\n");
+printf("[neutrino] CSectionsdClient::EVT_GOT_CN_EPG\n");
 								*msg          = NeutrinoMessages::EVT_CURRENTNEXT_EPG;
 								*data         = (neutrino_msg_data_t) p;
 								dont_delete_p = true;
 								break;
-								
 							case CSectionsdClient::EVT_SERVICES_UPDATE:
 								*msg          = NeutrinoMessages::EVT_SERVICES_UPD;
 								*data         = 0;
 								break;
-								
 							case CSectionsdClient::EVT_BOUQUETS_UPDATE:
 								break;
-								
 							case CSectionsdClient::EVT_WRITE_SI_FINISHED:
 								*msg          = NeutrinoMessages::EVT_SI_FINISHED;
 								*data         = 0;
 								break;
-								
 							default:
-								printf("CRCInput::getMsg_us: event INITID_SECTIONSD - unknown eventID 0x%x\n",  emsg.eventID );
+								printf("[neutrino] event INITID_SECTIONSD - unknown eventID 0x%x\n",  emsg.eventID );
 						}
 					}
 					else if ( emsg.initiatorID == CEventServer::INITID_ZAPIT )
-					{					  
-						dprintf(DEBUG_DEBUG, "CRCInput::getMsg_us: event - from ZAPIT %x %x\n", emsg.eventID, *(unsigned*) p);						
-						
+					{
+						//printf("[neutrino] event - from ZAPIT %x %x\n", emsg.eventID, *(unsigned*) p);
 						switch(emsg.eventID)
 						{
 							case CZapitClient::EVT_RECORDMODE_ACTIVATED:
 								*msg  = NeutrinoMessages::EVT_RECORDMODE;
 								*data = true;
 								break;
-								
 							case CZapitClient::EVT_RECORDMODE_DEACTIVATED:
 								*msg  = NeutrinoMessages::EVT_RECORDMODE;
 								*data = false;
 								break;
-								
 							case CZapitClient::EVT_ZAP_COMPLETE:
 								*msg = NeutrinoMessages::EVT_ZAP_COMPLETE;
 								break;
-								
 							case CZapitClient::EVT_ZAP_FAILED:
 								*msg = NeutrinoMessages::EVT_ZAP_FAILED;
 								break;
-								
 							case CZapitClient::EVT_ZAP_SUB_FAILED:
 								*msg = NeutrinoMessages::EVT_ZAP_SUB_FAILED;
 								break;
-								
 							case CZapitClient::EVT_ZAP_COMPLETE_IS_NVOD:
 								*msg = NeutrinoMessages::EVT_ZAP_ISNVOD;
 								break;
-								
 							case CZapitClient::EVT_ZAP_SUB_COMPLETE:
 								*msg = NeutrinoMessages::EVT_ZAP_SUB_COMPLETE;
 								break;
-								
 							case CZapitClient::EVT_SCAN_COMPLETE:
 								*msg  = NeutrinoMessages::EVT_SCAN_COMPLETE;
 								*data = 0;
 								break;
-								
 							case CZapitClient::EVT_SCAN_NUM_TRANSPONDERS:
 								*msg  = NeutrinoMessages::EVT_SCAN_NUM_TRANSPONDERS;
 								*data = *(unsigned*) p;
 								break;
-								
 							case CZapitClient::EVT_SCAN_REPORT_NUM_SCANNED_TRANSPONDERS:
 								*msg  = NeutrinoMessages::EVT_SCAN_REPORT_NUM_SCANNED_TRANSPONDERS;
 								*data = *(unsigned*) p;
 								break;
-								
 							case CZapitClient::EVT_SCAN_REPORT_FREQUENCY:
 								*msg = NeutrinoMessages::EVT_SCAN_REPORT_FREQUENCY;
 								*data = *(unsigned*) p;
 								break;
-								
 							case CZapitClient::EVT_SCAN_FOUND_A_CHAN:
 								*msg = NeutrinoMessages::EVT_SCAN_FOUND_A_CHAN;
 								break;
-								
 							case CZapitClient::EVT_SCAN_SERVICENAME:
 								*msg = NeutrinoMessages::EVT_SCAN_SERVICENAME;
 								break;
@@ -959,31 +996,25 @@
 								*msg  = NeutrinoMessages::EVT_SCAN_FOUND_TV_CHAN;
 								*data = *(unsigned*) p;
 								break;
-								
 							case CZapitClient::EVT_SCAN_FOUND_RADIO_CHAN:
 								*msg  = NeutrinoMessages::EVT_SCAN_FOUND_RADIO_CHAN;
 								*data = *(unsigned*) p;
 								break;
-								
 							case CZapitClient::EVT_SCAN_FOUND_DATA_CHAN:
 								*msg  = NeutrinoMessages::EVT_SCAN_FOUND_DATA_CHAN;
 								*data = *(unsigned*) p;
 								break;
-								
 							case CZapitClient::EVT_SCAN_REPORT_FREQUENCYP:
 								*msg  = NeutrinoMessages::EVT_SCAN_REPORT_FREQUENCYP;
 								*data = *(unsigned*) p;
 								break;
-								
 							case CZapitClient::EVT_SCAN_NUM_CHANNELS:
 								*msg = NeutrinoMessages::EVT_SCAN_NUM_CHANNELS;
 								*data = *(unsigned*) p;
 								break;
-								
 							case CZapitClient::EVT_SCAN_PROVIDER:
 								*msg = NeutrinoMessages::EVT_SCAN_PROVIDER;
 								break;
-								
 							case CZapitClient::EVT_SCAN_SATELLITE:
 								*msg = NeutrinoMessages::EVT_SCAN_SATELLITE;
 								break;
@@ -991,66 +1022,44 @@
 								*msg  = NeutrinoMessages::EVT_BOUQUETSCHANGED;
 								*data = 0;
 								break;
-								
 							case CZapitClient::EVT_SERVICES_CHANGED:
 								*msg  = NeutrinoMessages::EVT_SERVICESCHANGED;
 								*data = 0;
 								break;
-								
 							case CZapitClient::EVT_ZAP_CA_CLEAR:
 								*msg  = NeutrinoMessages::EVT_ZAP_CA_CLEAR;
 								*data = *(unsigned*) p;
 								break;
-								
 							case CZapitClient::EVT_ZAP_CA_LOCK:
 								*msg  = NeutrinoMessages::EVT_ZAP_CA_LOCK;
 								*data = *(unsigned*) p;
 								break;
-								
 							case CZapitClient::EVT_ZAP_CA_FTA:
 								*msg  = NeutrinoMessages::EVT_ZAP_CA_FTA;
 								*data = *(unsigned*) p;
 								break;
-							
 							case CZapitClient::EVT_ZAP_CA_ID :
 								*msg = NeutrinoMessages::EVT_ZAP_CA_ID;
 								*data = *(unsigned*) p;
 								break;
-								
 							case CZapitClient::EVT_SCAN_FAILED:
 								*msg  = NeutrinoMessages::EVT_SCAN_FAILED;
 								*data = 0;
 								break;
-								
 							case CZapitClient::EVT_ZAP_MOTOR:
 								*msg  = NeutrinoMessages::EVT_ZAP_MOTOR;
 								*data = *(unsigned*) p;
 								break;
-								
 							case CZapitClient::EVT_SDT_CHANGED:
 								*msg          = NeutrinoMessages::EVT_SERVICES_UPD;
 								*data         = 0;
 								break;
-								
-							//TEST
-							case CZapitClient::EVT_PIPMODE_ACTIVATED:
-								*msg  = NeutrinoMessages::EVT_PIPMODE;
-								*data = true;
-								break;
-								
-							case CZapitClient::EVT_PIPMODE_DEACTIVATED:
-								*msg  = NeutrinoMessages::EVT_PIPMODE;
-								*data = false;
-								break;
-								
 							case CZapitClient::EVT_PMT_CHANGED:
 								*msg          = NeutrinoMessages::EVT_PMT_CHANGED;
 								*data = (neutrino_msg_data_t) p;
 								break;
-							//
-							
 							default:
-								printf("CRCInput::getMsg_us: event INITID_ZAPIT - unknown eventID 0x%x\n",  emsg.eventID );
+								printf("[neutrino] event INITID_ZAPIT - unknown eventID 0x%x\n",  emsg.eventID );
 						}
 						if (((*msg) >= CRCInput::RC_WithData) && ((*msg) < CRCInput::RC_WithData + 0x10000000))
 						{
@@ -1059,21 +1068,19 @@
 						}
 					}
 					else if ( emsg.initiatorID == CEventServer::INITID_TIMERD )
-					{					  
-						dprintf(DEBUG_DEBUG, "CRCInput::getMsg_us: event - from TIMERD %x %x\n", emsg.eventID, *(unsigned*) p);					
-						
+					{
 						/*
-						if (emsg.eventID==CTimerdClient::EVT_ANNOUNCE_NEXTPROGRAM)
-						{
-						}
-
-						if (emsg.eventID==CTimerdClient::EVT_NEXTPROGRAM)
-						{
-							*msg = NeutrinoMessages::EVT_NEXTPROGRAM;
-							*data = (neutrino_msg_data_t) p;
-							dont_delete_p = true;
-						}
-						*/
+						   if (emsg.eventID==CTimerdClient::EVT_ANNOUNCE_NEXTPROGRAM)
+						   {
+						   }
+
+						   if (emsg.eventID==CTimerdClient::EVT_NEXTPROGRAM)
+						   {
+						 *msg = NeutrinoMessages::EVT_NEXTPROGRAM;
+						 *data = (neutrino_msg_data_t) p;
+						 dont_delete_p = true;
+						 }
+						 */
 						switch(emsg.eventID)
 						{
 							case CTimerdClient::EVT_ANNOUNCE_RECORD :
@@ -1081,66 +1088,54 @@
 								*data = (unsigned) p;
 								dont_delete_p = true;
 								break;
-								
 							case CTimerdClient::EVT_ANNOUNCE_ZAPTO :
 								*msg = NeutrinoMessages::ANNOUNCE_ZAPTO;
 								*data = 0;
 								break;
-								
 							case CTimerdClient::EVT_ANNOUNCE_SHUTDOWN :
 								*msg = NeutrinoMessages::ANNOUNCE_SHUTDOWN;
 								*data = 0;
 								break;
-								
 							case CTimerdClient::EVT_ANNOUNCE_SLEEPTIMER :
 								*msg = NeutrinoMessages::ANNOUNCE_SLEEPTIMER;
 								*data = 0;
 								break;
-								
 							case CTimerdClient::EVT_SLEEPTIMER :
 								*msg = NeutrinoMessages::SLEEPTIMER;
 								*data = 0;
 								break;
-								
 							case CTimerdClient::EVT_RECORD_START :
 								*msg = NeutrinoMessages::RECORD_START;
 								*data = (unsigned) p;
 								dont_delete_p = true;
 								break;
-								
 							case CTimerdClient::EVT_RECORD_STOP :
 								*msg = NeutrinoMessages::RECORD_STOP;
 								*data = (unsigned) p;
 								dont_delete_p = true;
 								break;
-								
 							case CTimerdClient::EVT_ZAPTO :
 								*msg = NeutrinoMessages::ZAPTO;
 								*data = (unsigned)  p;
 								dont_delete_p = true;
 								break;
-								
 							case CTimerdClient::EVT_SHUTDOWN :
 								*msg = NeutrinoMessages::SHUTDOWN;
 								*data = 0;
 								break;
-								
 							case CTimerdClient::EVT_STANDBY_ON :
 								*msg = NeutrinoMessages::STANDBY_ON;
 								*data = 0;
 								break;
-								
 							case CTimerdClient::EVT_STANDBY_OFF :
 								*msg = NeutrinoMessages::STANDBY_OFF;
 								*data = 0;
 								break;
-								
 							case CTimerdClient::EVT_REMIND :
 								*msg = NeutrinoMessages::REMIND;
 								*data = (unsigned) p;
 								dont_delete_p = true;
 								break;
-								
 							case CTimerdClient::EVT_EXEC_PLUGIN :
 								*msg = NeutrinoMessages::EVT_START_PLUGIN;
 								*data = (unsigned) p;
@@ -1148,15 +1143,14 @@
 								break;
 
 							default :
-								printf("CRCInput::getMsg_us: event INITID_TIMERD - unknown eventID 0x%x\n",  emsg.eventID );
+								printf("[neutrino] event INITID_TIMERD - unknown eventID 0x%x\n",  emsg.eventID );
 
 						}
 					}
 					else if (emsg.initiatorID == CEventServer::INITID_NEUTRINO)
-					{					  
-						dprintf(DEBUG_DEBUG, "CRCInput::getMsg_us: event - from NEUTRINO %x %x\n", emsg.eventID, *(unsigned*) p);					
-						
-						if ((emsg.eventID == NeutrinoMessages::EVT_RECORDING_ENDED) && (read_bytes == sizeof(stream2file_status2_t)))
+					{
+						if ((emsg.eventID == NeutrinoMessages::EVT_RECORDING_ENDED) &&
+								(read_bytes == sizeof(stream2file_status2_t)))
 						{
 							*msg  = NeutrinoMessages::EVT_RECORDING_ENDED;
 							*data = (neutrino_msg_data_t) p;
@@ -1164,9 +1158,7 @@
 						}
 					}
 					else if (emsg.initiatorID == CEventServer::INITID_GENERIC_INPUT_EVENT_PROVIDER)
-					{					  
-						dprintf(DEBUG_DEBUG, "CRCInput::getMsg_us: event - from GENERIC_INPUT_EVENT_PROVIDER %x %x\n", emsg.eventID, *(unsigned*) p);						
-						
+					{
 						if (read_bytes == sizeof(int))
 						{
 							*msg  = *(int *)p;
@@ -1174,8 +1166,7 @@
 						}
 					}
 					else
-						printf("CRCInput::getMsg_us: event - unknown initiatorID 0x%x\n",  emsg.initiatorID);
-					
+						printf("[neutrino] event - unknown initiatorID 0x%x\n",  emsg.initiatorID);
 					if ( !dont_delete_p )
 					{
 						delete[] p;//new [] delete []
@@ -1185,7 +1176,7 @@
 			}
 			else
 			{
-				printf("CRCInput::getMsg_us: event - read failed!\n");
+				printf("[neutrino] event - read failed!\n");
 			}
 
 			::close(fd_eventclient);
@@ -1198,57 +1189,74 @@
 			}
 		}
 
-		for (int i = 0; i < NUMBER_OF_EVENT_DEVICES; i++) 
-		{
-			if ((fd_rc[i] != -1) && (FD_ISSET(fd_rc[i], &rfds))) 
-			{
+		for (int i = 0; i < NUMBER_OF_EVENT_DEVICES; i++) {
+			if ((fd_rc[i] != -1) && (FD_ISSET(fd_rc[i], &rfds))) {
 				int ret;
-
 				ret = read(fd_rc[i], &ev, sizeof(t_input_event));
-
-				if(ret != sizeof(t_input_event)) 
+				if (ret != sizeof(t_input_event)) {
+					if (errno == ENODEV) {
+						/* hot-unplugged? */
+						::close(fd_rc[i]);
+						fd_rc[i] = -1;
+					}
 					continue;
-								
-				dprintf(DEBUG_NORMAL, "CRCInput::getMsg_us: key: 0x%X value %d, translate: 0x%X -%s-\n", ev.code, ev.value, translate(ev.code, i), getKeyName(translate(ev.code, i)).c_str());				
-
+				}
+				if (ev.type == EV_SYN)
+					continue; /* ignore... */
 				uint32_t trkey = translate(ev.code, i);
-
-				if (trkey == RC_nokey) 
+#ifdef _DEBUG
+				printf("key: %04x value %d, translate: %04x -%s-\n", ev.code, ev.value, trkey, getKeyName(trkey).c_str());
+#endif
+				if (trkey == RC_nokey)
 					continue;
-				
-				if (ev.value) 
-				{
-					dprintf(DEBUG_DEBUG, "got keydown native key: %04x %04x, translate: %04x -%s-\n", ev.code, ev.code&0x1f, translate(ev.code, 0), getKeyName(translate(ev.code, 0)).c_str());
-					dprintf(DEBUG_DEBUG, "rc_last_key %04x rc_last_repeat_key %04x\n\n", rc_last_key, rc_last_repeat_key);
+				if (ev.value) {
+#ifdef RCDEBUG
+					printf("got keydown native key: %04x %04x, translate: %04x -%s-\n", ev.code, ev.code&0x1f, translate(ev.code, 0), getKeyName(translate(ev.code, 0)).c_str());
+					printf("rc_last_key %04x rc_last_repeat_key %04x\n\n", rc_last_key, rc_last_repeat_key);
+#endif
+
+					if (firstKey) {
+						char c = '0';
+						firstKey = false;
+						int wtw = ::open ("/proc/stb/fp/was_timer_wakeup", O_RDONLY);
+						if (wtw > -1) {
+							::read(wtw, &c, 1);
+							::close(wtw);
+						}
+						wtw = ::open ("/proc/stb/fp/was_timer_wakeup", O_WRONLY);
+						if (wtw > -1) {
+							::write(wtw, "0\n", 2);
+							::close(wtw);
+						}
+					}
 
-					unsigned long long now_pressed;
+					uint64_t now_pressed;
 					bool keyok = true;
 
 					tv = ev.time;
-					now_pressed = (unsigned long long) tv.tv_usec + (unsigned long long)((unsigned long long) tv.tv_sec * (unsigned long long) 1000000);
-					if (ev.code == rc_last_key) 
-					{
+					now_pressed = (uint64_t) tv.tv_usec + (uint64_t)((uint64_t) tv.tv_sec * (uint64_t) 1000000);
+					if (ev.code == rc_last_key) {
 						/* only allow selected keys to be repeated */
 						/* (why?)                                  */
-						if((trkey == RC_up) || (trkey == RC_down   ) ||
+						if( 	(trkey == RC_up) || (trkey == RC_down   ) ||
 							(trkey == RC_plus   ) || (trkey == RC_minus  ) ||
 							(trkey == RC_page_down   ) || (trkey == RC_page_up  ) ||
-							//(trkey == RC_standby) ||
-							((bAllowRepeatLR) && ((trkey == RC_left ) ||
-								(trkey == RC_right))))
+							((bAllowRepeatLR) && ((trkey == RC_left ) || (trkey == RC_right))) ||
+							((trkey == RC_standby)
+
+							))
 						{
 #ifdef ENABLE_REPEAT_CHECK
-							if (rc_last_repeat_key != ev.code) 
-							{
+							if (rc_last_repeat_key != ev.code) {
 								if ((now_pressed > last_keypress + repeat_block) ||
 										/* accept all keys after time discontinuity: */
-										(now_pressed < last_keypress)) 
+										(now_pressed < last_keypress))
 									rc_last_repeat_key = ev.code;
 								else
 									keyok = false;
 							}
 #endif
-						}
+					}
 						else
 							keyok = false;
 					}
@@ -1257,12 +1265,11 @@
 
 					rc_last_key = ev.code;
 
-					if (keyok) 
-					{
+					if (keyok) {
 #ifdef ENABLE_REPEAT_CHECK
 						if ((now_pressed > last_keypress + repeat_block_generic) ||
 								/* accept all keys after time discontinuity: */
-								(now_pressed < last_keypress)) 
+								(now_pressed < last_keypress))
 #endif
 						{
 							last_keypress = now_pressed;
@@ -1274,14 +1281,13 @@
 						}
 					} /*if keyok */
 				} /* if (ev.value) */
-				else 
-				{
+				else {
 					// clear rc_last_key on keyup event
-					dprintf(DEBUG_DEBUG, "got keyup native key: %04x %04x, translate: %04x -%s-\n", ev.code, ev.code&0x1f, translate(ev.code, 0), getKeyName(translate(ev.code, 0)).c_str() );
-
+#ifdef RCDEBUG
+					printf("got keyup native key: %04x %04x, translate: %04x -%s-\n", ev.code, ev.code&0x1f, translate(ev.code, 0), getKeyName(translate(ev.code, 0)).c_str() );
+#endif
 					rc_last_key = KEY_MAX;
-					if (trkey == RC_standby) 
-					{
+					if (trkey == RC_standby) {
 						*msg = RC_standby;
 						*data = 1; /* <- button released */
 						return;
@@ -1289,6 +1295,8 @@
 				}
 			}/* if FDSET */
 		} /* for NUMBER_OF_EVENT_DEVICES */
+		if (ev.type == EV_SYN)
+			continue; /* ignore... */
 
 		if(FD_ISSET(fd_pipe_low_priority[0], &rfds))
 		{
@@ -1315,9 +1323,9 @@
 		{
 			//timeout neu kalkulieren
 			gettimeofday( &tv, NULL );
-			long long getKeyNow = (long long) tv.tv_usec + (long long)((long long) tv.tv_sec * (long long) 1000000);
-			long long diff = (getKeyNow - getKeyBegin);
-			if( Timeout <= (unsigned long long) diff )
+			int64_t getKeyNow = (int64_t) tv.tv_usec + (int64_t)((int64_t) tv.tv_sec * (int64_t) 1000000);
+			int64_t diff = (getKeyNow - getKeyBegin);
+			if( Timeout <= (uint64_t) diff )
 			{
 				*msg = RC_timeout;
 				*data = 0;
@@ -1359,25 +1367,28 @@
 	rc_last_key =  KEY_MAX;
 }
 
-/*
+/**************************************************************************
 *       isNumeric - test if key is 0..9
-*/
+*
+**************************************************************************/
 bool CRCInput::isNumeric(const neutrino_msg_t key)
 {
 	return ((key == RC_0) || ((key >= RC_1) && (key <= RC_9)));
 }
 
-/*
+/**************************************************************************
 *       getNumericValue - return numeric value of the key or -1
-*/
+*
+**************************************************************************/
 int CRCInput::getNumericValue(const neutrino_msg_t key)
 {
 	return ((key == RC_0) ? (int)0 : (((key >= RC_1) && (key <= RC_9)) ? (int)(key - RC_1 + 1) : (int)-1));
 }
 
-/*
+/**************************************************************************
 *       convertDigitToKey - return key representing digit or RC_nokey
-*/
+*
+**************************************************************************/
 static const unsigned int digit_to_key[10] = {CRCInput::RC_0, CRCInput::RC_1, CRCInput::RC_2, CRCInput::RC_3, CRCInput::RC_4, CRCInput::RC_5, CRCInput::RC_6, CRCInput::RC_7, CRCInput::RC_8, CRCInput::RC_9};
 
 unsigned int CRCInput::convertDigitToKey(const unsigned int digit)
@@ -1385,9 +1396,10 @@
 	return (digit < 10) ? digit_to_key[digit] : RC_nokey;
 }
 
-/*
+/**************************************************************************
 *       getUnicodeValue - return unicode value of the key or -1
-*/
+*
+**************************************************************************/
 #define UNICODE_VALUE_SIZE 58
 static const int unicode_value[UNICODE_VALUE_SIZE] = {-1 , -1 , '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', '=', -1 , -1 ,
 						      'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P', '{', '}', -1 , -1 , 'A', 'S',
@@ -1402,252 +1414,298 @@
 		return -1;
 }
 
-/*
+/**************************************************************************
 *       transforms the rc-key to const char *
-*/
+*
+**************************************************************************/
 const char * CRCInput::getSpecialKeyName(const unsigned int key)
 {
 	switch(key)
 	{
-		case RC_standby:
-			return "standby";
-				
-		case RC_home:
-#if HAVE_DVB_API_VERSION == 1
-			return "lame";
-#else
-			return "home";
-#endif
-
-		case RC_setup:
-#if HAVE_DVB_API_VERSION == 1
-			return "dream";
-#else
-			return "setup";
-#endif
-
-		case RC_red:
-			return "red button";
-				
-		case RC_green:
-			return "green button";
-				
-		case RC_yellow:
-			return "yellow button";
-				
-		case RC_blue:
-			return "blue button";
-				
-		case RC_page_up:
-			return "page up";
-				
-		case RC_page_down:
-			return "page down";
-				
-		case RC_up:
-			return "cursor up";
-				
-		case RC_down:
-			return "cursor down";
-				
-		case RC_left:
-			return "cursor left";
-				
-		case RC_right:
-			return "cursor right";
-				
-		case RC_ok:
-			return "ok";
-				
-		case RC_plus:
-			return "vol. inc";
-				
-		case RC_minus:
-			return "vol. dec";
-				
-		case RC_spkr:
-			return "mute";
-				
-		case RC_info:
-			return "info";
-
-		case RC_audio:
-			return "audio";
-				
-		case RC_video:
-			return "video";
-		
-#if defined (PLATFORM_CUBEREVO) || defined (PLATFORM_CUBEREVO_MINI) || defined (PLATFORM_CUBEREVO_MINI2) || defined (PLATFORM_CUBEREVO_MINI_FTA) || defined (PLATFORM_CUBEREVO_250HD) || defined (PLATFORM_CUBEREVO_2000HD) || defined (PLATFORM_CUBEREVO_9500HD)			
-		case RC_picture:
-			return "picture";
-				
-		case RC_music:
-			return "music";
-#endif			
-
-		case RC_text:
-			return "text";
-
-		case RC_epg:
-			return "epg";
-				
-		case RC_recall:
-			return "recall";
-				
-		case RC_favorites:
-			return "favorites";
-				
-		case RC_sat:
-			return "sat";
-				
-		case RC_play:
-			return "play";
-				
-		case RC_stop:
-			return "stop";
-				
-		case RC_forward:
-			return "forward";
-				
-		case RC_rewind:
-			return "rewind";
-				
-		case RC_timeshift:
-			return "timeshift";
-
-		case RC_mode:
-			return "mode";
-				
-		case RC_record:
-			return "record";
-				
-		case RC_pause:
-			return "pause";
-		
-#if defined (PLATFORM_CUBEREVO) || defined (PLATFORM_CUBEREVO_MINI) || defined (PLATFORM_CUBEREVO_MINI2) || defined (PLATFORM_CUBEREVO_MINI_FTA) || defined (PLATFORM_CUBEREVO_250HD) || defined (PLATFORM_CUBEREVO_2000HD) || defined (PLATFORM_CUBEREVO_9500HD)			
-		case RC_repeat:
-			return "repeat";
-				
-		case RC_slow:
-			return "slow";
-#endif			
-				
-		//case RC_games:
-		//	return "games";
-
-		case RC_next:
-			return "next";
-				
-		case RC_prev:
-			return "prev";
-
-#if defined (PLATFORM_CUBEREVO) || defined (PLATFORM_CUBEREVO_MINI) || defined (PLATFORM_CUBEREVO_MINI2) || defined (PLATFORM_CUBEREVO_MINI_FTA) || defined (PLATFORM_CUBEREVO_250HD) || defined (PLATFORM_CUBEREVO_2000HD) || defined (PLATFORM_CUBEREVO_9500HD)
-		case RC_dvbsub:
-			return "dvbsub";
-				
-		case RC_pip:
-			return "pip";
-				
-		case RC_pippos:
-			return "pippos";
-				
-		case RC_pipswap:
-			return "pipswap";
-				
-		case RC_pipsubch:
-			return "pipsubch";
-				
-		case RC_bookmark:
-			return "bookmark";
-				
-		case RC_net:
-			return "inet";
+			case RC_standby:
+				return "standby";
+			case RC_home:
+				return "home";
+			case RC_setup:
+				return "setup";
+			case RC_red:
+				return "red button";
+			case RC_green:
+				return "green button";
+			case RC_yellow:
+				return "yellow button";
+			case RC_blue:
+				return "blue button";
+			case RC_page_up:
+				return "page up";
+			case RC_page_down:
+				return "page down";
+			case RC_up:
+				return "cursor up";
+			case RC_down:
+				return "cursor down";
+			case RC_left:
+				return "cursor left";
+			case RC_right:
+				return "cursor right";
+			case RC_ok:
+				return "ok";
+			case RC_plus:
+				return "vol. inc";
+			case RC_minus:
+				return "vol. dec";
+			case RC_spkr:
+				return "mute";
+			case RC_help:
+				return "help";
+			case RC_info:
+				return "info";
+			case RC_topleft:
+				return "topleft";
+			case RC_topright:
+				return "topright";
+			case RC_audio:
+				return "audio";
+			case RC_video:
+				return "video";
+			case RC_tv:
+				return "tv";
+			case RC_radio:
+				return "radio";
+			case RC_text:
+				return "text";
+#if 0
+			case RC_shift_red:
+				return "shift-red";
+			case RC_shift_green:
+				return "shift-green";
+			case RC_shift_yellow:
+				return "shift-yellow";
+			case RC_shift_blue:
+				return "shift-blue";
+			case RC_shift_tv:
+				return "shift-tv";
+			case RC_shift_radio:
+				return "shift-radio";
 #endif
+			case RC_multifeed:
+				return "multifeed";
 
-		case RC_multifeed:
-			return "multifeed";
-		
-#if defined (PLATFORM_GIGABLUE)			
-		case RC_f1:
-			return "f1";
-					
-		case RC_f2:
-			return "f2";
-			
-		case RC_f3:
-			return "f3";
-			
-		case RC_f4:
-			return "f4";
-			
-		case RC_aspect:
-			return "aspect";
-#endif			
-				
-		/* VFD Tasten the generic values are from cuberevo so fix it */
-		case RC_vfdup:
-			return "vfdup";
-				
-		case RC_vfddown:
-			return "vfddown";
-				
-		case RC_vfdright:
-			return "vfdright";
-				
-		case RC_vfdleft:
-			return "vfdleft";
-				
-		case RC_vfdpower:
-			return "vfdpower";
-				
-		case RC_vfdmenu:
-			return "vfdmenu";
-				
-		case RC_vfdexit:
-			return "vfdexit";
-				
-		case RC_vfdok:
-			return "vfdok";
-
-		case RC_timeout:
-			return "timeout";
-
-		case RC_nokey:
-			return "none";
-			
-		default:
-			printf("unknown key: 0x%x\n", key);
-			return "unknown";
+			case RC_epg:
+				return "epg";
+			case RC_recall:
+				return "recall";
+			case RC_favorites:
+				return "favorites";
+			case RC_sat:
+				return "sat";
+			case RC_sat2:
+				return "sat2";
+			case RC_timeout:
+				return "timeout";
+			case RC_play:
+				return "play";
+			case RC_stop:
+				return "stop";
+			case RC_forward:
+				return "forward";
+			case RC_rewind:
+				return "rewind";
+			case RC_timeshift:
+				return "timeshift";
+			case RC_mode:
+				return "v.format";
+			case RC_record:
+				return "record";
+			case RC_pause:
+				return "pause";
+			case RC_games:
+				return "games";
+			case RC_next:
+				return "next";
+			case RC_prev:
+				return "prev";
+			case RC_nokey:
+				return "none";
+			case RC_power_on:
+				return "power on";
+			case RC_power_off:
+				return "power off";
+			case RC_standby_on:
+				return "standby on";
+			case RC_standby_off:
+				return "standby off";
+			case RC_mute_on:
+				return "mute on";
+			case RC_mute_off:
+				return "mute off";
+			case RC_analog_on:
+				return "analog on";
+			case RC_analog_off:
+				return "analog off";
+			case RC_www:
+				return "window print";
+			case RC_find:
+				return "find";
+			case RC_pip:
+				return "pip";
+			case RC_archive:
+				return "archive";
+			case RC_slow:
+				return "slow";
+			case RC_fastforward:
+				return "fast";
+			case RC_playmode:
+				return "play mode";
+			case RC_usb:
+				return "usb";
+			case RC_timer:
+				return "time";
+			case RC_f1:
+				return "f1";
+			case RC_f2:
+				return "f2";
+			case RC_f3:
+				return "f3";
+			case RC_f4:
+				return "f4";
+			case RC_prog1:
+				return "prog1";
+			case RC_prog2:
+				return "prog2";
+			case RC_prog3:
+				return "prog3";
+			case RC_prog4:
+				return "prog4";
+			default:
+				printf("unknown key: %d (0x%x) \n", key, key);
+				return "unknown";
 	}
 }
 
 std::string CRCInput::getKeyName(const unsigned int key)
 {
-	int unicode_value = getUnicodeValue(key);
-	if (unicode_value == -1)
+	int lunicode_value = getUnicodeValue(key);
+	if (lunicode_value == -1)
 		return getSpecialKeyName(key);
 	else
 	{
 		char tmp[2];
-		tmp[0] = unicode_value;
+		tmp[0] = lunicode_value;
 		tmp[1] = 0;
 		return std::string(tmp);
 	}
 }
 
-/*
-* transforms the rc-key to generic - internal use only!
-*/
-int CRCInput::translate(int code, int num)
-{
-	if(code == 0x100) 
-		code = RC_up;
-	else if(code == 0x101) 
-		code = RC_down;
-		
+/**************************************************************************
+*	transforms the rc-key to generic - internal use only!
+*
+**************************************************************************/
+int CRCInput::translate(int code, int /*num*/)
+{
+	// For simubutton/evremote2, as long as our lircd configuration is
+	// messed up.  --martii
+	switch (code) {
+		case KEY_EXIT:
+		case KEY_HOME:
+			return RC_home;
+		case 0x100:
+			return RC_up;
+		case 0x101:
+			return RC_down;
+	}
 	if ((code >= 0) && (code <= KEY_MAX))
 		return code;
 	else
 		return RC_nokey;
 }
 
+void CRCInput::close_click()
+{
+}
+
+void CRCInput::open_click()
+{
+}
+
+void CRCInput::reset_dsp(int /*rate*/)
+{
+}
+
+void CRCInput::set_dsp()
+{
+}
+
+void CRCInput::play_click()
+{
+}
+
+
+#ifdef HAVE_COOLSTREAM_NEVIS_IR_H
+// hint: ir_protocol_t and other useful things are defined in nevis_ir.h
+void CRCInput::set_rc_hw(ir_protocol_t ir_protocol, unsigned int ir_address)
+{
+	int ioctl_ret = -1;
+
+	//fixme?: for now fd_rc[] is hardcoded to 0 since only fd_rc[0] is used at the moment
+	ioctl_ret = ::ioctl(fd_rc[0], IOC_IR_SET_PRI_PROTOCOL, ir_protocol);
+	if(ioctl_ret < 0)
+		perror("IOC_IR_SET_PRI_PROTOCOL");
+	else
+		printf("CRCInput::set_rc_hw: Set IOCTRL : IOC_IR_SET_PRI_PROTOCOL, %05X\n", ir_protocol);
+
+	//bypass setting of IR Address with ir_address=0
+	if(ir_address > 0)
+	{
+		//fixme?: for now fd_rc[] is hardcoded to 0 since only fd_rc[0] is used at the moment
+		ioctl_ret = ::ioctl(fd_rc[0], IOC_IR_SET_PRI_ADDRESS, ir_address);
+		if(ioctl_ret < 0)
+			perror("IOC_IR_SET_PRI_ADDRESS");
+		else
+			printf("CRCInput::set_rc_hw: Set IOCTRL : IOC_IR_SET_PRI_ADDRESS,  %05X\n", ir_address);
+	}
+}
+
+// hint: ir_protocol_t and other useful things are defined in nevis_ir.h
+void CRCInput::set_rc_hw(void)
+{
+	ir_protocol_t ir_protocol = IR_PROTOCOL_UNKNOWN;
+	unsigned int ir_address = 0x00;
+
+	switch(g_settings.remote_control_hardware)
+	{
+		case RC_HW_COOLSTREAM:
+			ir_protocol = IR_PROTOCOL_NECE;
+			ir_address  = 0xFF80;
+			break;
+		case RC_HW_DBOX:
+			ir_protocol = IR_PROTOCOL_NRC17;
+			ir_address  = 0x00C5;
+			break;
+		case RC_HW_PHILIPS:
+			ir_protocol = IR_PROTOCOL_RC5;
+			ir_address  = 0x000A;
+			break;
+		case RC_HW_TRIPLEDRAGON:
+			ir_protocol = IR_PROTOCOL_RMAP_E;
+			ir_address  = 0x000A; // with device id 0
+//			ir_address  = 0x100A; // with device id 1
+//			ir_address  = 0x200A; // with device id 2
+//			ir_address  = 0x300A; // with device id 3
+//			ir_address  = 0x400A; // with device id 4
+//			ir_address  = 0x500A; // with device id 5
+//			ir_address  = 0x600A; // with device id 6
+//			ir_address  = 0x700A; // with device id 7
+			break;
+		default:
+			ir_protocol = IR_PROTOCOL_NECE;
+			ir_address  = 0xFF80;
+	}
+	
+	set_rc_hw(ir_protocol, ir_address);
+}
+#else
+void CRCInput::set_rc_hw(void)
+{
+}
+#endif
 
--- neutrino-hd2/lib/Makefile.am	2012-07-09 11:16:56.377523130 +0200
+++ neutrino-hd2/lib/Makefile.am	2012-07-09 12:39:48.706179582 +0200
@@ -10,7 +10,6 @@
 	libtuxtxt \
 	libdvbsub \
 	libupnpclient \
-	liblcddisplay \
 	libcoolstream
 
 # libeplayer3

--- neutrino-hd2/src/neutrino.cpp	2012-07-12 20:35:31.293469900 +0200
+++ neutrino-hd2/src/neutrino.cpp	2012-07-12 20:43:10.695747949 +0200
@@ -151,6 +151,7 @@
 
 #include <zapit/channel.h>
 #include <zapit/bouquets.h>
+#include "libtuxtxt/teletext.h"
 
 extern tallchans allchans;
 extern CBouquetManager * g_bouquetManager;
@@ -188,11 +189,11 @@
 //extern void tuxtxt_start(int tpid, int source );
 extern int  tuxtxt_stop();
 extern void tuxtxt_close();
-extern void tuxtx_pause_subtitle(bool pause, int source);
+//extern void tuxtx_pause_subtitle(bool pause, int source);
 extern void tuxtx_stop_subtitle();
 extern void tuxtx_set_pid(int pid, int page, const char * cc);
 extern int tuxtx_subtitle_running(int *pid, int *page, int *running);
-extern int tuxtx_main(int _rc, int pid, int page, int source );
+//extern int tuxtx_main(int _rc, int pid, int page, int source );
 
 // dvbsub
 extern int dvbsub_initialise();
@@ -1152,9 +1153,6 @@
 	
 	// radiotext
 	g_settings.radiotext_enable = configfile.getBool("radiotext_enable"          , false);
-	
-	// logos_dir
-	g_settings.logos_dir = configfile.getString("logos_dir", "/var/share/icons/logo");
 	// END MISC OPTS
 
 	// HDD
@@ -1523,9 +1521,6 @@
 	
 	// radiotext
 	configfile.setBool("radiotext_enable", g_settings.radiotext_enable);
-	
-	// logos_dir
-	configfile.setString("logos_dir", g_settings.logos_dir);
 	// END MISC OPTS
 
 	// HDD
@@ -2754,7 +2749,7 @@
 				
 				printf("current service fe(%d)\n", si.FeIndex);
 
-				tuxtx_main(g_RCInput->getFileHandle(), g_RemoteControl->current_PIDs.PIDs.vtxtpid, 0, si.FeIndex );
+				tuxtx_main(g_RCInput->getFileHandle(), g_RemoteControl->current_PIDs.PIDs.vtxtpid, 0, 0, atoi(g_settings.repeat_blocker), atoi(g_settings.repeat_genericblocker));
 
 				frameBuffer->paintBackground();
 
@@ -5099,10 +5094,8 @@
 	else if(actionKey == "audioplayerdir") 
 	{
 		parent->hide();
-		
 		CFileBrowser b;
 		b.Dir_Mode=true;
-		
 		if (b.exec(g_settings.network_nfs_audioplayerdir))
 			strncpy(g_settings.network_nfs_audioplayerdir, b.getSelectedFile()->Name.c_str(), sizeof(g_settings.network_nfs_audioplayerdir)-1);
 		
@@ -5111,10 +5104,8 @@
 	else if(actionKey == "picturedir") 
 	{
 		parent->hide();
-		
 		CFileBrowser b;
 		b.Dir_Mode=true;
-		
 		if (b.exec(g_settings.network_nfs_picturedir))
 			strncpy(g_settings.network_nfs_picturedir, b.getSelectedFile()->Name.c_str(), sizeof(g_settings.network_nfs_picturedir)-1);
 		
@@ -5123,7 +5114,6 @@
 	else if(actionKey == "moviedir") 
 	{
 		parent->hide();
-		
 		CFileBrowser b;
 		b.Dir_Mode=true;
 
@@ -5135,7 +5125,6 @@
 	else if(actionKey == "recordingdir") 
 	{
 		parent->hide();
-		
 		CFileBrowser b;
 		b.Dir_Mode=true;
 
@@ -5163,15 +5152,13 @@
 	else if(actionKey == "update_dir") 
 	{
 		parent->hide();
-		
 		CFileBrowser fileBrowser;
 		fileBrowser.Dir_Mode = true;
-		
 		if (fileBrowser.exec(g_settings.update_dir) == true) 
 		{
 			const char * newdir = fileBrowser.getSelectedFile()->Name.c_str();
 			if(check_dir(newdir))
-				printf("CNeutrinoApp::exec: Wrong/unsupported update dir %s\n", newdir);
+				printf("CNeutrinoApp::exec: Wrong/unsupported recording dir %s\n", newdir);
 			else
 			{
 				strcpy(g_settings.update_dir, fileBrowser.getSelectedFile()->Name.c_str());
@@ -5183,10 +5170,8 @@
 	else if(actionKey == "epgdir") 
 	{
 		parent->hide();
-		
 		CFileBrowser b;
 		b.Dir_Mode=true;
-		
 		if (b.exec(g_settings.epg_dir.c_str())) 
 		{
 			const char * newdir = b.getSelectedFile()->Name.c_str();
@@ -5201,27 +5186,6 @@
 
 		return menu_return::RETURN_REPAINT;
 	}
-	else if(actionKey == "logos_dir") 
-	{
-		parent->hide();
-		
-		CFileBrowser b;
-		b.Dir_Mode=true;
-		
-		if (b.exec(g_settings.logos_dir.c_str())) 
-		{
-			const char * newdir = b.getSelectedFile()->Name.c_str();
-			if(check_dir(newdir))
-				printf("CNeutrinoApp::exec: Wrong/unsupported logos dir %s\n", newdir);
-			else
-			{
-				g_settings.logos_dir = b.getSelectedFile()->Name;
-				dprintf(DEBUG_NORMAL, "CNeutrinoApp::exec: new logos dir %s\n", b.getSelectedFile()->Name.c_str());
-			}
-		}
-
-		return menu_return::RETURN_REPAINT;
-	}
 	else if(actionKey == "loadcolors") 
 	{
 		parent->hide();
@@ -5230,13 +5194,11 @@
 		CFileFilter fileFilter;
 		fileFilter.addFilter("conf");
 		fileBrowser.Filter = &fileFilter;
-		
 		if (fileBrowser.exec("/var/tuxbox/config") == true) 
 		{
 			loadColors(fileBrowser.getSelectedFile()->Name.c_str());
 			dprintf(DEBUG_NORMAL, "CNeutrinoApp::exec: new colors: %s\n", fileBrowser.getSelectedFile()->Name.c_str());
 		}
-		
 		return menu_return::RETURN_REPAINT;
 	}
 	else if(actionKey == "savecolors") 
@@ -5256,7 +5218,6 @@
 			saveColors(sname);
 			delete sms;
 		}
-		
 		return menu_return::RETURN_REPAINT;
 	}
 	else if(actionKey == "loadkeys") 
@@ -5267,22 +5228,18 @@
 		CFileFilter fileFilter;
 		fileFilter.addFilter("conf");
 		fileBrowser.Filter = &fileFilter;
-		
 		if (fileBrowser.exec("/var/tuxbox/config") == true) 
 		{
 			loadKeys(fileBrowser.getSelectedFile()->Name.c_str());
 			dprintf(DEBUG_NORMAL, "CNeutrinoApp::exec: new keys: %s\n", fileBrowser.getSelectedFile()->Name.c_str());
 		}
-		
 		return menu_return::RETURN_REPAINT;
 	}
 	else if(actionKey == "savekeys") 
 	{
 		parent->hide();
-		
 		CFileBrowser fileBrowser;
 		fileBrowser.Dir_Mode = true;
-		
 		if (fileBrowser.exec("/var/tuxbox") == true) 
 		{
 			char  fname[256] = "keys.conf", sname[256];
@@ -5293,7 +5250,6 @@
 			saveKeys(sname);
 			delete sms;
 		}
-		
 		return menu_return::RETURN_REPAINT;
 	}
 	else if(actionKey == "clearSectionsd")
@@ -5664,7 +5620,7 @@
 	
 	if(ttx) 
 	{
-		tuxtx_pause_subtitle(true, si.FeIndex);
+		tuxtx_pause_subtitle(true);
 		frameBuffer->paintBackground();
 #ifdef FB_BLIT
 		frameBuffer->blit();
@@ -5688,7 +5644,7 @@
 	dvbsub_start(0);
 	
 	// tuxtxt
-	tuxtx_pause_subtitle(false, si.FeIndex);
+	tuxtx_pause_subtitle(false);
 }
 
 // select subtitle

--- neutrino-hd2/lib/libtuxtxt/tuxtxt.cpp	2012-06-27 00:39:42.949809616 +0200
+++ neutrino-hd2/lib/libtuxtxt/tuxtxt.cpp	2012-07-12 18:41:50.467647249 +0200
@@ -21,14 +21,19 @@
 #include <signal.h>
 #include <sys/select.h>
 #include <sys/time.h>
+//#include <system/set_threadname.h>
 #include <unistd.h>
-
+#include "teletext.h"
 #include "tuxtxt.h"
 
 #include <dmx_cs.h>
 
 #include <driver/framebuffer.h>
 
+#define KEY_TTTV	KEY_FN_1
+#define KEY_TTZOOM	KEY_FN_2
+#define KEY_REVEAL	KEY_FN_D
+
 int log_level = 0;
 
 #define debugf(i, arg...) \
@@ -1526,6 +1531,7 @@
 static void * reader_thread(void * /*arg*/)
 {
 	printf("TuxTxt subtitle thread started\n");
+//	set_threadname("ttx_reader_thread");
 	reader_running = 1;
 	
 	//ttx_paused = 0;
@@ -1553,14 +1559,13 @@
 	pthread_exit(NULL);
 }
 
-int tuxtx_main(int _rc, int pid, int page, int source);
-void tuxtx_pause_subtitle(bool pause, int source)
+void tuxtx_pause_subtitle(bool pause)
 {
 	if(!pause) {
 		printf("TuxTxt subtitle unpause, running %d pid %d page %d\n", reader_running, sub_pid, sub_page);
 		ttx_paused = 0;
 		if(!reader_running && sub_pid && sub_page)
-			tuxtx_main(0, sub_pid, sub_page, source);
+			tuxtx_main(0, sub_pid, sub_page);
 	}
 	else 
 	{
@@ -1622,11 +1627,13 @@
 }
 #endif
 //
-
-int tuxtx_main(int _rc, int pid, int page, int source)
+static int ttx_repeat_blocker = 125000;
+static int ttx_repeat_genericblocker = 250000;
+int tuxtx_main(int _rc, int pid, int page, int source, int repeat_blocker, int repeat_genericblocker)
 {
 	char cvs_revision[] = "$Revision: 1.95 $";
-
+	ttx_repeat_blocker = repeat_blocker * 2000;
+	ttx_repeat_genericblocker = repeat_genericblocker * 2000;
 	debugf(1, "%s: >\n", __func__);
 	
 	use_gui = 1;
@@ -6515,14 +6522,19 @@
 	debugf(2, "%s: <\n", __func__);
 }
 
-/*
- * GetRCCode
-*/
+/******************************************************************************
+ * GetRCCode                                                                  *
+ ******************************************************************************/
+#if 1
 int GetRCCode()
 {
 	struct input_event ev;
 	static __u16 rc_last_key = KEY_RESERVED;
 
+        static uint64_t time_last = 0;
+	RCCode = -1;
+
+
 	int val = fcntl(rc, F_GETFL);
 	if(!(val & O_NONBLOCK))
 		printf("[tuxtxt] GetRCCode in blocking mode.\n");
@@ -6532,80 +6544,164 @@
 	{
 		if (ev.value)
 		{
-			if (ev.code != rc_last_key)
+
+        		uint64_t time_now = (uint64_t) ev.time.tv_usec + (uint64_t)((uint64_t) ev.time.tv_sec * (uint64_t) 1000000);
+			if (ev.code == rc_last_key && time_last + ttx_repeat_blocker> time_now
+				&& (ev.code == KEY_DOWN || ev.code == KEY_UP || ev.code == KEY_LEFT || ev.code == KEY_RIGHT)) {
+				// purge input buffer
+				if(!(val & O_NONBLOCK))
+					fcntl(rc, F_SETFL, val | O_NONBLOCK);
+					while (read(rc, &ev, sizeof(ev)) == sizeof(ev));
+				if(!(val & O_NONBLOCK))
+					fcntl(rc, F_SETFL, val);
+				return 0;
+			}
+			if (ev.code == rc_last_key && time_last + ttx_repeat_genericblocker > time_now) {
+				// purge input buffer
+				if(!(val & O_NONBLOCK))
+					fcntl(rc, F_SETFL, val | O_NONBLOCK);
+					while (read(rc, &ev, sizeof(ev)) == sizeof(ev));
+				if(!(val & O_NONBLOCK))
+					fcntl(rc, F_SETFL, val);
+				return 0;
+			}
+			if (time_last + ttx_repeat_genericblocker < time_now)
+				rc_last_key = KEY_RESERVED;
+			time_last = time_now;
+
 			{
 				rc_last_key = ev.code;
 				switch (ev.code)
 				{
-#if defined (PLATFORM_CUBEREVO) || defined (PLATFORM_CUBEREVO_MINI) || defined (PLATFORM_CUBEREVO_MINI2) || defined (PLATFORM_CUBEREVO_MINI_FTA) || defined (PLATFORM_CUBEREVO_250HD) || defined (PLATFORM_CUBEREVO_2000HD) || defined (PLATFORM_CUBEREVO_9500HD)					  
-					case 0x67: 		RCCode = RC_UP;	break;	
-					case 0x6c: 		RCCode = RC_DOWN; break;	
-					case 0x69:		RCCode = RC_LEFT; break;	
-					case 0x6A:		RCCode = RC_RIGHT; break;
-					case 0x160:		RCCode = RC_OK;	break;
-#else
-					case KEY_UP:		RCCode = RC_UP;		break;
-					case KEY_DOWN:		RCCode = RC_DOWN;	break;
-					case KEY_LEFT:		RCCode = RC_LEFT;	break;
-					case KEY_RIGHT:		RCCode = RC_RIGHT;	break;
-					case KEY_OK:		RCCode = RC_OK;		break;
-#endif
-
-					// common
-					case KEY_0:		RCCode = RC_0; 		break;
-					case KEY_1:		RCCode = RC_1;		break;
-					case KEY_2:		RCCode = RC_2;		break;
-					case KEY_3:		RCCode = RC_3;		break;
-					case KEY_4:		RCCode = RC_4;		break;
-					case KEY_5:		RCCode = RC_5;		break;
-					case KEY_6:		RCCode = RC_6;		break;
-					case KEY_7:		RCCode = RC_7;		break;
-					case KEY_8:		RCCode = RC_8;		break;
-					case KEY_9:		RCCode = RC_9;		break;
-					
-					case KEY_RED:		RCCode = RC_RED;	break;
-					case KEY_GREEN:		RCCode = RC_GREEN;	break;
-					case KEY_YELLOW:	RCCode = RC_YELLOW;	break;
-					case KEY_BLUE:		RCCode = RC_BLUE;	break;
-
-#if defined (PLATFORM_CUBEREVO) || defined (PLATFORM_CUBEREVO_MINI) || defined (PLATFORM_CUBEREVO_MINI2) || defined (PLATFORM_CUBEREVO_MINI_FTA) || defined (PLATFORM_CUBEREVO_250HD) || defined (PLATFORM_CUBEREVO_2000HD) || defined (PLATFORM_CUBEREVO_9500HD)						
-					case 0xBB:		RCCode = RC_PLUS;	break;
-					case 0xBC:		RCCode = RC_MINUS;	break;
-					case 0x71:		RCCode = RC_MUTE;	break;
-					case 0x173:		RCCode = RC_TEXT;	break;
-					case 0x166:		RCCode = RC_HELP;	break;
-					case 0x8B:		RCCode = RC_DBOX;	break;
-					case 0x9E:		RCCode = RC_HOME;	break;
-					case 0x74:		RCCode = RC_STANDBY;	break;
-#else
-					case KEY_VOLUMEUP:	RCCode = RC_PLUS;	break;
-					case KEY_VOLUMEDOWN:	RCCode = RC_MINUS;	break;
-					case KEY_MUTE:		RCCode = RC_MUTE;	break;
-					case KEY_TEXT:		RCCode = RC_TEXT;	break;
-					//case KEY_HELP:		RCCode = RC_HELP;	break;
-					case KEY_INFO:		RCCode = RC_HELP;	break;
-					case KEY_MENU:		RCCode = RC_DBOX;	break;
-#if defined (PLATFORM_GIGABLUE_800SE)
-					case 0xAE:		RCCode = RC_HOME;	break;
-#else
-					case KEY_EXIT:		RCCode = RC_HOME;	break;
-#endif					
-					case KEY_POWER:		RCCode = RC_STANDBY;	break;
-#endif
-				}
-				printf("[tuxtxt] new key, code 0x%X (%d)\n", RCCode, KEY_EXIT);
+				case KEY_UP:		RCCode = RC_UP;		break;
+				case KEY_DOWN:		RCCode = RC_DOWN;	break;
+				case KEY_LEFT:		RCCode = RC_LEFT;	break;
+				case KEY_RIGHT:		RCCode = RC_RIGHT;	break;
+				case KEY_OK:		RCCode = RC_OK;		break;
+				case KEY_0:		RCCode = RC_0;		break;
+				case KEY_1:		RCCode = RC_1;		break;
+				case KEY_2:		RCCode = RC_2;		break;
+				case KEY_3:		RCCode = RC_3;		break;
+				case KEY_4:		RCCode = RC_4;		break;
+				case KEY_5:		RCCode = RC_5;		break;
+				case KEY_6:		RCCode = RC_6;		break;
+				case KEY_7:		RCCode = RC_7;		break;
+				case KEY_8:		RCCode = RC_8;		break;
+				case KEY_9:		RCCode = RC_9;		break;
+				case KEY_RED:		RCCode = RC_RED;	break;
+				case KEY_GREEN:		RCCode = RC_GREEN;	break;
+				case KEY_YELLOW:	RCCode = RC_YELLOW;	break;
+				case KEY_BLUE:		RCCode = RC_BLUE;	break;
+				case KEY_VOLUMEUP:	RCCode = RC_PLUS;	break;
+				case KEY_VOLUMEDOWN:	RCCode = RC_MINUS;	break;
+				case KEY_MUTE:		RCCode = RC_MUTE;	break;
+
+				/* on CS, change transparent mode with TEXT key */
+				case KEY_TEXT:		RCCode = RC_TEXT;	break;
+
+				case KEY_TTTV:		RCCode = RC_MUTE;	break;
+				case KEY_TTZOOM:	RCCode = RC_PLUS;	break;
+				case KEY_REVEAL:	RCCode = RC_HELP;	break;
+				//case KEY_HELP:		RCCode = RC_HELP;	break;
+				case KEY_INFO:		RCCode = RC_HELP;	break;
+				case KEY_MENU:		RCCode = RC_DBOX;	break;
+				case KEY_EXIT:		RCCode = RC_HOME;	break;
+
+				case KEY_HOME:		RCCode = RC_HOME;	break;
+
+				case KEY_POWER:		RCCode = RC_STANDBY;	break;
+				}
+printf("[tuxtxt] new key, code %X\n", RCCode);
+
+				// purge input buffer
+				if(!(val & O_NONBLOCK))
+					fcntl(rc, F_SETFL, val | O_NONBLOCK);
+				while (read(rc, &ev, sizeof(ev)) == sizeof(ev));
+				if(!(val & O_NONBLOCK))
+					fcntl(rc, F_SETFL, val);
+
 				return 1;
 			}
 		}
-		else
-		{
-			RCCode = -1;
-			rc_last_key = KEY_RESERVED;
-		}
 	}
 
-	RCCode = -1;
-	usleep(1000000/100);
+
+	// purge input buffer
+	if(!(val & O_NONBLOCK))
+		fcntl(rc, F_SETFL, val | O_NONBLOCK);
+	while (read(rc, &ev, sizeof(ev)) == sizeof(ev));
+	if(!(val & O_NONBLOCK))
+		fcntl(rc, F_SETFL, val);
+
+	usleep(1000000/25);
 
 	return 0;
 }
+#else
+/* this is obsolete and can soon be removed */
+int GetRCCode()
+{
+	static unsigned short LastKey = -1;
+	int count;
+	if ((count = read(rc, &RCCode, 2)) != 2)
+	{
+		RCCode = -1;
+		usleep(1000000/100);
+		return 0;
+	}
+
+	fprintf(stderr, "rccode: %04x\n", RCCode);
+	if (RCCode == LastKey &&
+	    RCCode != 0x18 && RCCode != 0x19 && /* allow direction keys */
+	    RCCode != 0x1b && RCCode != 0x1c)   /* to autorepeat...     */
+	{
+		RCCode = -1;
+		return 1;
+	}
+
+	LastKey = RCCode;
+	if ((RCCode & 0xFF00) == 0x0000)
+	{
+		switch (RCCode)
+		{
+		case 0x18:	RCCode = RC_UP;		break;
+		case 0x1c:	RCCode = RC_DOWN;	break;
+		case 0x19:	RCCode = RC_LEFT;	break;
+		case 0x1b:	RCCode = RC_RIGHT;	break;
+		case 0x1a:	RCCode = RC_OK;		break;
+		case 0x0e:	RCCode = RC_0;		break;
+		case 0x02:	RCCode = RC_1;		break;
+		case 0x03:	RCCode = RC_2;		break;
+		case 0x04:	RCCode = RC_3;		break;
+		case 0x05:	RCCode = RC_4;		break;
+		case 0x06:	RCCode = RC_5;		break;
+		case 0x07:	RCCode = RC_6;		break;
+		case 0x09:	RCCode = RC_7;		break;
+		case 0x0a:	RCCode = RC_8;		break;
+		case 0x0b:	RCCode = RC_9;		break;
+		case 0x1f:	RCCode = RC_RED;	break;
+		case 0x20:	RCCode = RC_GREEN;	break;
+		case 0x21:	RCCode = RC_YELLOW;	break;
+		case 0x22:	RCCode = RC_BLUE;	break;
+		case 0x29:	RCCode = RC_PLUS;	break; // [=X=] key -> double height
+		case 0x27:	RCCode = RC_MINUS;	break; // [txt] key -> split mode
+		case 0x11:	RCCode = RC_MUTE;	break;
+		case 0x28:	RCCode = RC_MUTE;	break; // [ /=] key
+		case 0x14:	RCCode = RC_HELP;	break;
+		case 0x2a:	RCCode = RC_HELP;	break; // [==?] key
+		case 0x12:	RCCode = RC_DBOX;	break;
+		case 0x15:	RCCode = RC_HOME;	break;
+		case 0x01:	RCCode = RC_STANDBY;	break;
+		}
+		return 1;
+	}
+	return 1;
+}
+#endif
+/* Local Variables: */
+/* indent-tabs-mode:t */
+/* tab-width:3 */
+/* c-basic-offset:3 */
+/* comment-column:0 */
+/* fill-column:120 */
+/* End: */

--- neutrino-hd2/src/system/setting_helpers.cpp	2012-06-27 00:39:46.077825130 +0200
+++ neutrino-hd2/src/system/setting_helpers.cpp	2012-07-12 18:42:27.791832334 +0200
@@ -62,6 +62,7 @@
 
 #include <zapit/frontend_c.h>
 #include <gui/scan_setup.h>
+#include "libtuxtxt/teletext.h"
 
 extern CPlugins       * g_PluginList;    /* neutrino.cpp */
 extern CRemoteControl * g_RemoteControl; /* neutrino.cpp */
@@ -91,7 +92,7 @@
 extern void tuxtx_stop_subtitle();
 extern void tuxtx_set_pid(int pid, int page, const char * cc);
 //extern int tuxtx_subtitle_running(int *pid, int *page, int *running);
-extern int tuxtx_main(int _rc, int pid, int page, int source );
+//extern int tuxtx_main(int _rc, int pid, int page, int source );
 
 extern int tuner_to_scan;		//defined in scan_setup.cpp
 
@@ -609,7 +610,7 @@
 		//	tuxtxt_start( g_RemoteControl->current_PIDs.PIDs.vtxtpid, si.FeIndex );
 		
 		// start tuxtxt
-		tuxtx_main(g_RCInput->getFileHandle(), pid, page, si.FeIndex ); // this 
+		tuxtx_main(g_RCInput->getFileHandle(), pid, page);
 	}
 	
         return menu_return::RETURN_EXIT;

--- neutrino-hd2/lib/libtuxtxt/teletext.h	1970-01-01 01:00:00.000000000 +0100
+++ neutrino-hd2/lib/libtuxtxt/teletext.h	2012-07-12 19:32:14.386642061 +0200
@@ -0,0 +1,16 @@
+#ifndef __teletext_h__
+#define __teletext_h__
+
+int tuxtxt_init();
+void tuxtxt_close();
+void tuxtxt_start(int tpid, int source = 0);  // Start caching
+int  tuxtxt_stop(); // Stop caching
+
+int tuxtx_main(int _rc, int pid, int page = 0, int source = 0, int repeat_blocker = 2000, int repeat_genericblocker = 1000);
+
+void tuxtx_stop_subtitle();
+int tuxtx_subtitle_running(int *pid, int *page, int *running);
+void tuxtx_pause_subtitle(bool pause = 1);
+void tuxtx_set_pid(int pid, int page, const char * cc);
+
+#endif

--- neutrino-hd2/src/Makefile.am	2012-07-12 21:14:57.153201571 +0200
+++ neutrino-hd2/src/Makefile.am	2012-07-12 21:23:23.999714883 +0200
@@ -75,19 +75,3 @@
 	-lass
 endif
 
-# LCD display
-neutrino_LDADD += \
-	$(top_builddir)/lib/liblcddisplay/liblcddisplay.a
-
-
-
-
-
-
-
-
-
-	
-
-
-

###here next patch
