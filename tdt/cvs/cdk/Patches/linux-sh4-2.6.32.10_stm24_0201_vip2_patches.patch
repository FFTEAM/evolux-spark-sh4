*** linux-sh4-2.6.32.10_stm24_0201_orig/arch/sh/boards/mach-mb442/setup.c	Mon May  3 15:59:09 2010
--- linux-sh4/arch/sh/boards/mach-mb442/setup.c	Mon May  3 17:15:50 2010
***************
*** 21,34 ****
  #include <linux/mtd/physmap.h>
  #include <linux/stm/platform.h>
  #include <linux/stm/stx7100.h>
  #include <asm/irl.h>
  
! 
! 
! #define MB442_PIO_STE100P_RESET stm_gpio(2, 4)
! #define MB442_PIO_SMC91X_RESET stm_gpio(2, 6)
  #define MB442_PIO_FLASH_VPP stm_gpio(2, 7)
  
  
  
  void __init mb442_setup(char** cmdline_p)
--- 21,51 ----
  #include <linux/mtd/physmap.h>
  #include <linux/stm/platform.h>
  #include <linux/stm/stx7100.h>
+ #include <linux/bpa2.h>
  #include <asm/irl.h>
  
! #define MB442_PIO_PHY_RESET stm_gpio(3, 6)
  #define MB442_PIO_FLASH_VPP stm_gpio(2, 7)
  
+ const char *LMI_VID_partalias[] = { "BPA2_Region1", "coredisplay-video", "gfx-memory", "v4l2-video-buffers", NULL };
+ const char *LMI_SYS_partalias[] = { "BPA2_Region0", "bigphysarea", "v4l2-coded-video-buffers", NULL };
+ 
+ static struct bpa2_partition_desc bpa2_parts_table[] = {
+ 	{
+ 		.name  = "LMI_VID",
+ 		.start = 0x10800000,
+ 		.size  = 0x03800000,
+ 		.flags = 0,
+ 		.aka   = LMI_VID_partalias
+ 	},
+ 	{
+ 		.name  = "LMI_SYS",
+ 		.start = 0,
+ 		.size  = 0x01600000,
+ 		.flags = 0,
+ 		.aka   = LMI_SYS_partalias
+ 	}
+ };
  
  
  void __init mb442_setup(char** cmdline_p)
***************
*** 43,48 ****
--- 60,67 ----
  	stx7100_configure_asc(3, &(struct stx7100_asc_config) {
  			.hw_flow_control = 0,
  			.is_console = 0, });
+ 
+  	bpa2_init(bpa2_parts_table, ARRAY_SIZE(bpa2_parts_table));
  }
  
  static struct resource mb442_smc91x_resources[] = {
***************
*** 86,96 ****
  
  static int mb442_phy_reset(void* bus)
  {
! 	gpio_set_value(MB442_PIO_STE100P_RESET, 1);
  	udelay(1);
! 	gpio_set_value(MB442_PIO_STE100P_RESET, 0);
  	udelay(1);
! 	gpio_set_value(MB442_PIO_STE100P_RESET, 1);
  
  	return 1;
  }
--- 105,115 ----
  
  static int mb442_phy_reset(void* bus)
  {
! 	gpio_set_value(MB442_PIO_PHY_RESET, 1);
  	udelay(1);
! 	gpio_set_value(MB442_PIO_PHY_RESET, 0);
  	udelay(1);
! 	gpio_set_value(MB442_PIO_PHY_RESET, 1);
  
  	return 1;
  }
***************
*** 119,125 ****
  };
  
  static struct platform_device *mb442_devices[] __initdata = {
! 	&mb442_smc91x_device,
  	&mb442_physmap_flash,
  	&mb442_phy_device,
  };
--- 138,144 ----
  };
  
  static struct platform_device *mb442_devices[] __initdata = {
! 	/*&mb442_smc91x_device,*/
  	&mb442_physmap_flash,
  	&mb442_phy_device,
  };
***************
*** 128,139 ****
  {
  	stx7100_configure_sata();
  
! 	stx7100_configure_pwm(&(struct stx7100_pwm_config) {
  			.out0_enabled = 0,
! 			.out1_enabled = 1, });
  
  	stx7100_configure_ssc_i2c(0);
! 	stx7100_configure_ssc_spi(1, NULL);
  	stx7100_configure_ssc_i2c(2);
  
  	stx7100_configure_usb();
--- 147,158 ----
  {
  	stx7100_configure_sata();
  
! 	/*stx7100_configure_pwm(&(struct stx7100_pwm_config) {
  			.out0_enabled = 0,
! 			.out1_enabled = 1, });*/
  
  	stx7100_configure_ssc_i2c(0);
! 	stx7100_configure_ssc_i2c(1);
  	stx7100_configure_ssc_i2c(2);
  
  	stx7100_configure_usb();
***************
*** 151,158 ****
  	gpio_request(MB442_PIO_FLASH_VPP, "Flash VPP");
  	gpio_direction_output(MB442_PIO_FLASH_VPP, 0);
  
! 	gpio_request(MB442_PIO_STE100P_RESET, "STE100P reset");
! 	gpio_direction_output(MB442_PIO_STE100P_RESET, 1);
  
  	stx7100_configure_ethernet(&(struct stx7100_ethernet_config) {
  			.mode = stx7100_ethernet_mode_mii,
--- 170,177 ----
  	gpio_request(MB442_PIO_FLASH_VPP, "Flash VPP");
  	gpio_direction_output(MB442_PIO_FLASH_VPP, 0);
  
! 	gpio_request(MB442_PIO_PHY_RESET, "PHY reset");
! 	gpio_direction_output(MB442_PIO_PHY_RESET, 1);
  
  	stx7100_configure_ethernet(&(struct stx7100_ethernet_config) {
  			.mode = stx7100_ethernet_mode_mii,
***************
*** 160,171 ****
  			.phy_bus = 0, });
  
  	/* Reset the SMSC 91C111 Ethernet chip */
! 	gpio_request(MB442_PIO_SMC91X_RESET, "SMC91x reset");
  	gpio_direction_output(MB442_PIO_SMC91X_RESET, 0);
  	udelay(1);
  	gpio_set_value(MB442_PIO_SMC91X_RESET, 1);
  	udelay(1);
! 	gpio_set_value(MB442_PIO_SMC91X_RESET, 0);
  
  	return platform_add_devices(mb442_devices,
  			ARRAY_SIZE(mb442_devices));
--- 179,190 ----
  			.phy_bus = 0, });
  
  	/* Reset the SMSC 91C111 Ethernet chip */
! 	/*gpio_request(MB442_PIO_SMC91X_RESET, "SMC91x reset");
  	gpio_direction_output(MB442_PIO_SMC91X_RESET, 0);
  	udelay(1);
  	gpio_set_value(MB442_PIO_SMC91X_RESET, 1);
  	udelay(1);
! 	gpio_set_value(MB442_PIO_SMC91X_RESET, 0);*/
  
  	return platform_add_devices(mb442_devices,
  			ARRAY_SIZE(mb442_devices));
*** linux-sh4-2.6.32.10_stm24_0201_orig/drivers/net/stmmac/stmmac_main.c	Mon May  3 15:58:46 2010
--- linux-sh4/drivers/net/stmmac/stmmac_main.c	Mon May  3 17:15:50 2010
***************
*** 867,873 ****
  		return -1;
  	}
  
! 	/* Copy the MAC addr into the HW  */
  	priv->hw->mac->set_umac_addr(ioaddr, dev->dev_addr, 0);
  	/* If required, perform hw setup of the bus. */
  	if (priv->bus_setup)
--- 867,873 ----
  		return -1;
  	}
  
! 	/* Copy the MAC addr into the HW  */ // TODO
  	priv->hw->mac->set_umac_addr(ioaddr, dev->dev_addr, 0);
  	/* If required, perform hw setup of the bus. */
  	if (priv->bus_setup)
*** linux-sh4-2.6.32.10_stm24_0201_orig/drivers/net/stmmac/stmmac_mdio.c	Mon May  3 15:58:46 2010
--- linux-sh4/drivers/net/stmmac/stmmac_mdio.c	Mon May  3 17:15:50 2010
***************
*** 175,181 ****
  	for (addr = 0; addr < 32; addr++) {
  		struct phy_device *phydev = new_bus->phy_map[addr];
  		if (phydev) {
! 			if (priv->phy_addr == -1) {
  				priv->phy_addr = addr;
  				phydev->irq = priv->phy_irq;
  				irqlist[addr] = priv->phy_irq;
--- 175,181 ----
  	for (addr = 0; addr < 32; addr++) {
  		struct phy_device *phydev = new_bus->phy_map[addr];
  		if (phydev) {
! 			/*if (priv->phy_addr == -1)*/ {
  				priv->phy_addr = addr;
  				phydev->irq = priv->phy_irq;
  				irqlist[addr] = priv->phy_irq;
*** linux-sh4-2.6.32.10_stm24_0201_orig/drivers/usb/storage/usb.c	Mon May  3 15:58:31 2010
--- linux-sh4/drivers/usb/storage/usb.c	Mon May  3 17:21:12 2010
***************
*** 74,80 ****
  MODULE_DESCRIPTION("USB Mass Storage driver for Linux");
  MODULE_LICENSE("GPL");
  
! static unsigned int delay_use = 5;
  module_param(delay_use, uint, S_IRUGO | S_IWUSR);
  MODULE_PARM_DESC(delay_use, "seconds to delay before using a new device");
  
--- 74,80 ----
  MODULE_DESCRIPTION("USB Mass Storage driver for Linux");
  MODULE_LICENSE("GPL");
  
! static unsigned int delay_use = 0;
  module_param(delay_use, uint, S_IRUGO | S_IWUSR);
  MODULE_PARM_DESC(delay_use, "seconds to delay before using a new device");
  
*** linux-sh4-2.6.32.10_stm24_0201_orig/drivers/stm/copro-st_socs.c	Mon May  3 15:59:01 2010
--- linux-sh4/drivers/stm/copro-st_socs.c	Mon May  3 19:37:29 2010
***************
*** 3,8 ****
--- 3,9 ----
  #include <linux/init.h>
  #include <linux/delay.h>
  #include <linux/seq_file.h>
+ #include <linux/stm/stx7100.h>
  #include <linux/stm/coprocessor.h>
  #include <linux/stm/sysconf.h>
  #include <linux/pfn.h>
*** linux-sh4-2.6.32.10_stm24_0201_orig/arch/sh/mm/init.c	Mon May  3 15:59:09 2010
--- linux-sh4/arch/sh/mm/init.c	Tue May  4 00:08:16 2010
***************
*** 133,138 ****
--- 133,140 ----
  		j = 0;
  	}
  }
+ 
+ EXPORT_SYMBOL(init_mm);
  #endif	/* CONFIG_MMU */
  
  /*
diff -rcN linux-sh4-2.6.32.10_stm24_0201_orig/kernel/time/timekeeping.c linux-sh4/kernel/time/timekeeping.c
*** linux-sh4-2.6.32.10_stm24_0201_orig/kernel/time/timekeeping.c	Mon May  3 15:59:19 2010
--- linux-sh4/kernel/time/timekeeping.c	Tue May  4 00:55:58 2010
***************
*** 137,142 ****
--- 137,144 ----
   */
  __cacheline_aligned_in_smp DEFINE_SEQLOCK(xtime_lock);
  
+ EXPORT_SYMBOL(xtime_lock);
+ 
  
  /*
   * The current time
***************
*** 156,161 ****
--- 158,165 ----
  struct timespec xtime __attribute__ ((aligned (16)));
  struct timespec wall_to_monotonic __attribute__ ((aligned (16)));
  static struct timespec total_sleep_time;
+ EXPORT_SYMBOL(xtime);
+ EXPORT_SYMBOL_GPL(wall_to_monotonic);
  
  /*
   * The raw monotonic time for the CLOCK_MONOTONIC_RAW posix clock.
diff -rcN linux-sh4-2.6.32.10_stm24_0201_orig/sound/core/oss/pcm_oss.c linux-sh4/sound/core/oss/pcm_oss.c
*** linux-sh4-2.6.32.10_stm24_0201_orig/sound/core/oss/pcm_oss.c	Mon May  3 15:58:10 2010
--- linux-sh4/sound/core/oss/pcm_oss.c	Tue May  4 01:00:33 2010
***************
*** 219,224 ****
--- 219,226 ----
  	return 0;
  }
  
+ EXPORT_SYMBOL_GPL(snd_pcm_hw_param_mask);
+ 
  static int _snd_pcm_hw_param_min(struct snd_pcm_hw_params *params,
  				 snd_pcm_hw_param_t var, unsigned int val,
  				 int dir)
***************
*** 278,283 ****
--- 280,287 ----
  	return snd_pcm_hw_param_value_min(params, var, dir);
  }
  
+ EXPORT_SYMBOL_GPL(_snd_pcm_hw_param_min);
+ 
  static int _snd_pcm_hw_param_max(struct snd_pcm_hw_params *params,
  				 snd_pcm_hw_param_t var, unsigned int val,
  				 int dir)
***************
*** 467,472 ****
--- 471,478 ----
  	return v;
  }
  
+ EXPORT_SYMBOL_GPL(snd_pcm_hw_param_near);
+ 
  static int _snd_pcm_hw_param_set(struct snd_pcm_hw_params *params,
  				 snd_pcm_hw_param_t var, unsigned int val,
  				 int dir)
***************
*** 543,548 ****
--- 549,556 ----
  	return snd_pcm_hw_param_value(params, var, NULL);
  }
  
+ EXPORT_SYMBOL_GPL(snd_pcm_hw_param_set);
+ 
  static int _snd_pcm_hw_param_setinteger(struct snd_pcm_hw_params *params,
  					snd_pcm_hw_param_t var)
  {
***************
*** 554,560 ****
  	}
  	return changed;
  }
! 	
  /*
   * plugin
   */
--- 562,570 ----
  	}
  	return changed;
  }
! 
! EXPORT_SYMBOL_GPL(_snd_pcm_hw_param_setinteger);
! 
  /*
   * plugin
   */
diff -rcN linux-sh4-2.6.32.10_stm24_0201_orig/sound/core/pcm_native.c linux-sh4/sound/core/pcm_native.c
*** linux-sh4-2.6.32.10_stm24_0201_orig/sound/core/pcm_native.c	Mon May  3 15:58:10 2010
--- linux-sh4/sound/core/pcm_native.c	Tue May  4 00:46:19 2010
***************
*** 885,890 ****
--- 885,892 ----
  			      SNDRV_PCM_STATE_RUNNING);
  }
  
+ EXPORT_SYMBOL(snd_pcm_start);
+ 
  /*
   * stop callbacks
   */
***************
*** 1879,1884 ****
--- 1881,1888 ----
  	return 0;
  }
  
+ EXPORT_SYMBOL_GPL(snd_pcm_hw_constraints_init);
+ 
  int snd_pcm_hw_constraints_complete(struct snd_pcm_substream *substream)
  {
  	struct snd_pcm_runtime *runtime = substream->runtime;
***************
*** 1962,1967 ****
--- 1966,1973 ----
  	return 0;
  }
  
+ EXPORT_SYMBOL_GPL(snd_pcm_hw_constraints_complete);
+ 
  static void pcm_release_private(struct snd_pcm_substream *substream)
  {
  	snd_pcm_unlink(substream);
